/**
 * Our W3C DOM Node implementation. Note we call it XNode because we
 * can't define the identifier Node. We do this mostly for Opera,
 * where we can't reuse the HTML DOM for parsing our own XML, and for
 * Safari, where it is too expensive to have the template processor.
 */
declare class XNode {
    id: number;
    childNodes: XNode[];
    nodeType: number;
    nodeName: string;
    nodeValue: any;
    firstChild: XNode;
    lastChild: XNode;
    nextSibling: XNode;
    previousSibling: XNode;
    siblingPosition: number;
    ownerDocument: any;
    namespaceUri: any;
    prefix: string;
    localName: string;
    parentNode: XNode;
    visited: boolean;
    escape: boolean;
    fromXslText: boolean;
    static _unusedXNodes: any[];
    constructor(type: number, name: string, opt_value: any, opt_owner: any, opt_namespace?: any);
    /**
     * Node initialization. Called by the constructor and `recycle` method.
     * @param type The node type.
     * @param name The node name.
     * @param value The node value.
     * @param owner The node owner.
     * @param namespaceUri The node namespace.
     */
    init(type: number, name: string, value: string, owner: any, namespaceUri: any): void;
    protected qualifiedNameToParts(name: string): string[];
    protected domTraverseElements(node: XNode, opt_pre: Function, opt_post: any): boolean;
    static recycle(node: any): void;
    static create(type: any, name: string, value: any, owner: any, namespace?: any): XNode;
    static clone(node: XNode, newOwner: XNode): XNode;
    appendChild(node: XNode): void;
    replaceChild(newNode: any, oldNode: any): void;
    insertBefore(newNode: any, oldNode: any): void;
    removeChild(node: XNode): void;
    hasAttributes(): boolean;
    setAttribute(name: string, value: any): void;
    setAttributeNS(namespace: any, name: any, value: any): void;
    getAttributeValue(name: string): any;
    getAttributeNS(namespace: any, localName: any): any;
    hasAttribute(name: string): boolean;
    hasAttributeNS(namespace: string, localName: string): boolean;
    removeAttribute(name: string): void;
    removeAttributeNS(namespace: string, localName: string): void;
    getElementsByTagName(name: string): any[];
    getElementsByTagNameNS(namespace: string, localName: string): any[];
    getElementById(id: any): any;
    getAncestorByLocalName(localName: string): XNode | undefined;
    getAncestorById(id: number): XNode | undefined;
    toString(): string;
}

declare class XDocument extends XNode {
    documentElement: any;
    constructor();
    appendChild(node: any): void;
    createElement(name: string): XNode;
    createElementNS(namespace: any, name: any): XNode;
    createDocumentFragment(): XNode;
    createTextNode(value: any): XNode;
    createAttribute(name: any): XNode;
    createAttributeNS(namespace: any, name: any): XNode;
    createComment(data: any): XNode;
    createCDATASection(data: any): XNode;
    createDTDSection(data: any): XNode;
    createProcessingInstruction(target: string, data: any): XNode;
}

/**
 * Escape XML special markup characters: tag delimiter <, >, and entity
 * reference start delimiter &. The escaped string can be used in XML
 * text portions (i.e. between tags).
 * @param s The string to be escaped.
 * @returns The escaped string.
 */
declare function xmlEscapeText(s: string): string;

/**
 * Original author: Steffen Meschkat <mesch@google.com> (the `xmlParse` function,
 * now `xmlStrictParse`).
 *
 * An XML parse and a minimal DOM implementation that just supports
 * the subset of the W3C DOM that is used in the XSLT implementation.
 */
declare class XmlParser {
    regexEmpty: RegExp;
    XML10_TAGNAME_REGEXP: RegExp;
    XML10_ATTRIBUTE_REGEXP: RegExp;
    XML11_TAGNAME_REGEXP: RegExp;
    XML11_ATTRIBUTE_REGEXP: RegExp;
    lenientHtmlTags: string[];
    /**
     * The entry point for this parser.
     * It verifies whether the document seems to be HTML.
     * HTML is a special case if XML and it should be parsed differently.
     * @param xmlOrHtml The XML or HTML content to be parsed.
     * @returns A DOM document.
     */
    xmlParse(xmlOrHtml: string): XDocument;
    /**
     * Given an XNode, returns an object mapping prefixes to their corresponding namespaces in its scope.
     * Default namespace is treated as if its prefix were the empty string.
     * @param node The Node.
     * @returns An object with prefixes and namespace URLs.
     */
    private namespaceMapAt;
    /**
     * HTML needs to be parsed differently because it's a special case of XML.
     * Sources:
     *
     * - https://blog.teamtreehouse.com/to-close-or-not-to-close-tags-in-html5
     * @param htmlText The HTML text
     * @returns A DOM document.
     */
    private htmlParse;
    /**
     * Parses the given XML string with our custom, JavaScript XML parser.
     * @param xml The XML String.
     * @returns A XDocument.
     * @author Steffen Meschkat <mesch@google.com>
     */
    private xmlStrictParse;
}

type XsltParameter = {
    name: string;
    namespaceUri?: string;
    value: any;
};

/**
 * According to https://www.w3schools.com/xml/ref_xsl_el_decimal-format.asp:
 *
 * @property {string} name: Optional. Specifies a name for this format.
 * @property {string} decimalSeparator: Optional. Specifies the decimal point character. Default is ".".
 * @property {string} groupingSeparator: Optional. Specifies the thousands separator character. Default is ",".
 * @property {string} infinity: Optional. Specifies the string used to represent infinity. Default is "Infinity".
 * @property {string} minusSign: Optional. Specifies the character to represent negative numbers. Default is "-".
 * @property {string} naN: Optional. Specifies the string used when the value is not a number". Default is "NaN".
 * @property {string} percent: Optional. Specifies the percentage sign character. Default is "%".
 * @property {string} perMille: Optional. Specifies the per thousand sign character. Default is "â€°".
 * @property {string} zeroDigit: Optional. Specifies the digit zero character. Default is "0".
 * @property {string} digit: Optional. Specifies the character used to indicate a place where a digit is required. Default is #.
 * @property {string} patternSeparator: Optional. Specifies the character used to separate positive and negative subpatterns in a format pattern. Default is ";".
 */
type XsltDecimalFormatSettings = {
    name?: string;
    decimalSeparator: string;
    groupingSeparator: string;
    infinity: string;
    minusSign: string;
    naN: string;
    percent: string;
    perMille: string;
    zeroDigit: string;
    digit: string;
    patternSeparator: string;
};
type XsltOptions = {
    cData: boolean;
    escape: boolean;
    selfClosingTags: boolean;
    outputMethod?: 'xml' | 'html' | 'text' | 'xhtml' | 'json' | 'adaptive';
    parameters?: XsltParameter[];
};

interface NodeValue {
    type: string;
    stringValue(): string;
    booleanValue(): boolean;
    numberValue(): number;
    nodeSetValue(): XNode[];
}

/**
 * XPath expression evaluation context. An XPath context consists of a
 * DOM node, a list of DOM nodes that contains this node, a number
 * that represents the position of the single node in the list, and a
 * current set of variable bindings. (See XPath spec.)
 *
 *   setVariable(name, expr) -- binds given XPath expression to the
 *   name.
 *
 *   getVariable(name) -- what the name says.
 *
 *   setNode(position) -- sets the context to the node at the given
 *   position. Needed to implement scoping rules for variables in
 *   XPath. (A variable is visible to all subsequent siblings, not
 *   only to its children.)
 *
 *   set/isCaseInsensitive -- specifies whether node name tests should
 *   be case sensitive.  If you're executing xpaths against a regular
 *   HTML DOM, you probably don't want case-sensitivity, because
 *   browsers tend to disagree about whether elements & attributes
 *   should be upper/lower case.  If you're running xpaths in an
 *   XSLT instance, you probably DO want case sensitivity, as per the
 *   XSL spec.
 *
 *   set/isReturnOnFirstMatch -- whether XPath evaluation should quit as soon
 *   as a result is found. This is an optimization that might make sense if you
 *   only care about the first result.
 *
 *   set/isIgnoreNonElementNodesForNTA -- whether to ignore non-element nodes
 *   when evaluating the "node()" any node test. While technically this is
 *   contrary to the XPath spec, practically it can enhance performance
 *   significantly, and makes sense if you a) use "node()" when you mean "*",
 *   and b) use "//" when you mean "/descendant::* /".
 */
declare class ExprContext {
    position: number;
    nodeList: XNode[];
    xsltVersion: '1.0' | '2.0' | '3.0';
    variables: {
        [name: string]: NodeValue;
    };
    keys: {
        [name: string]: {
            [key: string]: NodeValue;
        };
    };
    knownNamespaces: {
        [alias: string]: string;
    };
    /**
     * Custom system properties for system-property() function.
     * Overrides the default properties (xsl:version, xsl:vendor, xsl:vendor-url).
     */
    systemProperties?: {
        [name: string]: string;
    };
    /**
     * Document loader function for the document() function.
     * Takes a URI and returns an XNode document, or null if loading fails.
     */
    documentLoader?: (uri: string) => XNode | null;
    /**
     * Unparsed entity URIs for the unparsed-entity-uri() function.
     * Maps entity names to their URIs (from DTD declarations).
     */
    unparsedEntities?: {
        [name: string]: string;
    };
    /**
     * Warning callback for non-fatal XPath/XSLT warnings.
     */
    warningsCallback?: (...args: any[]) => void;
    caseInsensitive: any;
    ignoreAttributesWithoutValue: any;
    returnOnFirstMatch: any;
    ignoreNonElementNodesForNTA: any;
    parent: ExprContext;
    root: XNode;
    decimalFormatSettings: XsltDecimalFormatSettings;
    inApplyTemplates: boolean;
    baseTemplateMatched: boolean;
    /**
     * Regex groups from xsl:analyze-string for regex-group() function.
     * Index 0 is the full match, 1+ are captured groups.
     */
    regexGroups?: string[];
    /**
     * Current group from xsl:for-each-group for current-group() function.
     * Contains the nodes/items in the current group being processed.
     */
    currentGroup?: XNode[];
    /**
     * Current grouping key from xsl:for-each-group for current-grouping-key() function.
     * Contains the key value of the current group being processed.
     */
    currentGroupingKey?: any;
    /**
     * User-defined XSLT functions from xsl:function declarations.
     * Maps QName (namespace:localname) to function definition info.
     */
    userDefinedFunctions?: Map<string, {
        functionDef: XNode;
        executor: (context: ExprContext, functionDef: XNode, args: any[]) => any;
    }>;
    /**
     * Constructor -- gets the node, its position, the node set it
     * belongs to, and a parent context as arguments. The parent context
     * is used to implement scoping rules for variables: if a variable
     * is not found in the current context, it is looked for in the
     * parent context, recursively. Except for node, all arguments have
     * default values: default position is 0, default node set is the
     * set that contains only the node, and the default parent is null.
     *
     * Notice that position starts at 0 at the outside interface;
     * inside XPath expressions this shows up as position()=1.
     * @param nodeList TODO
     * @param opt_position TODO
     * @param opt_parent TODO
     * @param opt_caseInsensitive TODO
     * @param opt_ignoreAttributesWithoutValue TODO
     * @param opt_returnOnFirstMatch TODO
     * @param opt_ignoreNonElementNodesForNTA TODO
     */
    constructor(nodeList: XNode[], xsltVersion?: '1.0' | '2.0' | '3.0', opt_position?: number, opt_decimalFormatSettings?: XsltDecimalFormatSettings, opt_variables?: {
        [name: string]: any;
    }, opt_knownNamespaces?: {
        [alias: string]: string;
    }, opt_parent?: ExprContext, opt_caseInsensitive?: any, opt_ignoreAttributesWithoutValue?: any, opt_returnOnFirstMatch?: any, opt_ignoreNonElementNodesForNTA?: any, opt_warningsCallback?: (...args: any[]) => void);
    /**
     * clone() -- creates a new context with the current context as
     * parent. If passed as argument to clone(), the new context has a
     * different node, position, or node set. What is not passed is
     * inherited from the cloned context.
     * @param opt_nodeList TODO
     * @param opt_position TODO
     * @returns TODO
     */
    clone(opt_nodeList?: XNode[], opt_position?: number): ExprContext;
    setVariable(name?: string, value?: NodeValue | string): void;
    getVariable(name: string): NodeValue;
    /**
     * Gets a regex group from xsl:analyze-string context.
     * Searches up the parent chain for regexGroups.
     * @param index Group index (0 = full match, 1+ = captured groups)
     * @returns The group value or empty string if not found
     */
    getRegexGroup(index: number): string;
    setNode(position: number): void;
    contextSize(): number;
    isCaseInsensitive(): any;
    setCaseInsensitive(caseInsensitive: any): any;
    isIgnoreAttributesWithoutValue(): any;
    setIgnoreAttributesWithoutValue(ignore: any): any;
    isReturnOnFirstMatch(): any;
    setReturnOnFirstMatch(returnOnFirstMatch: any): any;
    isIgnoreNonElementNodesForNTA(): any;
    setIgnoreNonElementNodesForNTA(ignoreNonElementNodesForNTA: any): any;
}

/**
 * XPath version support and configuration.
 *
 * This module defines version-specific behavior and prepares for future XPath 2.0/3.0 support.
 */
/**
 * Supported XPath specification versions.
 */
type XPathVersion = '1.0' | '2.0' | '3.0' | '3.1';

/**
 * Represents a DOM-like node interface for XPath evaluation.
 * This is compatible with browser DOM nodes and can be extended for other implementations.
 */
interface XPathNode {
    nodeType: number;
    nodeName: string;
    localName?: string;
    namespaceUri?: string | null;
    textContent?: string | null;
    parentNode?: XPathNode | null;
    childNodes?: ArrayLike<XPathNode>;
    attributes?: ArrayLike<XPathNode>;
    nextSibling?: XPathNode | null;
    previousSibling?: XPathNode | null;
    ownerDocument?: XPathNode | null;
    documentElement?: XPathNode;
    target?: string;
    getAttribute?(name: string): string | null;
    compareDocumentPosition?(other: XPathNode): number;
}

/**
 * Type for custom XPath functions that can be registered in the context.
 */
type XPathFunction = (...args: any[]) => any;
/**
 * Type for the variables map in the context.
 */
type XPathVariables = Record<string, any>;
/**
 * Type for the custom functions map in the context.
 */
type XPathFunctions = Record<string, XPathFunction>;
/**
 * Type for namespace bindings (prefix -> namespace URI).
 */
type XPathNamespaces = Record<string, string>;
/**
 * Type for available documents mapping (URI -> root node).
 * Used by fn:doc() and related functions (XPath 2.0+).
 */
type XPathDocuments = Record<string, XPathNode | null>;
/**
 * Type for available collections mapping (URI -> sequence of nodes).
 * Used by fn:collection() function (XPath 2.0+).
 */
type XPathCollections = Record<string, XPathNode[]>;
/**
 * Type for function implementations registry.
 * Maps function names (with optional namespace) to their implementations.
 */
type XPathFunctionRegistry = Record<string, XPathFunction>;
/**
 * The evaluation context for XPath expressions.
 *
 * This context is passed to all expression evaluate() methods and contains:
 * - The current context node
 * - Position information for predicates
 * - Variable bindings
 * - Custom function definitions
 * - Dynamic properties like current dateTime, available documents, etc.
 */
interface XPathContext {
    /**
     * The current context node being evaluated.
     */
    node?: XPathNode;
    /**
     * The position of the context node within the current node set (1-based).
     * Used by position() function and numeric predicates.
     */
    position?: number;
    /**
     * The size of the current node set.
     * Used by last() function.
     */
    size?: number;
    /**
     * The full node list for the current context.
     * Used by the 'self-and-siblings' axis (XSLT-specific).
     */
    nodeList?: XPathNode[];
    /**
     * Variable bindings available during evaluation.
     * Variables are referenced in XPath as $variableName.
     */
    variables?: XPathVariables;
    /**
     * Custom functions available during evaluation.
     * These extend the built-in XPath 1.0 function library.
     */
    functions?: XPathFunctions;
    /**
     * Namespace bindings for resolving prefixes in XPath expressions.
     * Maps namespace prefixes to namespace URIs.
     * Example: { "atom": "http://www.w3.org/2005/Atom" }
     */
    namespaces?: XPathNamespaces;
    /**
     * XSLT version ('1.0', '2.0', '3.0') for version-specific behavior.
     * Used by functions like json-to-xml() which are only available in XSLT 3.0+
     */
    xsltVersion?: string;
    /**
     * XPath specification version being used.
     * Default: '1.0'
     *
     * This affects:
     * - Function library available
     * - Type system behavior
     * - Sequence vs node-set handling
     */
    xpathVersion?: '1.0' | '2.0' | '3.0' | '3.1';
    /**
     * Enable XPath 1.0 backward compatibility mode (Phase 8.1).
     * When true, XPath 2.0+ expressions follow XPath 1.0 type conversion rules.
     * This enables:
     * - XPath 1.0 boolean conversion semantics
     * - XPath 1.0 numeric conversion (with NaN for empty sequences)
     * - XPath 1.0 comparison rules (node-set to string conversion)
     * - XPath 1.0 logical operator behavior (short-circuit, error suppression)
     * Default: false (XPath 2.0 semantics)
     */
    xpath10CompatibilityMode?: boolean;
    /**
     * Default collation for string comparisons (XPath 2.0+).
     * Default: Unicode codepoint collation
     */
    defaultCollation?: string;
    /**
     * Base URI for resolving relative URIs (XPath 2.0+).
     */
    baseUri?: string;
    /**
     * Implicit timezone as duration offset from UTC (XPath 2.0+).
     * Example: '-PT5H' for US Eastern Time (UTC-5)
     */
    implicitTimezone?: string;
    /**
     * Extension data for XSLT or custom implementations.
     * This allows attaching arbitrary data to the context without
     * polluting the main interface.
     */
    extensions?: Record<string, any>;
    /**
     * Current dateTime in the dynamic context (XPath 2.0+).
     * Returned by fn:current-dateTime().
     * If not provided, defaults to system time when accessed.
     */
    currentDateTime?: Date;
    /**
     * Available documents mapping for fn:doc() function (XPath 2.0+).
     * Maps document URIs to their root document nodes.
     * Example: { "http://example.com/data.xml": rootNode }
     */
    availableDocuments?: XPathDocuments;
    /**
     * Available collections mapping for fn:collection() function (XPath 2.0+).
     * Maps collection URIs to sequences of nodes.
     * Example: { "http://example.com/collection": [node1, node2, ...] }
     */
    availableCollections?: XPathCollections;
    /**
     * Default collection URI when fn:collection() is called without arguments (XPath 2.0+).
     * If provided, fn:collection() returns availableCollections[defaultCollection].
     */
    defaultCollection?: string;
    /**
     * Function implementations registry (XPath 2.0+).
     * Maps QName function names to their implementations.
     * Allows defining custom/XSLT functions at evaluation time.
     * Format: "localName" or "prefix:localName"
     */
    functionRegistry?: XPathFunctionRegistry;
}
/**
 * Represents an XPath 3.0 function item.
 * This is a simplified interface to avoid circular dependencies.
 */
interface XPathFunctionItem {
    __isFunctionItem: true;
    implementation: (...args: any[]) => any;
    arity: number;
    name?: string;
    namespace?: string;
}
/**
 * Result types that can be returned from XPath evaluation.
 *
 * XPath 1.0: node-set, string, number, boolean
 * XPath 2.0+: sequences (which subsume node-sets), atomic values, functions
 */
type XPathResult = XPathNode[] | string | number | boolean | any[] | Map<any, any> | null | XPathFunctionItem;

declare abstract class XPathExpression {
    abstract evaluate(context: XPathContext): XPathResult;
}

/**
 * Handles conversion between ExprContext and XPathContext.
 * Uses XNode directly as XPathNode-compatible objects to preserve node identity.
 */
declare class NodeConverter {
    /**
     * Convert ExprContext to XPathContext for the new XPath implementation.
     * XNodes are used directly since they implement enough of the XPathNode interface.
     */
    exprContextToXPathContext(exprContext: ExprContext): XPathContext;
    /**
     * Adapt XNode to be compatible with XPathNode interface.
     * We add missing properties but keep the original XNode reference.
     */
    adaptXNode(node: XNode): XPathNode;
    /**
     * Convert XPathNode result back to XNode.
     * Since we're now using XNodes directly, this is mostly a type cast.
     */
    xPathNodeToXNode(xpathNode: XPathNode): XNode | null;
    /**
     * Get text content from an XNode.
     */
    private getTextContent;
    /**
     * Convert variables from ExprContext format to XPathContext format.
     */
    private convertVariables;
    /**
     * Create custom functions for XPath context (like key(), document(), etc.).
     * Note: Custom functions receive the XPathContext as their first argument,
     * followed by the evaluated function arguments.
     */
    private createCustomFunctions;
    /**
     * Convert an XPathNode interface tree to actual XNode objects.
     * This is needed to convert json-to-xml() output to XSLT-compatible nodes.
     */
    private convertXPathNodeToXNode;
    /**
     * Convert an XML node to a JSON string representation.
     * This is a simplified implementation of XSLT 3.0's xml-to-json().
     */
    private xmlToJson;
    /**
     * Wrap XPath result in appropriate NodeValue type.
     */
    wrapResult(result: XPathResult, exprContext: ExprContext): NodeValue;
    /**
     * Clear any internal state if needed.
     */
    clearCache(): void;
}

/**
 * Expression wrapper that provides backward-compatible interface.
 * Wraps new XPath expressions to work with old ExprContext.
 */
declare class Expression {
    protected xpathExpression: XPathExpression;
    protected nodeConverter: NodeConverter;
    absolute?: boolean;
    steps?: any[];
    constructor(xpathExpression: XPathExpression, nodeConverter: NodeConverter);
    /**
     * Evaluate the expression in the given context.
     */
    evaluate(context: ExprContext): NodeValue;
}

/**
 * XPath class that uses the new lexer/parser implementation
 * while maintaining API compatibility with the old implementation.
 */
declare class XPath {
    private lexers;
    private parsers;
    private nodeConverter;
    private parseCache;
    constructor();
    private getLexer;
    private getParser;
    /**
     * Parse an XPath expression and return an Expression object.
     * @param expression The XPath expression string.
     * @param axis Optional axis override for relative paths.
     * @param version Optional XPath version (defaults to 1.0).
     */
    xPathParse(expression: string, axis?: string, version?: XPathVersion): Expression;
    /**
     * Parse and evaluate an XPath expression.
     * @param select The XPath expression string.
     * @param context The expression context.
     */
    xPathEval(select: string, context: ExprContext): NodeValue;
    /**
     * Sort nodes in context according to sort specifications.
     * @param context The expression context with nodes to sort.
     * @param sort Array of sort specifications.
     */
    xPathSort(context: ExprContext, sort: any[]): void;
    /**
     * Comparison function for sorting.
     */
    private xPathSortByKey;
    /**
     * Wrap a new XPath expression in the backward-compatible Expression class.
     */
    private wrapExpression;
    /**
     * Clear parse cache (useful for testing or memory management).
     */
    clearCache(): void;
}

/**
 * Class that resolves XPath expressions, returning nodes.
 * This is used for XSLT pattern matching.
 */
declare class MatchResolver {
    /**
     * Entry point for expression matching.
     * @param expression The expression to be resolved.
     * @param context The Expression Context.
     * @returns An array of nodes.
     */
    expressionMatch(expression: Expression, context: ExprContext): XNode[];
    /**
     * Resolves a LocationExpr.
     * @param expression The Location Expression.
     * @param context The Expression Context.
     * @returns Either the results of a relative resolution, or the results of an
     *          absolute resolution.
     */
    private locationExpressionMatch;
    /**
     * Resolves a UnionExpr.
     * @param expression The Union Expression.
     * @param context The Expression Context.
     * @returns The concatenated result of evaluating both sides of the expression.
     */
    private unionExpressionMatch;
    /**
     * Finds all the nodes through absolute XPath search, starting on
     * the #document parent node.
     * @param expression The Expression.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    private absoluteXsltMatchByDocumentNode;
    /**
     * Finds all the nodes through absolute XPath search, starting with the
     * first child of the #document node.
     * @param expression The Expression.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    private absoluteXsltMatch;
    /**
     * Tries to find relative nodes from the actual context position.
     * If found nodes are already in the context, or if they are children of
     * nodes in the context, they are returned.
     * @param expression The expression used.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    private relativeXsltMatch;
}

/**
 * The main class for XSL-T processing.
 *
 * References:
 *
 * [XSLT 1.0] XSL Transformations (XSLT) Version 1.0
 * <https://www.w3.org/TR/1999/REC-xslt-19991116>.
 *
 * [XSLT 2.0] XSL Transformations (XSLT) Version 2.0
 * <https://www.w3.org/TR/xslt20/>.
 *
 * [XSLT 3.0] XSL Transformations (XSLT) Version 3.0
 * <https://www.w3.org/TR/xslt-30/>.
 *
 * [ECMA] ECMAScript Language Specification
 * <http://www.ecma-international.org/publications/standards/Ecma-262.htm>.
 *
 * The XSL processor API has one entry point: the async function
 * `xsltProcess()`. It receives as arguments the input XML document
 * and the XSL-T stylesheet document (both as `XDocument` instances),
 * and returns the transformed output as a string (XML, HTML, JSON,
 * or plain text depending on the output method).
 *
 * NOTE: Strictly speaking, XSL-T processing according to the specification
 * is defined as operation on text documents, not as operation on DOM
 * trees. This implementation operates on an internal DOM representation,
 * complemented by an XML parser and serializer to be complete. Those two
 * are found in the `dom` folder.
 */
declare class Xslt {
    xPath: XPath;
    xmlParser: XmlParser;
    matchResolver: MatchResolver;
    options: XsltOptions;
    decimalFormatSettings: XsltDecimalFormatSettings;
    warningsCallback: (...args: any[]) => void;
    outputDocument: XDocument;
    outputMethod: 'xml' | 'html' | 'text' | 'name' | 'xhtml' | 'json' | 'adaptive';
    outputOmitXmlDeclaration: string;
    outputVersion: string;
    itemSeparator: string;
    version: string;
    firstTemplateRan: boolean;
    /**
     * Forwards-compatible processing mode (XSLT 1.0 Section 2.5).
     * When true, the processor is running a stylesheet with version > 1.0.
     * In this mode:
     * - Unknown top-level elements are silently ignored
     * - Unknown XSLT instructions use xsl:fallback if available, otherwise are ignored
     * - Unknown attributes on XSLT elements are ignored
     */
    forwardsCompatible: boolean;
    /**
     * List of element name patterns from xsl:strip-space declarations.
     * Whitespace-only text nodes inside matching elements will be stripped.
     */
    stripSpacePatterns: string[];
    /**
     * List of element name patterns from xsl:preserve-space declarations.
     * Whitespace-only text nodes inside matching elements will be preserved.
     * preserve-space takes precedence over strip-space for conflicting patterns.
     */
    preserveSpacePatterns: string[];
    /**
     * Namespace aliases from xsl:namespace-alias declarations.
     * Maps stylesheet namespace prefixes to result namespace prefixes.
     */
    namespaceAliases: Map<string, string>;
    /**
     * Set of supported extension element namespaces.
     * Processors can register custom extension namespaces here.
     * Currently only XSLT namespace is auto-registered.
     */
    supportedExtensions: Set<string>;
    /**
     * Map of attribute sets defined in the stylesheet.
     * Keys are attribute set names, values are arrays of xsl:attribute nodes.
     */
    attributeSets: Map<string, XNode[]>;
    /**
     * Map of user-defined functions from xsl:function declarations.
     * Keys are QNames (namespace:localname), values are the function definition nodes.
     */
    userDefinedFunctions: Map<string, XNode>;
    /**
     * Result documents created by xsl:result-document.
     * Keys are the href URIs, values are the serialized output strings.
     */
    resultDocuments: Map<string, string>;
    /**
     * Stack of stylesheet metadata for tracking import hierarchy.
     * Used by apply-imports to find templates from imported stylesheets.
     */
    private styleSheetStack;
    /**
     * Map of imported stylesheet HREFs to their parsed XNodes.
     * Prevents duplicate imports and allows precedence tracking.
     */
    private importedStylesheets;
    /**
     * Map templates to the stylesheet they came from.
     * Enables apply-imports to find templates by import precedence.
     */
    private templateSourceMap;
    /**
     * Stack of currently executing templates with their metadata.
     * Used by apply-imports to determine which template called it.
     */
    private currentTemplateStack;
    /**
     * Package registry for XSLT 3.0 package system.
     * Manages loaded packages and their components.
     */
    private packageRegistry;
    /**
     * Callback for loading external packages.
     * Called when a package is not found in the registry.
     */
    private packageLoader?;
    /**
     * Current package being processed (for XSLT 3.0).
     * null if processing a non-package stylesheet.
     */
    private currentPackage;
    /**
     * Current override context (for XSLT 3.0 xsl:original).
     * Tracks the original component when executing an override.
     */
    private currentOverrideContext;
    /**
     * Accumulator registry for XSLT 3.0 accumulators.
     * Stores accumulator definitions and current state during processing.
     */
    private accumulatorRegistry;
    /**
     * Streaming processor for XSLT 3.0 streaming processing.
     * Encapsulates streaming context, copy management, and merge coordination.
     */
    private streamingProcessor;
    constructor(options?: Partial<XsltOptions>);
    /**
     * The exported entry point of the XSL-T processor.
     * @param xmlDoc The input document root, as DOM node.
     * @param stylesheet The stylesheet document root, as DOM node.
     * @returns the processed document, as XML text in a string, JSON string if outputMethod is 'json', or text if outputMethod is 'text' or 'adaptive' (with text content).
     */
    xsltProcess(xmlDoc: XDocument, stylesheet: XDocument): Promise<string>;
    /**
     * The main entry point of the XSL-T processor, as explained on the top of the file.
     * @param context The input document root, as XPath `ExprContext`.
     * @param template The stylesheet document root, as DOM node.
     * @param output If set, the output where the transformation should occur.
     */
    protected xsltProcessContext(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Handle unknown XSLT instructions per XSLT 1.0 Section 2.5 (Forwards-Compatible Processing).
     *
     * In forwards-compatible mode (version > 1.0):
     * - If the instruction has an xsl:fallback child, execute the fallback
     * - Otherwise, the instruction is silently ignored
     *
     * In strict mode (version = 1.0):
     * - Unknown instructions are an error
     *
     * @param context The Expression Context
     * @param template The unknown XSLT instruction element
     * @param output The output node
     */
    protected xsltUnknownInstruction(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:apply-templates`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     * @protected
     */
    protected xsltApplyTemplates(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Helper method to apply the built-in template for elements.
     * The built-in template recursively applies templates to children.
     */
    private applyBuiltInTemplate;
    /**
     * Implements `xsl:apply-imports`.
     * Applies templates from imported stylesheets with the same match pattern and mode.
     * This enables template overriding where a template in an importing stylesheet
     * can call the overridden template from the imported stylesheet.
     * @param context The Expression Context.
     * @param template The apply-imports template node.
     * @param output The output node.
     */
    protected xsltApplyImports(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:attribute`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     * @protected
     */
    protected xsltAttribute(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:call-template`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output, used when a fragment is passed by a previous step.
     */
    protected xsltCallTemplate(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:choose`, its child nodes `xsl:when`, and
     * `xsl:otherwise`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     */
    protected xsltChoose(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:copy` for all node types.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     * @returns {XNode|null} If an element node was created, the element node. Otherwise, null.
     */
    protected xsltCopy(destination: XNode, source: XNode): XNode;
    /**
     * Implements `xsl:comment`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     */
    protected xsltComment(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:processing-instruction`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     */
    protected xsltProcessingInstruction(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:copy-of` for node-set values of the select
     * expression. Recurses down the source node tree, which is part of
     * the input document.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     */
    protected xsltCopyOf(destination: XNode, source: XNode): void;
    /**
     * Implements `xsl:decimal-format`, registering the settings in this instance
     * and the current context.
     * @param context The Expression Context.
     * @param template The template.
     */
    protected xsltDecimalFormat(context: ExprContext, template: XNode): void;
    /**
     * Implements `xsl:element`.
     * @param context The Expression Context.
     * @param template The template.
     */
    protected xsltElement(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:accumulator` (XSLT 3.0).
     *
     * Accumulators are a declarative way to compute values during template processing.
     * They consist of rules that are applied as elements are processed.
     *
     * @param context The expression context
     * @param template The xsl:accumulator element
     */
    protected xsltAccumulator(context: ExprContext, template: XNode): void;
    /**
     * Evaluates all matching accumulator rules for a given node
     * and updates the accumulator state
     *
     * @param context The expression context with current node
     * @param node The current node being processed
     */
    protected evaluateAccumulatorRules(context: ExprContext, node: XNode): void;
    /**
     * Retrieves the current value of an accumulator
     * Used when accessing accumulators in templates via accumulator-after() or accumulator-before()
     *
     * @param accumulatorName The name of the accumulator
     * @returns The current value of the accumulator, or null if not found
     */
    protected getAccumulatorValue(accumulatorName: string): any;
    /**
     * Implements `xsl:for-each`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltForEach(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:for-each-group` (XSLT 2.0).
     *
     * Groups items from the select expression and processes each group.
     * Supports group-by and group-adjacent grouping methods.
     *
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltForEachGroup(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Group items by a computed key value.
     * Items with the same key are placed in the same group.
     */
    private groupByKey;
    /**
     * Group adjacent items with the same key.
     * A new group starts when the key changes.
     */
    private groupAdjacent;
    /**
     * Convert an XSLT pattern to a self:: expression for matching against the current node.
     * For example, "h1" becomes "self::h1", "section[@type]" becomes "self::section[@type]".
     */
    private patternToSelfExpression;
    /**
     * Group items starting with items that match a pattern.
     * A new group starts when an item matches the pattern.
     */
    private groupStartingWith;
    /**
     * Group items ending with items that match a pattern.
     * A group ends when an item matches the pattern.
     */
    private groupEndingWith;
    /**
     * Implements `xsl:iterate` (XSLT 3.0).
     *
     * Iterates over a sequence, maintaining accumulators that are updated across iterations.
     * Each iteration can output content and update accumulator values.
     * After all iterations complete, optional xsl:on-completion is executed.
     *
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltIterate(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:try`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltTry(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:evaluate` (XSLT 3.0).
     * Dynamically evaluates an XPath expression constructed as a string.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltEvaluate(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:if`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltIf(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Common implementation for `<xsl:import>` and `<xsl:include>`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     * @param isImport Whether this is an import (true) or include (false).
     */
    protected xsltImportOrInclude(context: ExprContext, template: XNode, output: XNode | undefined, isImport: boolean): Promise<void>;
    /**
     * Implements `<xsl:import>`. For now the code is nearly identical to `<xsl:include>`, but there's
     * no precedence evaluation implemented yet.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltImport(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:include`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    protected xsltInclude(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `<xsl:package>` (XSLT 3.0 Section 3.6).
     * Defines a package of XSLT components with controlled visibility.
     * @param context The Expression Context.
     * @param template The xsl:package element.
     * @param output The output node.
     */
    protected xsltPackage(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Loads and registers an external package.
     * Creates a temporary context and processes the package document.
     *
     * @param name The package name/URI.
     * @param packageDoc The parsed package document.
     * @param version Optional semantic version string.
     */
    protected loadAndRegisterPackage(name: string, packageDoc: XNode, version?: string): Promise<void>;
    /**
     * Implements `<xsl:use-package>` (XSLT 3.0 Section 3.7).
     * Imports another package and makes its public components available.
     * @param context The Expression Context.
     * @param template The xsl:use-package element.
     * @param output The output node.
     */
    protected xsltUsePackage(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `<xsl:expose>` (XSLT 3.0 Section 3.8).
     * Marks a component as visible outside the package.
     * @param context The Expression Context.
     * @param template The xsl:expose element.
     */
    protected xsltExpose(context: ExprContext, template: XNode): void;
    /**
     * Find a component definition in the package root.
     * @param packageRoot The package root element
     * @param type The component type to find
     * @param name The component name (null for all matching type)
     * @returns Component information or null if not found
     */
    private findComponentInPackageRoot;
    /**
     * Implements `<xsl:accept>` (XSLT 3.0 Section 3.9).
     * Accepts and optionally overrides a component from a used package.
     * @param context The Expression Context.
     * @param template The xsl:accept element.
     */
    protected xsltAccept(context: ExprContext, template: XNode): void;
    /**
     * Implements <xsl:override> (XSLT 3.0 Section 3.7.2).
     * Overrides components from a used package.
     */
    protected xsltOverride(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Find components in a package matching the given criteria.
     * Used by xsl:accept to locate components from used packages.
     *
     * @param pkg The package to search in
     * @param componentType The type of component to find
     * @param namePatterns Array of name patterns ('*' for all, or specific names)
     * @returns Array of matching components
     */
    private findComponentsInPackage;
    /**
     * Get the name to use when matching components.
     * For named components (functions, variables, attribute-sets), returns the name.
     * For templates, returns the name if present, otherwise returns null (match-based templates).
     *
     * @param component The component to get the name from
     * @returns The component name for matching, or null if unnamed
     */
    private getComponentNameForMatching;
    /**
     * Implements <xsl:original> (XSLT 3.0 Section 3.7.2).
     * Calls the original component from within an override.
     */
    protected xsltOriginal(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `<xsl:mode>` (XSLT 3.0 Section 3.5).
     * Declares a mode with visibility and other properties.
     * Only valid within an xsl:package.
     */
    protected xsltMode(context: ExprContext, template: XNode): void;
    /**
     * Get the effective component, checking for overrides first.
     * If the component has been overridden in the current package, returns the override.
     * Otherwise, returns the original component.
     * @param component The original component
     * @returns The effective component (override or original)
     */
    private getEffectiveComponent;
    /**
     * Collect templates from accepted components in used packages.
     * @param mode The mode to match (null for default mode)
     * @returns Array of template priority interfaces
     */
    private collectAcceptedTemplates;
    /**
     * Implements `<xsl:stream>` (XSLT 3.0 Section 16).
     * Enables streaming processing of large documents.
     * @param context The Expression Context.
     * @param template The xsl:stream element.
     * @param output The output node.
     */
    protected xsltStream(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `<xsl:fork>` (XSLT 3.0 Section 17).
     * Creates multiple independent output branches from the input stream.
     * @param context The Expression Context.
     * @param template The xsl:fork element.
     * @param output The output node.
     */
    protected xsltFork(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `<xsl:merge>` (XSLT 3.0 Section 15).
     * Merges multiple sorted input sequences.
     * @param context The Expression Context.
     * @param template The xsl:merge element.
     * @param output The output node.
     */
    protected xsltMerge(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:key`.
     * @param context The Expression Context.
     * @param template The template.
     */
    protected xsltKey(context: ExprContext, template: XNode): void;
    /**
     * Implements `xsl:message`.
     * Outputs a message to the console. If terminate="yes", throws an error to stop processing.
     * @param context The Expression Context.
     * @param template The `<xsl:message>` node.
     */
    protected xsltMessage(context: ExprContext, template: XNode): Promise<void>;
    /**
     * Implements `xsl:namespace-alias`.
     * Declares that a namespace URI in the stylesheet should be replaced by a different
     * namespace URI in the output.
     * @param template The `<xsl:namespace-alias>` node.
     */
    protected xsltNamespaceAlias(template: XNode): void;
    /**
     * Implements `xsl:number`.
     * Inserts a formatted number into the result tree.
     * @param context The Expression Context.
     * @param template The `<xsl:number>` node.
     * @param output The output node.
     */
    protected xsltNumber(context: ExprContext, template: XNode, output?: XNode): void;
    /**
     * Counts nodes for xsl:number based on level, count, and from attributes.
     * @param context The Expression Context.
     * @param level The counting level: 'single', 'multiple', or 'any'.
     * @param count Pattern to match nodes to count.
     * @param from Pattern to define counting boundary.
     * @returns Array of count values (single element for 'single'/'any', multiple for 'multiple').
     */
    protected xsltNumberCount(context: ExprContext, level: string, count: string | null, from: string | null): number[];
    /**
     * Checks if a node matches a pattern (supports simple names and union patterns).
     * @param node The node to check.
     * @param pattern The pattern (node name, wildcard, or union like "a|b|c").
     * @returns True if the node matches.
     */
    protected nodeMatchesPattern(node: XNode, pattern: string): boolean;
    /**
     * Checks if a node matches a single (non-union) pattern.
     * @param node The node to check.
     * @param pattern The pattern (node name or wildcard).
     * @returns True if the node matches.
     */
    protected nodeMatchesSinglePattern(node: XNode, pattern: string): boolean;
    /**
     * Gets all nodes preceding the given node in document order.
     * @param node The reference node.
     * @param fromPattern Optional pattern to define counting boundary.
     * @returns Array of preceding nodes.
     */
    protected getAllPrecedingNodes(node: XNode, fromPattern?: string | null): XNode[];
    /**
     * Collects all descendant nodes of a given node.
     * @param node The parent node.
     * @param result The array to collect into.
     */
    protected collectDescendants(node: XNode, result: XNode[]): void;
    /**
     * Formats an array of numbers according to the format string.
     * For level="multiple", numbers like [1, 2, 3] with format "1.1.1" produce "1.2.3".
     * @param numbers The numbers to format.
     * @param format The format string (e.g., "1", "1.1", "1.a.i").
     * @param groupingSeparator Optional grouping separator.
     * @param groupingSize Optional grouping size.
     * @returns The formatted number string.
     */
    protected xsltFormatNumbers(numbers: number[], format: string, groupingSeparator: string | null, groupingSize: string | null): string;
    /**
     * Parses a format string into tokens and separators.
     * E.g., "1.a.i" -> tokens: ["1", "a", "i"], separators: [".", "."]
     * @param format The format string.
     * @returns Object with tokens and separators arrays.
     */
    protected parseFormatString(format: string): {
        tokens: string[];
        separators: string[];
    };
    /**
     * Formats a number according to the format string.
     * @param number The number to format.
     * @param format The format string (e.g., "1", "01", "a", "A", "i", "I").
     * @param groupingSeparator Optional grouping separator.
     * @param groupingSize Optional grouping size.
     * @returns The formatted number string.
     */
    protected xsltFormatNumber(number: number, format: string, groupingSeparator: string | null, groupingSize: string | null): string;
    /**
     * Converts a number to alphabetic representation.
     * @param number The number to convert.
     * @param uppercase Whether to use uppercase letters.
     * @returns The alphabetic representation.
     */
    protected numberToAlpha(number: number, uppercase: boolean): string;
    /**
     * Converts a number to Roman numeral representation.
     * @param number The number to convert.
     * @returns The Roman numeral string.
     */
    protected numberToRoman(number: number): string;
    /**
     * Applies grouping separators to a numeric string.
     * @param numStr The numeric string.
     * @param separator The grouping separator.
     * @param size The grouping size.
     * @returns The grouped string.
     */
    protected applyGrouping(numStr: string, separator: string, size: number): string;
    /**
     * Orders the current node list in the input context according to the
     * sort order specified by xsl:sort child nodes of the current
     * template node. This happens before the operation specified by the
     * current template node is executed.
     * @param context The expression context.
     * @param template The template node.
     * @todo case-order is not implemented.
     */
    protected xsltSort(context: ExprContext, template: XNode): void;
    /**
     * Implements `xsl:strip-space`.
     * Collects element name patterns for which whitespace-only text nodes should be stripped.
     * @param template The `<xsl:strip-space>` node.
     */
    protected xsltStripSpace(template: XNode): void;
    /**
     * Implements `xsl:preserve-space`.
     * Collects element name patterns for which whitespace-only text nodes should be preserved.
     * preserve-space takes precedence over strip-space for matching elements.
     * @param template The `<xsl:preserve-space>` node.
     */
    protected xsltPreserveSpace(template: XNode): void;
    /**
     * Determines if a text node from the input document should be stripped.
     * This applies xsl:strip-space and xsl:preserve-space rules to whitespace-only text nodes.
     * @param textNode The text node to check.
     * @returns True if the text node should be stripped (not included in output).
     */
    protected shouldStripWhitespaceNode(textNode: XNode): boolean;
    /**
     * Matches an element name against a strip-space/preserve-space pattern.
     * Supports:
     * - "*" matches any element
     * - "prefix:*" matches any element in a namespace
     * - "name" matches elements with that local name
     * - "prefix:name" matches elements with that QName
     * @param elementName The local name of the element.
     * @param pattern The pattern to match against.
     * @param element The element node (for namespace checking).
     * @returns True if the element matches the pattern.
     */
    protected matchesNamePattern(elementName: string, pattern: string, element: XNode): boolean;
    /**
     * Implements `xsl:template`.
     * @param context The Expression Context.
     * @param template The `<xsl:template>` node.
     * @param output The output. In general, a fragment that will be used by
     *               the caller.
     */
    protected xsltTemplate(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    protected xsltText(context: ExprContext, template: XNode, output?: XNode): void;
    /**
     * Validates XSLT stylesheet/transform attributes.
     * According to XSLT specification, validates:
     * - Required version attribute
     * - Valid version values (1.0, 2.0, 3.0)
     * - Valid namespace declarations
     * - Valid values for optional attributes (extension-element-prefixes, exclude-result-prefixes)
     * @param stylesheetElement The `<xsl:stylesheet>` or `<xsl:transform>` element to validate.
     * @param context The Expression Context for namespace access.
     */
    protected validateStylesheetAttributes(stylesheetElement: XNode, context: ExprContext): void;
    /**
     * Implements `<xsl:stylesheet>` and `<xsl:transform>`, and its corresponding
     * validations.
     * @param context The Expression Context.
     * @param template The `<xsl:stylesheet>` or `<xsl:transform>` node.
     * @param output The output. In general, a fragment that will be used by
     *               the caller.
     */
    protected xsltTransformOrStylesheet(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    protected xsltValueOf(context: ExprContext, template: XNode, output?: XNode): void;
    /**
     * Implements `xsl:sequence` (XSLT 2.0).
     *
     * Constructs a sequence by evaluating the select expression or processing
     * child content. Unlike xsl:copy-of, xsl:sequence returns nodes by reference
     * and can return atomic values.
     *
     * @param context The expression context.
     * @param template The xsl:sequence element.
     * @param output The output node.
     */
    protected xsltSequence(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:analyze-string` (XSLT 2.0).
     *
     * Processes a string using a regular expression, with separate handling
     * for matching and non-matching substrings.
     *
     * @param context The expression context.
     * @param template The xsl:analyze-string element.
     * @param output The output node.
     */
    protected xsltAnalyzeString(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Helper method to process xsl:matching-substring or xsl:non-matching-substring content.
     * Sets up the context with the current text and regex groups.
     */
    private processAnalyzeStringContent;
    /**
     * Implements `xsl:function` (XSLT 2.0).
     *
     * Declares a stylesheet function that can be called from XPath expressions.
     * Functions are collected during stylesheet initialization and made available
     * to the XPath evaluator.
     *
     * @param context The expression context.
     * @param template The xsl:function element.
     */
    protected xsltFunction(context: ExprContext, template: XNode): void;
    /**
     * Coerce a NodeValue to a specific type based on the 'as' attribute.
     *
     * @param value The value to coerce.
     * @param type The target type (e.g., "xs:integer", "xs:string", "xs:boolean").
     * @returns The coerced value.
     */
    protected coerceToType(value: NodeValue, type: string): NodeValue;
    /**
     * Execute a user-defined xsl:function.
     * Called when a function from userDefinedFunctions is invoked from XPath.
     *
     * @param context The expression context.
     * @param functionDef The xsl:function node.
     * @param args The evaluated arguments passed to the function.
     * @returns The result of the function execution.
     */
    protected executeUserDefinedFunction(context: ExprContext, functionDef: XNode, args: any[]): Promise<any>;
    /**
     * Synchronously execute a user-defined xsl:function.
     * This is used when functions are called from XPath expressions.
     * Limited to functions that don't require async operations in their body.
     *
     * @param context The expression context.
     * @param functionDef The xsl:function node.
     * @param args The evaluated arguments passed to the function.
     * @returns The result of the function execution.
     */
    executeUserDefinedFunctionSync(context: ExprContext, functionDef: XNode, args: any[]): any;
    /**
     * Implements `xsl:result-document` (XSLT 2.0).
     *
     * Creates a secondary output document. The output is stored in the
     * resultDocuments map, accessible via getResultDocuments().
     *
     * @param context The expression context.
     * @param template The xsl:result-document element.
     */
    protected xsltResultDocument(context: ExprContext, template: XNode): Promise<void>;
    /**
     * Get all result documents created by xsl:result-document.
     * @returns A map of href URIs to serialized output strings.
     */
    getResultDocuments(): Map<string, string>;
    /**
     * Sets the package loader callback.
     * The callback is called when a package is referenced via xsl:use-package
     * but is not found in the registry.
     *
     * @param loader A function that loads package documents by URI and optional version.
     *               Returns the parsed package document, or null if not found.
     */
    setPackageLoader(loader: (uri: string, version?: string) => Promise<XNode | null>): void;
    /**
     * Pre-registers a package for use in transformations.
     * The package is parsed and stored in the internal registry.
     *
     * @param name The package name/URI.
     * @param packageDoc The parsed package document.
     * @param version Optional semantic version string.
     */
    registerPackage(name: string, packageDoc: XNode, version?: string): Promise<void>;
    /**
     * Implements `xsl:perform-sort` (XSLT 2.0).
     *
     * Sorts a sequence of items without iteration. The sorted sequence
     * is available via xsl:sequence or other sequence-consuming instructions.
     *
     * @param context The expression context.
     * @param template The xsl:perform-sort element.
     * @param output The output node.
     */
    protected xsltPerformSort(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Implements `xsl:namespace` (XSLT 2.0).
     *
     * Creates a namespace node in the result tree.
     *
     * @param context The expression context.
     * @param template The xsl:namespace element.
     * @param output The output node.
     */
    protected xsltNamespace(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Evaluates a variable or parameter and set it in the current input
     * context. Implements `xsl:variable`, `xsl:param`, and `xsl:with-param`.
     *
     * @param context The expression context.
     * @param template The template node.
     * @param override flag that defines if the value computed here
     * overrides the one already in the input context if that is the
     * case. I.e. decides if this is a default value or a local
     * value. `xsl:variable` and `xsl:with-param` override; `xsl:param` doesn't.
     */
    protected xsltVariable(context: ExprContext, template: XNode, override: boolean): Promise<void>;
    /**
     * Register accepted variables from used packages into the context.
     * Called after processing package use-package declarations.
     * @param context The expression context.
     */
    private registerAcceptedVariables;
    /**
     * Traverses the template node tree. Calls the main processing
     * function with the current input context for every child node of the
     * current template node.
     * @param context Normally the Expression Context.
     * @param template The XSL-T definition.
     * @param output If set, the output where the transformation should occur.
     */
    protected xsltChildNodes(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    /**
     * Processes child nodes while skipping xsl:on-empty and xsl:on-non-empty.
     * Used by instructions that handle these conditionals explicitly.
     */
    protected xsltChildNodesExcludingConditional(context: ExprContext, template: XNode, output?: XNode): Promise<void>;
    private findConditionalChild;
    /**
     * This logic is used in two different places:
     * - `xsltPassThrough`, if the template asks this library to write a text node;
     * - `xsltProcessContext`, `apply-templates` operation, when the current node is text.
     *
     * Text nodes always require a parent, and they never have children.
     * @param context The Expression Context.
     * @param template The template, that contains the node value to be written.
     * @param output The output.
     */
    private commonLogicTextNode;
    /**
     * Passes template text to the output. The current template node does
     * not specify an XSL-T operation and therefore is appended to the
     * output with all its attributes. Then continues traversing the
     * template node tree.
     * @param context The Expression Context.
     * @param template The XSLT stylesheet or transformation.
     * @param output The output.
     */
    protected xsltPassThrough(context: ExprContext, template: XNode, output: XNode): Promise<void>;
    /**
     * Determines if a text node in the XSLT template document is to be
     * stripped according to XSLT whitespace stripping rules.
     * @see [XSLT], section 3.4.
     * @param template The XSLT template.
     * @returns TODO
     * @todo Whitespace stripping on the input document is
     * currently not implemented.
     */
    protected xsltPassText(template: XNode): boolean;
    protected findAttributeInContext(attributeName: string, context: ExprContext): XNode;
    /**
     * Evaluates an XSL-T attribute value template. Attribute value
     * templates are attributes on XSL-T elements that contain XPath
     * expressions in braces {}. The XSL-T expressions are evaluated in
     * the current input context.
     * @param value TODO
     * @param context TODO
     * @returns TODO
     */
    protected xsltAttributeValue(value: any, context: ExprContext): any;
    /**
     * Evaluates text value templates in XSLT 3.0. Text value templates
     * allow XPath expressions in braces {} within text nodes.
     * The expressions are evaluated in the current input context.
     * To include a literal brace, use {{ or }}.
     * @param value The text node value to process
     * @param context The expression context
     * @returns The processed text with expressions evaluated
     */
    protected xsltTextValueTemplate(value: string, context: ExprContext): string;
    /**
     * Evaluates an XPath expression in the current input context as a
     * match.
     * @see [XSLT] section 5.2, paragraph 1
     * @param match TODO
     * @param context The Expression Context.
     * @param axis The XPath axis. Used when the match does not start with the parent.
     * @returns {XNode[]} A list of the found nodes.
     */
    protected xsltMatch(match: string, context: ExprContext, axis?: string): XNode[];
    /**
     * Sets parameters defined by xsl:with-param child nodes of the
     * current template node, in the current input context. This happens
     * before the operation specified by the current template node is
     * executed.
     * @param context The Expression Context.
     * @param template The template node.
     */
    protected xsltWithParam(context: ExprContext, template: XNode): Promise<void>;
    /**
     * Recursively map all template nodes in a stylesheet to their metadata.
     * Used to track which stylesheet each template comes from for apply-imports.
     * @param stylesheetElement The stylesheet or transform element (or any parent element).
     * @param metadata The metadata for this stylesheet.
     */
    private mapTemplatesFromStylesheet;
    /**
     * Collect all attribute set definitions from the stylesheet.
     * Called at stylesheet initialization time.
     * @param stylesheetElement The stylesheet or transform element.
     */
    private collectAttributeSets;
    /**
     * Collect all user-defined function definitions from the stylesheet.
     * Called at stylesheet initialization time.
     * @param stylesheetElement The stylesheet or transform element.
     * @param context The expression context.
     */
    private collectUserDefinedFunctions;
    /**
     * Register user-defined functions in the expression context.
     * This makes them available to XPath expressions.
     * @param context The expression context.
     */
    private registerUserDefinedFunctionsInContext;
    /**
     * Check if there are any accepted functions in used packages.
     */
    private hasAcceptedFunctions;
    /**
     * Register accepted functions from used packages.
     * @param functionsMap The map to register functions into.
     */
    private registerAcceptedFunctions;
    /**
     * Apply one or more attribute sets to an element.
     * Parses space-separated attribute set names and applies them.
     * @param context The Expression Context.
     * @param element The element to apply attributes to.
     * @param setNames Space-separated attribute set names.
     */
    protected applyAttributeSets(context: ExprContext, element: XNode, setNames: string): Promise<void>;
    /**
     * Apply a single attribute set to an element.
     * Handles recursive attribute sets with cycle detection.
     * @param context The Expression Context.
     * @param element The element to apply attributes to.
     * @param setName The name of the attribute set to apply.
     * @param processedSets Set of already-processed attribute set names (for cycle detection).
     */
    private applyAttributeSet;
    /**
     * Test if an element is a supported extension.
     * Returns false for unrecognized elements in non-XSLT namespaces.
     * @param node The element to test.
     * @returns True if the element is supported, false if it's an unrecognized extension.
     */
    protected isExtensionElementSupported(node: XNode): boolean;
    /**
     * Get the fallback element from an extension element if it exists.
     * Searches for the first direct xsl:fallback child.
     * @param node The extension element.
     * @returns The fallback element, or null if not found.
     */
    protected getFallbackElement(node: XNode): XNode | null;
    /**
     * Process an extension element with fallback support.
     * If a fallback is defined, executes it; otherwise treats element as literal.
     * @param context The Expression Context.
     * @param element The extension element.
     * @param output The output node.
     */
    protected xsltExtensionElement(context: ExprContext, element: XNode, output?: XNode): Promise<void>;
    /**
     * Test if the given element is an XSLT element, optionally the one with the given name.
     * @param {XNode} element The element.
     * @param {string} opt_wantedName The name for comparison.
     * @returns True, if element is an XSL node. False otherwise.
     */
    protected isXsltElement(element: XNode, opt_wantedName?: string): boolean;
}

export { ExprContext, XPath, XmlParser, Xslt, type XsltOptions, xmlEscapeText };
