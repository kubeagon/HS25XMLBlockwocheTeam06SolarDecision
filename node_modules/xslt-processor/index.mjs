var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/xpath/lib/src/expressions/expression.ts
var XPathExpression;
var init_expression = __esm({
  "src/xpath/lib/src/expressions/expression.ts"() {
    XPathExpression = class {
    };
  }
});

// src/xpath/lib/src/expressions/literal-expression.ts
var XPathStringLiteral, XPathNumberLiteral;
var init_literal_expression = __esm({
  "src/xpath/lib/src/expressions/literal-expression.ts"() {
    init_expression();
    XPathStringLiteral = class extends XPathExpression {
      constructor(value) {
        super();
        this.value = value;
      }
      evaluate(_context) {
        return this.value;
      }
      toString() {
        return `"${this.value}"`;
      }
    };
    XPathNumberLiteral = class extends XPathExpression {
      constructor(value) {
        super();
        this.value = value;
      }
      evaluate(_context) {
        return this.value;
      }
      toString() {
        return this.value.toString();
      }
    };
  }
});

// src/xpath/lib/src/constants.ts
var NodeType, XS_NAMESPACE, XPATH_ERROR_NAMESPACE, DEFAULT_FUNCTION_NAMESPACE, DEFAULT_COLLATION, RESERVED_FUNCTION_NAMES;
var init_constants = __esm({
  "src/xpath/lib/src/constants.ts"() {
    NodeType = {
      ELEMENT_NODE: 1,
      ATTRIBUTE_NODE: 2,
      TEXT_NODE: 3,
      CDATA_SECTION_NODE: 4,
      PROCESSING_INSTRUCTION_NODE: 7,
      COMMENT_NODE: 8,
      DOCUMENT_NODE: 9,
      DOCUMENT_FRAGMENT_NODE: 11,
      NAMESPACE_NODE: 13
    };
    XS_NAMESPACE = "http://www.w3.org/2001/XMLSchema";
    XPATH_ERROR_NAMESPACE = "http://www.w3.org/2005/xqt-errors";
    DEFAULT_FUNCTION_NAMESPACE = "http://www.w3.org/2005/xpath-functions";
    DEFAULT_COLLATION = "http://www.w3.org/2005/xpath-functions/collation/codepoint";
    RESERVED_FUNCTION_NAMES = [
      "last",
      "position",
      "count",
      "id",
      "local-name",
      "namespace-uri",
      "name",
      "string",
      "concat",
      "starts-with",
      "contains",
      "substring-before",
      "substring-after",
      "substring",
      "string-length",
      "normalize-space",
      "translate",
      "boolean",
      "not",
      "true",
      "false",
      "lang",
      "number",
      "sum",
      "floor",
      "ceiling",
      "round"
    ];
  }
});

// src/xpath/lib/src/errors.ts
function grammarViolation(message) {
  return new XPathStaticError("XPST0003", `Grammar violation: ${message}`);
}
function unresolvedNameReference(name, type = "name") {
  return new XPathStaticError("XPST0008", `Unresolved ${type} reference: ${name}`);
}
function unsupportedAxis(axis) {
  return new XPathStaticError("XPST0010", `Unsupported axis: ${axis}`);
}
function functionSignatureMismatch(functionName2, expectedArgs, actualArgs) {
  return new XPathStaticError(
    "XPST0017",
    `Function ${functionName2} expects ${expectedArgs}, got ${actualArgs} arguments`
  );
}
function typeMismatch(expected, actual, context) {
  const msg = context ? `Type mismatch in ${context}: expected ${expected}, got ${actual}` : `Type mismatch: expected ${expected}, got ${actual}`;
  return new XPathTypeError("XPTY0004", msg);
}
function invalidCastArgument(value, targetType) {
  return new XPathDynamicError(
    "FORG0001",
    `Cannot cast ${JSON.stringify(value)} to ${targetType}`
  );
}
var XPathError, XPathStaticError, XPathDynamicError, XPathTypeError;
var init_errors = __esm({
  "src/xpath/lib/src/errors.ts"() {
    init_constants();
    XPathError = class _XPathError extends Error {
      constructor(code, message, isStatic = false, isDynamic = false) {
        super(`${code}: ${message}`);
        Object.setPrototypeOf(this, _XPathError.prototype);
        this.code = code;
        this.isStatic = isStatic;
        this.isDynamic = isDynamic;
        this.name = "XPathError";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      /**
       * Get qualified error QName (e.g., "err:XPST0001")
       */
      getQName() {
        return `err:${this.code}`;
      }
      /**
       * Get error URI for namespace
       */
      getErrorURI() {
        return `${XPATH_ERROR_NAMESPACE}#${this.code}`;
      }
    };
    XPathStaticError = class _XPathStaticError extends XPathError {
      constructor(code, message) {
        super(code, message, true, false);
        Object.setPrototypeOf(this, _XPathStaticError.prototype);
        this.name = "XPathStaticError";
      }
    };
    XPathDynamicError = class _XPathDynamicError extends XPathError {
      constructor(code, message) {
        super(code, message, false, true);
        Object.setPrototypeOf(this, _XPathDynamicError.prototype);
        this.name = "XPathDynamicError";
      }
    };
    XPathTypeError = class _XPathTypeError extends XPathDynamicError {
      constructor(code, message) {
        super(code, message);
        Object.setPrototypeOf(this, _XPathTypeError.prototype);
        this.name = "XPathTypeError";
      }
    };
  }
});

// src/xpath/lib/src/expressions/variable-reference-expression.ts
var XPathVariableReference;
var init_variable_reference_expression = __esm({
  "src/xpath/lib/src/expressions/variable-reference-expression.ts"() {
    init_expression();
    init_errors();
    XPathVariableReference = class extends XPathExpression {
      constructor(name) {
        super();
        this.name = name;
      }
      evaluate(context) {
        if (!context.variables) {
          throw unresolvedNameReference(`$${this.name}`, "variable");
        }
        if (!(this.name in context.variables)) {
          throw unresolvedNameReference(`$${this.name}`, "variable");
        }
        return context.variables[this.name];
      }
      toString() {
        return `$${this.name}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/step-expression.ts
var XPathStep;
var init_step_expression = __esm({
  "src/xpath/lib/src/expressions/step-expression.ts"() {
    init_expression();
    XPathStep = class extends XPathExpression {
      constructor(axis, nodeTest, predicates = []) {
        super();
        this.axis = axis;
        this.nodeTest = nodeTest;
        this.predicates = predicates;
      }
      evaluate(context) {
        const node = context == null ? void 0 : context.node;
        if (!node && this.axis === "self" && (context == null ? void 0 : context.contextItem) !== void 0) {
          const item = context.contextItem;
          if (this.predicates.length === 0) {
            return [item];
          }
          return this.applyPredicatesToAtomicItem(item, context);
        }
        if (!node) return [];
        let candidates = this.getNodesByAxis(node, context);
        candidates = candidates.filter((n) => this.matchesNodeTest(n, context));
        candidates = this.applyPredicates(candidates, context);
        return candidates;
      }
      /**
       * Apply predicates to an atomic item context.
       */
      applyPredicatesToAtomicItem(item, context) {
        const itemContext = __spreadProps(__spreadValues({}, context), { contextItem: item, position: 1, size: 1 });
        for (const predicate of this.predicates) {
          const result = predicate.evaluate(itemContext);
          if (typeof result === "number") {
            if (result !== 1) return [];
          } else if (!this.toBoolean(result)) {
            return [];
          }
        }
        return [item];
      }
      getNodesByAxis(node, context) {
        switch (this.axis) {
          case "child":
            return this.getChildNodes(node);
          case "parent":
            return node.parentNode ? [node.parentNode] : [];
          case "self":
            return [node];
          case "attribute":
            if (node.attributes) {
              return Array.from(node.attributes);
            }
            return Array.from(node.childNodes || []).filter((n) => n.nodeType === 2);
          case "descendant":
            return this.getDescendants(node, false);
          case "descendant-or-self":
            return this.getDescendants(node, true);
          case "ancestor":
            return this.getAncestors(node, false);
          case "ancestor-or-self":
            return this.getAncestors(node, true);
          case "following-sibling":
            return this.getFollowingSiblings(node);
          case "preceding-sibling":
            return this.getPrecedingSiblings(node);
          case "following":
            return this.getFollowing(node);
          case "preceding":
            return this.getPreceding(node);
          case "namespace":
            return this.getNamespaceNodes(node);
          case "self-and-siblings":
            if (context == null ? void 0 : context.nodeList) {
              return context.nodeList.filter((n) => n.nodeType !== 2);
            }
            return [node];
          default:
            return [];
        }
      }
      /**
       * Get child nodes excluding attribute nodes.
       * XNode stores attributes in childNodes, but XPath child axis doesn't include them.
       */
      getChildNodes(node) {
        const children = Array.from(node.childNodes || []);
        return children.filter((n) => n.nodeType !== 2);
      }
      getDescendants(node, includeSelf) {
        const result = [];
        if (includeSelf) result.push(node);
        const walk = (n) => {
          for (const child of this.getChildNodes(n)) {
            result.push(child);
            walk(child);
          }
        };
        walk(node);
        return result;
      }
      getAncestors(node, includeSelf) {
        const result = [];
        if (includeSelf) result.push(node);
        let current = node.parentNode;
        while (current) {
          result.push(current);
          current = current.parentNode;
        }
        return result;
      }
      getFollowingSiblings(node) {
        const result = [];
        let sibling = node.nextSibling;
        while (sibling) {
          result.push(sibling);
          sibling = sibling.nextSibling;
        }
        return result;
      }
      getPrecedingSiblings(node) {
        const result = [];
        let sibling = node.previousSibling;
        while (sibling) {
          result.unshift(sibling);
          sibling = sibling.previousSibling;
        }
        return result;
      }
      getFollowing(node) {
        const result = [];
        let sibling = node.nextSibling;
        while (sibling) {
          result.push(sibling);
          result.push(...this.getDescendants(sibling, false));
          sibling = sibling.nextSibling;
        }
        let ancestor = node.parentNode;
        while (ancestor) {
          sibling = ancestor.nextSibling;
          while (sibling) {
            result.push(sibling);
            result.push(...this.getDescendants(sibling, false));
            sibling = sibling.nextSibling;
          }
          ancestor = ancestor.parentNode;
        }
        return result;
      }
      getPreceding(node) {
        const result = [];
        let sibling = node.previousSibling;
        while (sibling) {
          result.unshift(sibling);
          const descendants = this.getDescendants(sibling, false);
          result.unshift(...descendants);
          sibling = sibling.previousSibling;
        }
        let ancestor = node.parentNode;
        while (ancestor) {
          sibling = ancestor.previousSibling;
          while (sibling) {
            result.unshift(sibling);
            const descendants = this.getDescendants(sibling, false);
            result.unshift(...descendants);
            sibling = sibling.previousSibling;
          }
          ancestor = ancestor.parentNode;
        }
        return result;
      }
      getNamespaceNodes(node) {
        var _a, _b;
        if (!node || node.nodeType !== 1) return [];
        const namespaces = {};
        let current = node;
        while (current) {
          const attrs = Array.from(current.attributes || []);
          for (const attr of attrs) {
            const name = attr.nodeName || attr.localName || "";
            const value = (_b = (_a = attr.nodeValue) != null ? _a : attr.textContent) != null ? _b : "";
            if (name === "xmlns") {
              if (!("" in namespaces)) {
                namespaces[""] = value;
              }
            } else if (name.startsWith("xmlns:")) {
              const prefix = name.substring("xmlns:".length);
              if (!(prefix in namespaces)) {
                namespaces[prefix] = value;
              }
            }
          }
          current = current.parentNode;
        }
        if (!("xml" in namespaces)) {
          namespaces["xml"] = "http://www.w3.org/XML/1998/namespace";
        }
        return Object.entries(namespaces).map(([prefix, uri]) => ({
          nodeType: 13,
          nodeName: prefix,
          localName: prefix,
          prefix,
          namespaceURI: uri,
          namespaceUri: uri,
          nodeValue: uri,
          textContent: uri,
          parentNode: node,
          ownerDocument: node.ownerDocument
        }));
      }
      matchesNodeTest(node, context, test = this.nodeTest) {
        var _a, _b;
        const nodeType = node.nodeType;
        const matchesQName = (testName, allowedNodeTypes) => {
          var _a2, _b2;
          if (!allowedNodeTypes.includes(nodeType)) return false;
          if (testName.endsWith(":*")) {
            const prefix = testName.slice(0, -2);
            const nsUri = (_a2 = context == null ? void 0 : context.namespaces) == null ? void 0 : _a2[prefix];
            if (!nsUri) return false;
            const nodeNsUri = node.namespaceURI || node.namespaceUri || "";
            return nodeNsUri === nsUri;
          }
          const colonIndex = testName.indexOf(":");
          if (colonIndex > 0) {
            const prefix = testName.substring(0, colonIndex);
            const localName = testName.substring(colonIndex + 1);
            const nsUri = (_b2 = context == null ? void 0 : context.namespaces) == null ? void 0 : _b2[prefix];
            if (!nsUri) return false;
            const nodeLocalName2 = node.localName || node.nodeName && this.extractLocalName(node.nodeName);
            const nodeNsUri = node.namespaceURI || node.namespaceUri || "";
            return nodeLocalName2 === localName && nodeNsUri === nsUri;
          }
          const nodeLocalName = node.localName || this.extractLocalName(node.nodeName);
          return nodeLocalName === testName;
        };
        switch (test.type) {
          case "wildcard":
            if (test.name && test.name.endsWith(":*")) {
              const prefix = test.name.slice(0, -2);
              const nsUri = (_a = context == null ? void 0 : context.namespaces) == null ? void 0 : _a[prefix];
              if (!nsUri) return false;
              const nodeNsUri = node.namespaceURI || node.namespaceUri || "";
              return (nodeType === 1 || nodeType === 2 || nodeType === 13) && nodeNsUri === nsUri;
            }
            return nodeType === 1 || nodeType === 2 || nodeType === 13;
          case "name":
            return matchesQName(test.name, [1, 2, 13]);
          case "element":
            if (nodeType !== 1) return false;
            if (!test.name || test.isWildcardName) return true;
            return matchesQName(test.name, [1]);
          case "attribute":
            if (nodeType !== 2) return false;
            if (!test.name || test.isWildcardName) return true;
            return matchesQName(test.name, [2]);
          case "schema-element":
            return matchesQName(test.name, [1]);
          case "schema-attribute":
            return matchesQName(test.name, [2]);
          case "document-node":
            if (nodeType !== 9) return false;
            if (!test.elementTest) return true;
            const root2 = node.documentElement || Array.from(node.childNodes || []).find((n) => n.nodeType === 1);
            if (!root2) return false;
            return this.matchesNodeTest(root2, context, test.elementTest);
          case "node-type":
            switch (test.nodeType) {
              case "node":
                return true;
              // matches any node
              case "text":
                return nodeType === 3;
              // text node
              case "comment":
                return nodeType === 8;
              // comment node
              case "processing-instruction":
                return nodeType === 7;
              // processing instruction
              default:
                return false;
            }
          case "processing-instruction":
            if (nodeType !== 7) return false;
            if (test.target) {
              return ((_b = node.target) != null ? _b : node.nodeName) === test.target;
            }
            return true;
          default:
            return false;
        }
      }
      applyPredicates(nodes, context) {
        let result = nodes;
        for (const predicate of this.predicates) {
          const filtered = [];
          const size = result.length;
          for (let i = 0; i < result.length; i++) {
            const predicateContext = __spreadProps(__spreadValues({}, context), {
              node: result[i],
              position: i + 1,
              size
            });
            const predicateResult = predicate.evaluate(predicateContext);
            if (typeof predicateResult === "number") {
              if (predicateResult === i + 1) {
                filtered.push(result[i]);
              }
            } else if (this.toBoolean(predicateResult)) {
              filtered.push(result[i]);
            }
          }
          result = filtered;
        }
        return result;
      }
      toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
      /**
       * Extract the local name from a qualified name (e.g., "ns:name" -> "name", "name" -> "name")
       */
      extractLocalName(qname) {
        if (!qname) return "";
        const colonIndex = qname.indexOf(":");
        if (colonIndex > 0) {
          return qname.substring(colonIndex + 1);
        }
        return qname;
      }
    };
  }
});

// src/xpath/lib/src/expressions/location-path-expression.ts
var XPathLocationPath;
var init_location_path_expression = __esm({
  "src/xpath/lib/src/expressions/location-path-expression.ts"() {
    init_expression();
    XPathLocationPath = class extends XPathExpression {
      constructor(steps, absolute = false) {
        super();
        this.steps = steps;
        this.absolute = absolute;
      }
      evaluate(context) {
        let nodes;
        if (this.absolute) {
          const root2 = this.getDocumentRoot(context == null ? void 0 : context.node);
          nodes = root2 ? [root2] : [];
        } else {
          if (context == null ? void 0 : context.node) {
            nodes = [context.node];
          } else if ((context == null ? void 0 : context.contextItem) !== void 0) {
            nodes = [{ __atomicContextItem: context.contextItem }];
          } else {
            nodes = [];
          }
        }
        for (const step of this.steps) {
          const nextNodes = [];
          for (const node of nodes) {
            if (node && node.__atomicContextItem !== void 0) {
              const stepContext = __spreadProps(__spreadValues({}, context), { contextItem: node.__atomicContextItem });
              const result = step.evaluate(stepContext);
              nextNodes.push(...result);
            } else {
              const stepContext = __spreadProps(__spreadValues({}, context), { node });
              const result = step.evaluate(stepContext);
              nextNodes.push(...result);
            }
          }
          nodes = this.uniqueNodes(nextNodes);
        }
        return nodes;
      }
      getDocumentRoot(node) {
        if (!node) return null;
        let root2 = node;
        while (root2.parentNode) {
          root2 = root2.parentNode;
        }
        return root2;
      }
      uniqueNodes(nodes) {
        const seen = /* @__PURE__ */ new Set();
        const result = [];
        for (const node of nodes) {
          if (!seen.has(node)) {
            seen.add(node);
            result.push(node);
          }
        }
        return result;
      }
    };
  }
});

// src/xpath/lib/src/expressions/filter-expression.ts
var XPathFilterExpression, FilteredPathExpression;
var init_filter_expression = __esm({
  "src/xpath/lib/src/expressions/filter-expression.ts"() {
    init_expression();
    XPathFilterExpression = class extends XPathExpression {
      constructor(expression, predicates) {
        super();
        this.expression = expression;
        this.predicates = predicates || [];
      }
      /**
       * Evaluate the filter expression.
       *
       * Steps:
       * 1. Evaluate the primary expression to get a sequence
       * 2. For each predicate:
       *    a. Set position/size in context
       *    b. Evaluate predicate for each item
       *    c. Keep items where predicate test succeeds
       * 3. Return the filtered result
       *
       * @param context The evaluation context
       * @returns The filtered sequence
       */
      evaluate(context) {
        let result = this.expression.evaluate(context);
        if (!Array.isArray(result)) {
          result = result === void 0 || result === null ? [] : [result];
        }
        for (const predicateExpr of this.predicates) {
          result = this.applyPredicate(result, predicateExpr, context);
        }
        return result;
      }
      /**
       * Apply a single predicate to filter the result sequence.
       *
       * For each item in the sequence:
       * - Set position and size in context
       * - Evaluate the predicate
       * - Test if the predicate matches
       * - Keep the item if it matches
       *
       * @param items The sequence to filter
       * @param predicateExpr The predicate expression
       * @param context The evaluation context
       * @returns The filtered sequence
       */
      applyPredicate(items, predicateExpr, context) {
        const result = [];
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const itemContext = __spreadProps(__spreadValues({}, context), {
            node: (item == null ? void 0 : item.nodeType) !== void 0 ? item : context.node,
            position: i + 1,
            // XPath uses 1-based indexing
            size: items.length
          });
          if (this.testPredicate(predicateExpr, itemContext)) {
            result.push(item);
          }
        }
        return result;
      }
      /**
       * Test if a predicate expression matches in the given context.
       *
       * A predicate matches if:
       * - It evaluates to a number equal to the context position (numeric predicate)
       * - It evaluates to true (boolean predicate)
       *
       * @param predicateExpr The predicate expression
       * @param context The evaluation context with position/size
       * @returns True if the predicate matches
       */
      testPredicate(predicateExpr, context) {
        const result = predicateExpr.evaluate(context);
        if (typeof result === "number") {
          return result === context.position;
        }
        return this.toBoolean(result);
      }
      /**
       * Convert a value to boolean using XPath rules.
       *
       * XPath boolean conversion rules:
       * - boolean: use as-is
       * - number: 0 or NaN is false, otherwise true
       * - string: empty string is false, non-empty is true
       * - array/sequence: non-empty is true, empty is false
       * - object/node: true
       * - null/undefined: false
       *
       * @param value The value to convert
       * @returns The boolean result
       */
      toBoolean(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "number") {
          return value !== 0 && !isNaN(value);
        }
        if (typeof value === "string") {
          return value.length > 0;
        }
        if (Array.isArray(value)) {
          return value.length > 0;
        }
        if (value === null || value === void 0) {
          return false;
        }
        return true;
      }
    };
    FilteredPathExpression = class extends XPathExpression {
      constructor(filterExpr, pathExpr) {
        super();
        this.filterExpr = filterExpr;
        this.pathExpr = pathExpr;
      }
      /**
       * Evaluate by first evaluating the filter expression,
       * then applying the path expression to each result.
       *
       * @param context The evaluation context
       * @returns The combined result
       */
      evaluate(context) {
        const items = this.filterExpr.evaluate(context);
        if (!Array.isArray(items)) {
          return [];
        }
        const result = [];
        for (const item of items) {
          const itemContext = __spreadProps(__spreadValues({}, context), {
            node: (item == null ? void 0 : item.nodeType) !== void 0 ? item : context.node
          });
          const pathResult = this.pathExpr.evaluate(itemContext);
          if (Array.isArray(pathResult)) {
            result.push(...pathResult);
          } else if (pathResult !== void 0 && pathResult !== null) {
            result.push(pathResult);
          }
        }
        return result;
      }
    };
  }
});

// src/xpath/lib/src/expressions/unary-expression.ts
var XPathUnaryExpression;
var init_unary_expression = __esm({
  "src/xpath/lib/src/expressions/unary-expression.ts"() {
    init_expression();
    XPathUnaryExpression = class extends XPathExpression {
      constructor(operator, operand) {
        super();
        this.operator = operator;
        this.operand = operand;
      }
      evaluate(context) {
        const value = this.operand.evaluate(context);
        const atomic = this.atomize(value);
        if (atomic === null) {
          return null;
        }
        const num = this.toNumber(atomic);
        if (this.operator === "+") {
          return num;
        } else {
          return -num;
        }
      }
      /**
       * Atomize value - extract atomic values from sequences
       */
      atomize(value) {
        if (value === null || value === void 0) {
          return null;
        }
        if (!Array.isArray(value)) {
          return value;
        }
        if (value.length === 0) {
          return null;
        }
        return value[0];
      }
      /**
       * Convert atomic value to number following XPath 2.0 rules
       */
      toNumber(value) {
        if (typeof value === "number") return value;
        if (typeof value === "boolean") return value ? 1 : 0;
        if (typeof value === "string") {
          const trimmed = value.trim();
          if (trimmed === "") return NaN;
          const num = Number(trimmed);
          return num;
        }
        return Number(value);
      }
      toString() {
        return `${this.operator}${this.operand.toString()}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/binary-expression.ts
var XPathBinaryExpression;
var init_binary_expression = __esm({
  "src/xpath/lib/src/expressions/binary-expression.ts"() {
    init_expression();
    XPathBinaryExpression = class extends XPathExpression {
      constructor(left, right, operator) {
        super();
        this.left = left;
        this.right = right;
        this.operator = operator;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        return this.compare(leftValue, rightValue, this.operator);
      }
      /**
       * XPath comparison rules:
       * - If both are node-sets: compare each node in left with each node in right
       * - If one is node-set and other is string: convert node-set to strings and compare
       * - If one is node-set and other is number: convert node-set to numbers and compare
       * - If one is node-set and other is boolean: convert node-set to boolean and compare
       * - Otherwise, convert both to numbers for numeric comparison, or strings for equality
       */
      compare(left, right, operator) {
        const leftIsNodeSet = Array.isArray(left);
        const rightIsNodeSet = Array.isArray(right);
        if (leftIsNodeSet && rightIsNodeSet) {
          return this.compareNodeSets(left, right, operator);
        }
        if (leftIsNodeSet) {
          return this.compareNodeSetToValue(left, right, operator);
        }
        if (rightIsNodeSet) {
          return this.compareValueToNodeSet(left, right, operator);
        }
        return this.comparePrimitives(left, right, operator);
      }
      compareNodeSets(left, right, operator) {
        for (const leftNode of left) {
          const leftStr = this.getStringValue(leftNode);
          for (const rightNode of right) {
            const rightStr = this.getStringValue(rightNode);
            if (this.comparePrimitives(leftStr, rightStr, operator)) {
              return true;
            }
          }
        }
        return false;
      }
      compareNodeSetToValue(nodeSet, value, operator) {
        for (const node of nodeSet) {
          const nodeValue = typeof value === "number" ? Number(this.getStringValue(node)) : this.getStringValue(node);
          if (this.comparePrimitives(nodeValue, value, operator)) {
            return true;
          }
        }
        return false;
      }
      compareValueToNodeSet(value, nodeSet, operator) {
        for (const node of nodeSet) {
          const nodeValue = typeof value === "number" ? Number(this.getStringValue(node)) : this.getStringValue(node);
          if (this.comparePrimitives(value, nodeValue, operator)) {
            return true;
          }
        }
        return false;
      }
      comparePrimitives(left, right, operator) {
        switch (operator) {
          case "=":
            return left == right;
          // Use loose equality for type coercion
          case "!=":
            return left != right;
          case "<":
            return Number(left) < Number(right);
          case ">":
            return Number(left) > Number(right);
          case "<=":
            return Number(left) <= Number(right);
          case ">=":
            return Number(left) >= Number(right);
          default:
            throw new Error(`Unknown operator: ${operator}`);
        }
      }
      getStringValue(node) {
        if (!node) return "";
        if (node.nodeType === 3 || node.nodeType === 2) {
          return node.nodeValue || node.textContent || "";
        }
        if (node.textContent !== void 0) {
          return node.textContent;
        }
        if (node.childNodes) {
          let text = "";
          for (const child of Array.from(node.childNodes)) {
            if (child.nodeType === 3) {
              text += child.nodeValue || "";
            } else if (child.nodeType === 1) {
              text += this.getStringValue(child);
            }
          }
          return text;
        }
        return String(node);
      }
    };
  }
});

// src/xpath/lib/src/expressions/arithmetic-expression.ts
var XPathArithmeticExpression;
var init_arithmetic_expression = __esm({
  "src/xpath/lib/src/expressions/arithmetic-expression.ts"() {
    init_expression();
    XPathArithmeticExpression = class extends XPathExpression {
      constructor(left, right, operator) {
        super();
        this.left = left;
        this.right = right;
        this.operator = operator;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        const leftAtomic = this.atomize(leftValue);
        const rightAtomic = this.atomize(rightValue);
        if (leftAtomic === null || rightAtomic === null) {
          return null;
        }
        const leftNum = this.toNumber(leftAtomic);
        const rightNum = this.toNumber(rightAtomic);
        switch (this.operator) {
          case "+":
            return leftNum + rightNum;
          case "-":
            return leftNum - rightNum;
          case "*":
            return leftNum * rightNum;
          case "div":
            return leftNum / rightNum;
          // Allows Infinity
          case "idiv":
            if (rightNum === 0) {
              throw new Error("XPDY0002: Integer division by zero");
            }
            return Math.trunc(leftNum / rightNum);
          case "mod":
            if (rightNum === 0) {
              throw new Error("XPDY0002: Modulo by zero");
            }
            return leftNum - Math.trunc(leftNum / rightNum) * rightNum;
          default:
            throw new Error(`Unknown arithmetic operator: ${this.operator}`);
        }
      }
      /**
       * Atomize value - extract atomic values from sequences
       * Returns first atomic value or null for empty sequence
       */
      atomize(value) {
        if (value === null || value === void 0) {
          return null;
        }
        if (typeof value === "object" && "numberValue" in value && typeof value.numberValue === "function") {
          return value.numberValue();
        }
        if (!Array.isArray(value)) {
          return value;
        }
        if (value.length === 0) {
          return null;
        }
        return this.atomize(value[0]);
      }
      /**
       * Convert atomic value to number following XPath 2.0 rules
       */
      toNumber(value) {
        if (typeof value === "number") return value;
        if (typeof value === "boolean") return value ? 1 : 0;
        if (typeof value === "string") {
          const trimmed = value.trim();
          if (trimmed === "") return NaN;
          const num = Number(trimmed);
          return num;
        }
        return Number(value);
      }
      toString() {
        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/logical-expression.ts
var XPathLogicalExpression;
var init_logical_expression = __esm({
  "src/xpath/lib/src/expressions/logical-expression.ts"() {
    init_expression();
    XPathLogicalExpression = class extends XPathExpression {
      constructor(left, right, operator) {
        super();
        this.left = left;
        this.right = right;
        this.operator = operator;
      }
      // Effective Boolean Value (EBV) per XPath 2.0 rules (simplified)
      toBoolean(value) {
        if (value === null || value === void 0) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        if (Array.isArray(value)) {
          if (value.length === 0) return false;
          if (value.length === 1) return this.toBoolean(value[0]);
          return true;
        }
        if (typeof value === "number") {
          return value !== 0 && !isNaN(value);
        }
        if (typeof value === "string") {
          return value.length > 0;
        }
        return !!value;
      }
      evaluate(context) {
        const leftValue = this.toBoolean(this.left.evaluate(context));
        if (this.operator === "and") {
          if (!leftValue) return false;
          return this.toBoolean(this.right.evaluate(context));
        }
        if (this.operator === "or") {
          if (leftValue) return true;
          return this.toBoolean(this.right.evaluate(context));
        }
        throw new Error(`Unknown logical operator: ${this.operator}`);
      }
    };
  }
});

// src/xpath/lib/src/expressions/conditional-expression.ts
var XPathConditionalExpression;
var init_conditional_expression = __esm({
  "src/xpath/lib/src/expressions/conditional-expression.ts"() {
    init_expression();
    XPathConditionalExpression = class extends XPathExpression {
      constructor(test, thenExpr, elseExpr) {
        super();
        this.test = test;
        this.thenExpr = thenExpr;
        this.elseExpr = elseExpr;
      }
      // Effective Boolean Value (EBV) per XPath 2.0 rules (simplified)
      toBoolean(value) {
        if (value === null || value === void 0) return false;
        if (typeof value === "boolean") return value;
        if (Array.isArray(value)) {
          if (value.length === 0) return false;
          if (value.length === 1) return this.toBoolean(value[0]);
          return true;
        }
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        return !!value;
      }
      evaluate(context) {
        const testValue = this.toBoolean(this.test.evaluate(context));
        if (testValue) {
          return this.thenExpr.evaluate(context);
        }
        return this.elseExpr.evaluate(context);
      }
    };
  }
});

// src/xpath/lib/src/expressions/for-expression.ts
var XPathForExpression;
var init_for_expression = __esm({
  "src/xpath/lib/src/expressions/for-expression.ts"() {
    init_expression();
    XPathForExpression = class extends XPathExpression {
      constructor(bindings, returnExpr) {
        super();
        this.bindings = bindings;
        this.returnExpr = returnExpr;
      }
      evaluate(context) {
        const initialVariables = context.variables ? __spreadValues({}, context.variables) : {};
        const initialContext = __spreadProps(__spreadValues({}, context), { variables: initialVariables });
        const results = [];
        this.evaluateBinding(0, initialContext, results);
        return results;
      }
      evaluateBinding(index, currentContext, results) {
        var _a;
        if (index >= this.bindings.length) {
          const value = this.returnExpr.evaluate(currentContext);
          this.appendResult(results, value);
          return;
        }
        const binding = this.bindings[index];
        const sequence = this.normalizeSequence(binding.expression.evaluate(currentContext));
        const size = sequence.length;
        for (let i = 0; i < size; i++) {
          const item = sequence[i];
          const variables = __spreadProps(__spreadValues({}, (_a = currentContext.variables) != null ? _a : {}), { [binding.variable]: item });
          const iterationContext = __spreadProps(__spreadValues({}, currentContext), {
            variables,
            node: this.resolveNode(item, currentContext),
            position: i + 1,
            size
          });
          this.evaluateBinding(index + 1, iterationContext, results);
        }
      }
      normalizeSequence(value) {
        if (value === null || value === void 0) {
          return [];
        }
        if (Array.isArray(value)) {
          return value;
        }
        return [value];
      }
      appendResult(results, value) {
        if (value === null || value === void 0) {
          return;
        }
        if (Array.isArray(value)) {
          results.push(...value);
          return;
        }
        results.push(value);
      }
      resolveNode(item, context) {
        if (item && typeof item === "object" && "nodeType" in item) {
          return item;
        }
        return context.node;
      }
    };
  }
});

// src/xpath/lib/src/expressions/quantified-expression.ts
var XPathQuantifiedExpression;
var init_quantified_expression = __esm({
  "src/xpath/lib/src/expressions/quantified-expression.ts"() {
    init_expression();
    XPathQuantifiedExpression = class extends XPathExpression {
      constructor(quantifier, bindings, satisfiesExpr) {
        super();
        this.quantifier = quantifier;
        this.bindings = bindings;
        this.satisfiesExpr = satisfiesExpr;
      }
      evaluate(context) {
        const initialVariables = context.variables ? __spreadValues({}, context.variables) : {};
        const initialContext = __spreadProps(__spreadValues({}, context), { variables: initialVariables });
        if (this.quantifier === "some") {
          return this.evaluateSome(0, initialContext);
        }
        return this.evaluateEvery(0, initialContext);
      }
      evaluateSome(index, currentContext) {
        var _a;
        if (index >= this.bindings.length) {
          return this.toBoolean(this.satisfiesExpr.evaluate(currentContext));
        }
        const binding = this.bindings[index];
        const sequence = this.normalizeSequence(binding.expression.evaluate(currentContext));
        for (let i = 0; i < sequence.length; i++) {
          const item = sequence[i];
          const variables = __spreadProps(__spreadValues({}, (_a = currentContext.variables) != null ? _a : {}), { [binding.variable]: item });
          const iterationContext = __spreadProps(__spreadValues({}, currentContext), {
            variables,
            node: this.resolveNode(item, currentContext),
            position: i + 1,
            size: sequence.length
          });
          if (this.evaluateSome(index + 1, iterationContext)) {
            return true;
          }
        }
        return false;
      }
      evaluateEvery(index, currentContext) {
        var _a;
        if (index >= this.bindings.length) {
          return this.toBoolean(this.satisfiesExpr.evaluate(currentContext));
        }
        const binding = this.bindings[index];
        const sequence = this.normalizeSequence(binding.expression.evaluate(currentContext));
        if (sequence.length === 0) {
          return true;
        }
        for (let i = 0; i < sequence.length; i++) {
          const item = sequence[i];
          const variables = __spreadProps(__spreadValues({}, (_a = currentContext.variables) != null ? _a : {}), { [binding.variable]: item });
          const iterationContext = __spreadProps(__spreadValues({}, currentContext), {
            variables,
            node: this.resolveNode(item, currentContext),
            position: i + 1,
            size: sequence.length
          });
          if (!this.evaluateEvery(index + 1, iterationContext)) {
            return false;
          }
        }
        return true;
      }
      normalizeSequence(value) {
        if (value === null || value === void 0) {
          return [];
        }
        if (Array.isArray(value)) {
          return value;
        }
        return [value];
      }
      resolveNode(item, context) {
        if (item && typeof item === "object" && "nodeType" in item) {
          return item;
        }
        return context.node;
      }
      // Boolean conversion aligning with XPath EBV rules (simplified for current types)
      toBoolean(value) {
        if (value === null || value === void 0) return false;
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
    };
  }
});

// src/xpath/lib/src/types/base.ts
var AtomicTypeImpl;
var init_base = __esm({
  "src/xpath/lib/src/types/base.ts"() {
    init_constants();
    AtomicTypeImpl = class {
      constructor(name, namespace = XS_NAMESPACE, baseType, primitive) {
        this.name = name;
        this.namespace = namespace;
        this.baseType = baseType;
        this.primitive = primitive;
      }
      get qualifiedName() {
        return `{${this.namespace}}${this.name}`;
      }
    };
  }
});

// src/xpath/lib/src/types/sequence-type.ts
var sequence_type_exports = {};
__export(sequence_type_exports, {
  ITEM_TYPE: () => ITEM_TYPE,
  OccurrenceIndicator: () => OccurrenceIndicator,
  SequenceType: () => SequenceType,
  createAtomicSequenceType: () => createAtomicSequenceType,
  createEmptySequenceType: () => createEmptySequenceType,
  createItemSequenceType: () => createItemSequenceType
});
function createEmptySequenceType() {
  return new SequenceType("empty", "ONE" /* EXACTLY_ONE */);
}
function createItemSequenceType(itemType, occurrence = "ONE" /* EXACTLY_ONE */) {
  return new SequenceType(itemType, occurrence);
}
function createAtomicSequenceType(atomicType, occurrence = "ONE" /* EXACTLY_ONE */) {
  const itemType = {
    name: atomicType.name,
    namespace: atomicType.namespace,
    atomicType,
    matches: (value) => {
      if (value === null || value === void 0) return false;
      try {
        return atomicType.validate(value);
      } catch (e) {
        return false;
      }
    }
  };
  return new SequenceType(itemType, occurrence);
}
var OccurrenceIndicator, SequenceType, ITEM_TYPE;
var init_sequence_type = __esm({
  "src/xpath/lib/src/types/sequence-type.ts"() {
    OccurrenceIndicator = /* @__PURE__ */ ((OccurrenceIndicator2) => {
      OccurrenceIndicator2["EXACTLY_ONE"] = "ONE";
      OccurrenceIndicator2["ZERO_OR_ONE"] = "?";
      OccurrenceIndicator2["ZERO_OR_MORE"] = "*";
      OccurrenceIndicator2["ONE_OR_MORE"] = "+";
      return OccurrenceIndicator2;
    })(OccurrenceIndicator || {});
    SequenceType = class {
      /**
       * Create a SequenceType
       *
       * @param itemType - The ItemType (or 'empty' for empty-sequence())
       * @param occurrence - The occurrence indicator (default: EXACTLY_ONE)
       */
      constructor(itemType, occurrence = "ONE" /* EXACTLY_ONE */) {
        if (itemType === "empty" && occurrence !== "ONE" /* EXACTLY_ONE */) {
          throw new Error("empty-sequence() must have exactly one occurrence");
        }
        this.itemType = itemType;
        this.occurrence = occurrence;
      }
      /**
       * Get the ItemType
       */
      getItemType() {
        return this.itemType;
      }
      /**
       * Get the OccurrenceIndicator
       */
      getOccurrence() {
        return this.occurrence;
      }
      /**
       * Check if this is empty-sequence()
       */
      isEmptySequence() {
        return this.itemType === "empty";
      }
      /**
       * Check if this type allows zero items
       */
      allowsZeroItems() {
        return this.isEmptySequence() || this.occurrence === "?" /* ZERO_OR_ONE */ || this.occurrence === "*" /* ZERO_OR_MORE */;
      }
      /**
       * Check if this type allows multiple items
       */
      allowsMultipleItems() {
        return this.occurrence === "*" /* ZERO_OR_MORE */ || this.occurrence === "+" /* ONE_OR_MORE */;
      }
      /**
       * Check if this type requires at least one item
       */
      requiresItems() {
        return !this.allowsZeroItems();
      }
      /**
       * Get a string representation of this SequenceType
       * Examples: "empty-sequence()", "xs:integer", "xs:integer?", "element(*)"
       */
      toString() {
        if (this.isEmptySequence()) {
          return "empty-sequence()";
        }
        const typeName = this.itemType.name;
        const indicator = this.occurrence === "ONE" /* EXACTLY_ONE */ ? "" : this.occurrence;
        return typeName + indicator;
      }
      /**
       * Get the minimum cardinality allowed by this type
       * 0 = allows empty, 1 = requires at least one item
       */
      getMinCardinality() {
        if (this.isEmptySequence() || this.allowsZeroItems()) {
          return 0;
        }
        return 1;
      }
      /**
       * Get the maximum cardinality allowed by this type
       * 1 = exactly one item, Infinity = unbounded
       */
      getMaxCardinality() {
        if (this.allowsMultipleItems()) {
          return Infinity;
        }
        return 1;
      }
      /**
       * Check if another SequenceType is compatible with this one
       * (i.e., can values of that type be assigned to this type)
       *
       * This is a simple compatibility check. Full implementation would require
       * schema information and type hierarchy checking.
       */
      isCompatibleWith(other) {
        if (other.isEmptySequence()) {
          return this.allowsZeroItems();
        }
        const otherMin = other.getMinCardinality();
        const otherMax = other.getMaxCardinality();
        const thisMin = this.getMinCardinality();
        const thisMax = this.getMaxCardinality();
        if (otherMin < thisMin || otherMax > thisMax && thisMax !== Infinity) {
          return false;
        }
        if (this.itemType !== "empty" && other.itemType !== "empty") {
          const thisItemType = this.itemType;
          const otherItemType = other.itemType;
          if (thisItemType.isWildcard) {
            return true;
          }
          return thisItemType.name === otherItemType.name;
        }
        return this.itemType === "empty" ? other.isEmptySequence() : true;
      }
    };
    ITEM_TYPE = {
      name: "item()",
      isWildcard: true,
      matches: () => true
    };
  }
});

// src/xpath/lib/src/types/kind-tests.ts
var KindTestImpl, NodeKindTest, ElementTest, AttributeTest, DocumentNodeTest, TextTest, CommentTest, ProcessingInstructionTest, KIND_TESTS;
var init_kind_tests = __esm({
  "src/xpath/lib/src/types/kind-tests.ts"() {
    KindTestImpl = class {
      constructor(name, nodeKind, nodeName2, nodeType, isWildcardName) {
        this.name = name;
        this.nodeKind = nodeKind;
        this.nodeName = nodeName2;
        this.nodeType = nodeType;
        this.isWildcardName = isWildcardName;
      }
      matches(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (value.nodeType !== this.nodeKind) {
          return false;
        }
        if (this.nodeName && !this.isWildcardName) {
          if (value.localName !== this.nodeName && value.nodeName !== this.nodeName) {
            return false;
          }
        }
        if (this.nodeType && value.type !== this.nodeType) {
          return false;
        }
        return true;
      }
    };
    NodeKindTest = class extends KindTestImpl {
      constructor() {
        super("node()", "node");
      }
      matches() {
        return true;
      }
    };
    ElementTest = class extends KindTestImpl {
      constructor(elementName, elementType) {
        const name = elementName ? elementType ? `element(${elementName}, ${elementType})` : `element(${elementName})` : "element()";
        super(name, "element", elementName, elementType, !elementName);
      }
    };
    AttributeTest = class extends KindTestImpl {
      constructor(attributeName, attributeType) {
        const name = attributeName ? attributeType ? `attribute(${attributeName}, ${attributeType})` : `attribute(${attributeName})` : "attribute()";
        super(name, "attribute", attributeName, attributeType, !attributeName);
      }
    };
    DocumentNodeTest = class extends KindTestImpl {
      constructor(elementTest) {
        const name = elementTest ? `document-node(${elementTest.name})` : "document-node()";
        super(name, "document", void 0, void 0, true);
        this.elementTest = elementTest;
      }
      matches(value) {
        if (!super.matches(value)) {
          return false;
        }
        if (this.elementTest && value.documentElement) {
          return this.elementTest.matches(value.documentElement);
        }
        return true;
      }
    };
    TextTest = class extends KindTestImpl {
      constructor() {
        super("text()", "text");
      }
    };
    CommentTest = class extends KindTestImpl {
      constructor() {
        super("comment()", "comment");
      }
    };
    ProcessingInstructionTest = class extends KindTestImpl {
      constructor(target) {
        const name = target ? `processing-instruction(${target})` : "processing-instruction()";
        super(name, "processing-instruction", target, void 0, !target);
      }
    };
    KIND_TESTS = {
      node: new NodeKindTest(),
      element: new ElementTest(),
      attribute: new AttributeTest(),
      documentNode: new DocumentNodeTest(),
      text: new TextTest(),
      comment: new CommentTest(),
      processingInstruction: new ProcessingInstructionTest()
    };
  }
});

// src/xpath/lib/src/types/union-type.ts
var union_type_exports = {};
__export(union_type_exports, {
  UnionItemType: () => UnionItemType,
  createUnionType: () => createUnionType,
  isUnionType: () => isUnionType
});
function createUnionType(...memberTypes) {
  return new UnionItemType(memberTypes);
}
function isUnionType(itemType) {
  return itemType instanceof UnionItemType;
}
var UnionItemType;
var init_union_type = __esm({
  "src/xpath/lib/src/types/union-type.ts"() {
    UnionItemType = class _UnionItemType {
      /**
       * Create a UnionItemType
       *
       * @param memberTypes - Array of ItemTypes that form the union
       * @throws Error if memberTypes is empty or contains only one type
       */
      constructor(memberTypes) {
        this.isWildcard = false;
        if (memberTypes.length === 0) {
          throw new Error("Union type must have at least one member type");
        }
        if (memberTypes.length === 1) {
          throw new Error(
            "Union type must have at least two member types (use the single type directly)"
          );
        }
        if (memberTypes.some((t) => t === "empty")) {
          throw new Error("empty-sequence() cannot be used in union types");
        }
        this.memberTypes = memberTypes;
        this.name = memberTypes.map((t) => t.name).join(" | ");
      }
      /**
       * Check if a value matches this union type
       * Returns true if the value matches ANY of the member types
       *
       * @param value - The value to check
       * @returns true if value matches any member type
       */
      matches(value) {
        return this.memberTypes.some((memberType) => memberType.matches(value));
      }
      /**
       * Get all member types in this union
       */
      getMemberTypes() {
        return [...this.memberTypes];
      }
      /**
       * Check if this union contains a specific type
       *
       * @param typeName - The name of the type to check for
       * @returns true if any member type has this name
       */
      containsType(typeName) {
        return this.memberTypes.some((memberType) => memberType.name === typeName);
      }
      /**
       * Flatten nested unions into a single-level union
       * If any member is itself a union, extract its members
       *
       * @returns A new UnionItemType with all unions flattened
       */
      flatten() {
        const flattenedTypes = [];
        for (const memberType of this.memberTypes) {
          if (memberType instanceof _UnionItemType) {
            const nested = memberType.flatten();
            flattenedTypes.push(...nested.memberTypes);
          } else {
            flattenedTypes.push(memberType);
          }
        }
        const uniqueTypes = flattenedTypes.filter(
          (type, index, self) => self.findIndex((t) => t.name === type.name) === index
        );
        return new _UnionItemType(uniqueTypes);
      }
      /**
       * Get the most general atomic type in the union
       * Used for type promotion in expressions
       *
       * @returns The most general atomic type, or undefined if no atomic types
       */
      getMostGeneralAtomicType() {
        const atomicTypes = this.memberTypes.filter((t) => t.atomicType !== void 0).map((t) => t.atomicType);
        if (atomicTypes.length === 0) {
          return void 0;
        }
        const hasString = atomicTypes.some((t) => t.name === "string");
        if (hasString) {
          return atomicTypes.find((t) => t.name === "string");
        }
        const hasDouble = atomicTypes.some((t) => t.name === "double");
        if (hasDouble) {
          return atomicTypes.find((t) => t.name === "double");
        }
        const hasDecimal = atomicTypes.some((t) => t.name === "decimal");
        if (hasDecimal) {
          return atomicTypes.find((t) => t.name === "decimal");
        }
        return atomicTypes[0];
      }
      /**
       * String representation of this union type
       */
      toString() {
        return this.name;
      }
    };
  }
});

// src/xpath/lib/src/types/sequence-type-matcher.ts
function matchesItemType(value, itemType) {
  const { isUnionType: isUnionType2 } = (init_union_type(), __toCommonJS(union_type_exports));
  if (isUnionType2(itemType)) {
    return itemType.matches(value);
  }
  const hasMapTest = itemType.isMapTest;
  const hasArrayTest = itemType.isArrayTest;
  const hasFunctionTest = itemType.isFunctionTest;
  if (hasMapTest || hasArrayTest || hasFunctionTest) {
    return itemType.matches(value);
  }
  if (itemType.isWildcard) {
    return value !== null && value !== void 0;
  }
  return itemType.matches(value);
}
function matchesSequenceType(values, sequenceType) {
  const sequence = Array.isArray(values) ? values : [values].filter((v) => v !== void 0);
  if (sequence.length === 0) {
    if (sequenceType.isEmptySequence()) {
      return { matches: true, itemCount: 0 };
    }
    if (sequenceType.allowsZeroItems()) {
      return { matches: true, itemCount: 0 };
    }
    return {
      matches: false,
      itemCount: 0,
      reason: `Empty sequence not allowed by ${sequenceType.toString()}`
    };
  }
  if (sequenceType.isEmptySequence()) {
    return {
      matches: false,
      itemCount: sequence.length,
      reason: `Expected empty sequence but got ${sequence.length} item(s)`
    };
  }
  const itemType = sequenceType.getItemType();
  if (itemType === "empty") {
    return {
      matches: false,
      itemCount: sequence.length,
      reason: "Expected empty sequence"
    };
  }
  const typedItemType = itemType;
  const unmatched = sequence.findIndex((item) => !matchesItemType(item, typedItemType));
  if (unmatched !== -1) {
    const unmatchedItem = sequence[unmatched];
    let itemDesc;
    try {
      if (typeof unmatchedItem === "object" && unmatchedItem !== null) {
        itemDesc = JSON.stringify(unmatchedItem);
      } else {
        itemDesc = String(unmatchedItem);
      }
    } catch (e) {
      itemDesc = "[complex value]";
    }
    return {
      matches: false,
      itemCount: sequence.length,
      reason: `Item ${unmatched} (${itemDesc}) does not match ${typedItemType.name}`
    };
  }
  const occurrence = sequenceType.getOccurrence();
  const itemCount = sequence.length;
  switch (occurrence) {
    case "ONE" /* EXACTLY_ONE */:
      if (itemCount === 1) {
        return { matches: true, itemCount };
      }
      return {
        matches: false,
        itemCount,
        reason: `Expected exactly one item but got ${itemCount}`
      };
    case "?" /* ZERO_OR_ONE */:
      if (itemCount <= 1) {
        return { matches: true, itemCount };
      }
      return {
        matches: false,
        itemCount,
        reason: `Expected zero or one item but got ${itemCount}`
      };
    case "*" /* ZERO_OR_MORE */:
      return { matches: true, itemCount };
    case "+" /* ONE_OR_MORE */:
      if (itemCount >= 1) {
        return { matches: true, itemCount };
      }
      return {
        matches: false,
        itemCount: 0,
        reason: `Expected one or more items but got none`
      };
    default:
      return {
        matches: false,
        itemCount,
        reason: `Unknown occurrence indicator: ${occurrence}`
      };
  }
}
var init_sequence_type_matcher = __esm({
  "src/xpath/lib/src/types/sequence-type-matcher.ts"() {
    init_sequence_type();
  }
});

// src/xpath/lib/src/types/atomization.ts
function isNode(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  return typeof value.nodeType === "string" || typeof value.nodeName === "string" || typeof value.textContent === "string";
}
function hasElementOnlyContent(node) {
  if (!node.childNodes || node.childNodes.length === 0) {
    return false;
  }
  return node.childNodes.every((child) => child.nodeType === "element");
}
function getNodeTypedValue(node) {
  if (node.typedValue !== void 0) {
    if (node.type) {
      const atomicType = getAtomicType(node.type);
      return { value: node.typedValue, type: atomicType };
    }
    return { value: node.typedValue, type: void 0 };
  }
  if (node.type) {
    const atomicType = getAtomicType(node.type);
    const textContent = getNodeStringValue(node);
    if (atomicType) {
      try {
        const castValue = atomicType.cast(textContent);
        return { value: castValue, type: atomicType };
      } catch (e) {
        return { value: textContent, type: void 0 };
      }
    }
  }
  return { value: getNodeStringValue(node), type: void 0 };
}
function getNodeStringValue(node) {
  if (node.nodeType === "text" || node.nodeType === "attribute" || node.nodeType === "comment") {
    return node.value || node.textContent || "";
  }
  if (node.nodeType === "processing-instruction") {
    return node.value || "";
  }
  if (node.nodeType === "element" || node.nodeType === "document") {
    if (node.textContent) {
      return node.textContent;
    }
    if (!node.childNodes) {
      return "";
    }
    let result = "";
    for (const child of node.childNodes) {
      if (child.nodeType === "text") {
        result += child.value || child.textContent || "";
      } else if (child.nodeType === "element") {
        result += getNodeStringValue(child);
      }
    }
    return result;
  }
  return "";
}
function atomize(value, strict = false) {
  if (value === void 0 || value === null) {
    return {
      values: [],
      type: void 0,
      isEmpty: true
    };
  }
  if (Array.isArray(value)) {
    const results = [];
    let resultType = void 0;
    let hasError = false;
    let errorCode = "";
    for (const item of value) {
      const result = atomize(item, strict);
      if (result.error) {
        hasError = true;
        errorCode = result.error;
        break;
      }
      results.push(...result.values);
      if (result.type && !resultType) {
        resultType = result.type;
      }
    }
    return {
      values: results,
      type: resultType,
      isEmpty: results.length === 0,
      error: hasError ? errorCode : void 0
    };
  }
  if (isNode(value)) {
    if (strict && hasElementOnlyContent(value)) {
      return {
        values: [],
        type: void 0,
        isEmpty: false,
        error: "FOTY0012"
        // Cannot atomize node with element-only content
      };
    }
    const { value: atomizedValue, type } = getNodeTypedValue(value);
    return {
      values: atomizedValue !== void 0 ? [atomizedValue] : [],
      type,
      isEmpty: atomizedValue === void 0
    };
  }
  return {
    values: [value],
    type: void 0,
    isEmpty: false
  };
}
var init_atomization = __esm({
  "src/xpath/lib/src/types/atomization.ts"() {
    init_types();
  }
});

// src/xpath/lib/src/expressions/map-constructor-expression.ts
function isXPathMap(value) {
  return value && typeof value === "object" && value.__isMap === true;
}
var XPathMapConstructorExpression;
var init_map_constructor_expression = __esm({
  "src/xpath/lib/src/expressions/map-constructor-expression.ts"() {
    init_atomization();
    init_errors();
    XPathMapConstructorExpression = class {
      constructor(entries) {
        this.entries = entries;
      }
      evaluate(context) {
        const result = {};
        for (const entry of this.entries) {
          const keyResult = entry.key.evaluate(context);
          const atomicKeys = atomize(keyResult);
          if (atomicKeys.error) {
            throw typeMismatch("atomic value", "value with error", "map key");
          }
          if (atomicKeys.isEmpty || atomicKeys.values.length === 0) {
            throw typeMismatch("atomic value", "empty sequence", "map key");
          }
          if (atomicKeys.values.length > 1) {
            throw typeMismatch("single atomic value", "sequence", "map key");
          }
          const key = atomicKeys.values[0];
          const keyString = String(key);
          const value = entry.value.evaluate(context);
          result[keyString] = value;
        }
        return this.createMap(result);
      }
      /**
       * Create a map object with type marker.
       * Maps are distinguishable from plain objects and arrays.
       */
      createMap(entries) {
        const map = /* @__PURE__ */ Object.create(null);
        map.__isMap = true;
        Object.assign(map, entries);
        return map;
      }
    };
  }
});

// src/xpath/lib/src/expressions/array-constructor-expression.ts
function isXPathArray(value) {
  return value && typeof value === "object" && value.__isArray === true;
}
function createXPathArray(members) {
  return {
    __isArray: true,
    members
  };
}
function getArraySize(arr) {
  return arr.members.length;
}
function getArrayMember(arr, position) {
  if (position < 1 || position > arr.members.length) {
    throw new Error(
      `FOAY0001: Array index ${position} out of bounds (array size: ${arr.members.length})`
    );
  }
  return arr.members[position - 1];
}
var XPathSquareBracketArrayConstructor, XPathCurlyBraceArrayConstructor;
var init_array_constructor_expression = __esm({
  "src/xpath/lib/src/expressions/array-constructor-expression.ts"() {
    XPathSquareBracketArrayConstructor = class {
      constructor(items) {
        this.items = items;
      }
      evaluate(context) {
        const members = [];
        for (const item of this.items) {
          const value = item.evaluate(context);
          members.push(value);
        }
        return createXPathArray(members);
      }
      toString() {
        const itemStrs = this.items.map((i) => i.toString()).join(", ");
        return `[${itemStrs}]`;
      }
    };
    XPathCurlyBraceArrayConstructor = class {
      constructor(expr) {
        this.expr = expr;
      }
      evaluate(context) {
        const result = this.expr.evaluate(context);
        const members = this.toSequence(result);
        return createXPathArray(members);
      }
      /**
       * Convert any value to a sequence (array) of items.
       */
      toSequence(value) {
        if (value === null || value === void 0) {
          return [];
        }
        if (Array.isArray(value)) {
          return value;
        }
        if (isXPathArray(value)) {
          return [value];
        }
        return [value];
      }
      toString() {
        return `array { ${this.expr.toString()} }`;
      }
    };
  }
});

// src/xpath/lib/src/types/typed-collection-types.ts
var typed_collection_types_exports = {};
__export(typed_collection_types_exports, {
  createTypedArrayTest: () => createTypedArrayTest,
  createTypedMapTest: () => createTypedMapTest,
  isTypedArrayTest: () => isTypedArrayTest,
  isTypedMapTest: () => isTypedMapTest
});
function createTypedMapTest(keyType, valueType) {
  const isWildcardMapTest = keyType === null && valueType === null;
  const itemType = {
    name: formatMapTypeName(keyType, valueType),
    isMapTest: true,
    keyType,
    valueType,
    isWildcard: isWildcardMapTest,
    // TypedMapItemType.isWildcard field
    namespace: void 0,
    matches(value) {
      if (!isXPathMap(value)) {
        return false;
      }
      if (isWildcardMapTest) {
        return true;
      }
      const entries = Object.entries(value).filter(
        ([key]) => !key.startsWith("_") && !key.startsWith("__")
      );
      for (const [key, val] of entries) {
        if (keyType !== null) {
          const matchResult = matchesSequenceType(key, keyType);
          if (!matchResult.matches) {
            return false;
          }
        }
        if (valueType !== null) {
          const matchResult = matchesSequenceType(val, valueType);
          if (!matchResult.matches) {
            return false;
          }
        }
      }
      return true;
    }
  };
  return itemType;
}
function createTypedArrayTest(memberType) {
  const isWildcardArrayTest = memberType === null;
  const itemType = {
    name: formatArrayTypeName(memberType),
    isArrayTest: true,
    memberType,
    isWildcard: isWildcardArrayTest,
    // TypedArrayItemType.isWildcard field
    namespace: void 0,
    matches(value) {
      if (!isXPathArray(value)) {
        return false;
      }
      if (isWildcardArrayTest) {
        return true;
      }
      const members = value.members || [];
      for (const member of members) {
        const matchResult = matchesSequenceType(member, memberType);
        if (!matchResult.matches) {
          return false;
        }
      }
      return true;
    }
  };
  return itemType;
}
function formatMapTypeName(keyType, valueType) {
  if (keyType === null && valueType === null) {
    return "map(*)";
  }
  const keyStr = keyType ? keyType.toString() : "*";
  const valueStr = valueType ? valueType.toString() : "*";
  return `map(${keyStr}, ${valueStr})`;
}
function formatArrayTypeName(memberType) {
  if (memberType === null) {
    return "array(*)";
  }
  return `array(${memberType.toString()})`;
}
function isTypedMapTest(itemType) {
  return itemType.isMapTest === true;
}
function isTypedArrayTest(itemType) {
  return itemType.isArrayTest === true;
}
var init_typed_collection_types = __esm({
  "src/xpath/lib/src/types/typed-collection-types.ts"() {
    init_map_constructor_expression();
    init_array_constructor_expression();
    init_sequence_type_matcher();
  }
});

// src/xpath/lib/src/types/type-promotion.ts
var init_type_promotion = __esm({
  "src/xpath/lib/src/types/type-promotion.ts"() {
    init_types();
  }
});

// src/xpath/lib/src/types/simple-types.ts
var AnyAtomicTypeImpl, UntypedAtomicImpl, StringTypeImpl, BooleanTypeImpl;
var init_simple_types = __esm({
  "src/xpath/lib/src/types/simple-types.ts"() {
    init_base();
    AnyAtomicTypeImpl = class extends AtomicTypeImpl {
      constructor() {
        super("anyAtomicType", XS_NAMESPACE);
      }
      validate(value) {
        return value !== null && value !== void 0 && typeof value !== "object";
      }
      cast(value) {
        return value;
      }
    };
    UntypedAtomicImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("untypedAtomic", XS_NAMESPACE, baseType, baseType);
      }
      validate(value) {
        return typeof value === "string";
      }
      cast(value) {
        return String(value);
      }
    };
    StringTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("string", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "string";
      }
      cast(value) {
        if (value === null || value === void 0) {
          throw new Error("Cannot cast null or undefined to xs:string");
        }
        return String(value);
      }
    };
    BooleanTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("boolean", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "boolean";
      }
      cast(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "string") {
          const trimmed = value.trim().toLowerCase();
          if (trimmed === "true" || trimmed === "1") return true;
          if (trimmed === "false" || trimmed === "0") return false;
          throw new Error(`Cannot cast "${value}" to xs:boolean`);
        }
        if (typeof value === "number") {
          if (value === 0) return false;
          if (value === 1) return true;
          throw new Error(`Cannot cast ${value} to xs:boolean`);
        }
        throw new Error(`Cannot cast ${typeof value} to xs:boolean`);
      }
    };
  }
});

// src/xpath/lib/src/types/numeric-types.ts
var DecimalTypeImpl, FloatTypeImpl, DoubleTypeImpl, IntegerTypeImpl;
var init_numeric_types = __esm({
  "src/xpath/lib/src/types/numeric-types.ts"() {
    init_base();
    DecimalTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("decimal", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        if (typeof value === "number") {
          return isFinite(value);
        }
        return false;
      }
      cast(value) {
        if (typeof value === "number" && isFinite(value)) return value;
        if (typeof value === "string") {
          const num = parseFloat(value);
          if (!isFinite(num)) throw new Error(`Cannot cast "${value}" to xs:decimal`);
          return num;
        }
        if (typeof value === "boolean") return value ? 1 : 0;
        throw new Error(`Cannot cast ${typeof value} to xs:decimal`);
      }
    };
    FloatTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("float", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "number";
      }
      cast(value) {
        if (typeof value === "number") return value;
        if (typeof value === "string") {
          if (value === "INF") return Infinity;
          if (value === "-INF") return -Infinity;
          if (value === "NaN") return NaN;
          const num = parseFloat(value);
          if (isNaN(num)) throw new Error(`Cannot cast "${value}" to xs:float`);
          return num;
        }
        if (typeof value === "boolean") return value ? 1 : 0;
        throw new Error(`Cannot cast ${typeof value} to xs:float`);
      }
    };
    DoubleTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("double", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "number";
      }
      cast(value) {
        if (typeof value === "number") return value;
        if (typeof value === "string") {
          if (value === "INF") return Infinity;
          if (value === "-INF") return -Infinity;
          if (value === "NaN") return NaN;
          const num = parseFloat(value);
          if (isNaN(num)) throw new Error(`Cannot cast "${value}" to xs:double`);
          return num;
        }
        if (typeof value === "boolean") return value ? 1 : 0;
        throw new Error(`Cannot cast ${typeof value} to xs:double`);
      }
    };
    IntegerTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType, primitive) {
        super("integer", XS_NAMESPACE, baseType, primitive);
      }
      validate(value) {
        return typeof value === "number" && Number.isInteger(value) && isFinite(value);
      }
      cast(value) {
        const num = this.baseType.cast(value);
        const intVal = Math.trunc(num);
        if (!isFinite(intVal)) throw new Error(`Cannot cast ${value} to xs:integer`);
        return intVal;
      }
    };
  }
});

// src/xpath/lib/src/types/datetime-types.ts
function parseDuration(value) {
  const match = value.match(
    /^(-)?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/
  );
  if (!match) {
    throw new Error(`Invalid duration format: "${value}"`);
  }
  const hasComponents = match.slice(2).some((component) => component !== void 0);
  if (!hasComponents) {
    throw new Error(`Invalid duration format: "${value}"`);
  }
  const isNegative = !!match[1];
  const sign = isNegative ? -1 : 1;
  return {
    negative: isNegative,
    years: sign * (parseInt(match[2]) || 0),
    months: sign * (parseInt(match[3]) || 0),
    days: sign * (parseInt(match[4]) || 0),
    hours: sign * (parseInt(match[5]) || 0),
    minutes: sign * (parseInt(match[6]) || 0),
    seconds: sign * (parseFloat(match[7]) || 0)
  };
}
function parseTime(value) {
  const match = value.match(/^(\d{2}):(\d{2}):(\d{2}(?:\.\d+)?)(?:Z|([+-])(\d{2}):(\d{2}))?$/);
  if (!match) {
    throw new Error(`Invalid time format: "${value}"`);
  }
  const hours = parseInt(match[1], 10);
  const minutes = parseInt(match[2], 10);
  const seconds = parseFloat(match[3]);
  if (hours < 0 || hours > 23) {
    throw new Error(`Invalid hours value: ${hours}`);
  }
  if (minutes < 0 || minutes > 59) {
    throw new Error(`Invalid minutes value: ${minutes}`);
  }
  if (seconds < 0 || seconds >= 60) {
    throw new Error(`Invalid seconds value: ${seconds}`);
  }
  let timezone;
  if (match[4]) {
    timezone = {
      sign: match[4],
      hours: parseInt(match[5], 10),
      minutes: parseInt(match[6], 10)
    };
  }
  return { hours, minutes, seconds, timezone };
}
var DurationTypeImpl, DateTimeTypeImpl, DateTypeImpl, TimeTypeImpl;
var init_datetime_types = __esm({
  "src/xpath/lib/src/types/datetime-types.ts"() {
    init_base();
    DurationTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("duration", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        if (typeof value === "object" && value !== null && "years" in value) {
          return true;
        }
        return false;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          return parseDuration(value);
        }
        throw new Error(`Cannot cast ${typeof value} to xs:duration`);
      }
    };
    DateTimeTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("dateTime", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return value instanceof Date;
      }
      cast(value) {
        if (value instanceof Date) return value;
        if (typeof value === "string") {
          const date = new Date(value);
          if (isNaN(date.getTime())) {
            throw new Error(`Invalid dateTime value: "${value}"`);
          }
          return date;
        }
        throw new Error(`Cannot cast ${typeof value} to xs:dateTime`);
      }
    };
    DateTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType, primitive) {
        super("date", XS_NAMESPACE, baseType, primitive);
      }
      validate(value) {
        return value instanceof Date;
      }
      cast(value) {
        const dateTime = this.baseType.cast(value);
        const date = new Date(dateTime);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    TimeTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType, primitive) {
        super("time", XS_NAMESPACE, baseType, primitive);
      }
      validate(value) {
        if (typeof value === "object" && value !== null && "hours" in value) {
          return true;
        }
        return false;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          return parseTime(value);
        }
        throw new Error(`Cannot cast ${typeof value} to xs:time`);
      }
    };
  }
});

// src/xpath/lib/src/types/gregorian-types.ts
var GYearMonthTypeImpl, GYearTypeImpl, GMonthDayTypeImpl, GDayTypeImpl, GMonthTypeImpl;
var init_gregorian_types = __esm({
  "src/xpath/lib/src/types/gregorian-types.ts"() {
    init_base();
    GYearMonthTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("gYearMonth", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "year" in value && "month" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const match = value.match(/^(-?\d{4})-(\d{2})$/);
          if (!match) {
            throw new Error(`Invalid gYearMonth format: "${value}"`);
          }
          const year = parseInt(match[1], 10);
          const month = parseInt(match[2], 10);
          if (month < 1 || month > 12) {
            throw new Error(`Invalid month value: ${month}`);
          }
          return { year, month };
        }
        throw new Error(`Cannot cast ${typeof value} to xs:gYearMonth`);
      }
    };
    GYearTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("gYear", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "year" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const match = value.match(/^(-?\d{4})$/);
          if (!match) {
            throw new Error(`Invalid gYear format: "${value}"`);
          }
          return { year: parseInt(match[1], 10) };
        }
        throw new Error(`Cannot cast ${typeof value} to xs:gYear`);
      }
    };
    GMonthDayTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("gMonthDay", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "month" in value && "day" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const match = value.match(/^--(\d{2})-(\d{2})$/);
          if (!match) {
            throw new Error(`Invalid gMonthDay format: "${value}"`);
          }
          const month = parseInt(match[1], 10);
          const day = parseInt(match[2], 10);
          if (month < 1 || month > 12) {
            throw new Error(`Invalid month value: ${month}`);
          }
          if (day < 1 || day > 31) {
            throw new Error(`Invalid day value: ${day}`);
          }
          return { month, day };
        }
        throw new Error(`Cannot cast ${typeof value} to xs:gMonthDay`);
      }
    };
    GDayTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("gDay", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "day" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const match = value.match(/^---(\d{2})$/);
          if (!match) {
            throw new Error(`Invalid gDay format: "${value}"`);
          }
          const day = parseInt(match[1], 10);
          if (day < 1 || day > 31) {
            throw new Error(`Invalid day value: ${day}`);
          }
          return { day };
        }
        throw new Error(`Cannot cast ${typeof value} to xs:gDay`);
      }
    };
    GMonthTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("gMonth", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "month" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const match = value.match(/^--(\d{2})$/);
          if (!match) {
            throw new Error(`Invalid gMonth format: "${value}"`);
          }
          const month = parseInt(match[1], 10);
          if (month < 1 || month > 12) {
            throw new Error(`Invalid month value: ${month}`);
          }
          return { month };
        }
        throw new Error(`Cannot cast ${typeof value} to xs:gMonth`);
      }
    };
  }
});

// src/xpath/lib/src/types/binary-types.ts
var HexBinaryTypeImpl, Base64BinaryTypeImpl;
var init_binary_types = __esm({
  "src/xpath/lib/src/types/binary-types.ts"() {
    init_base();
    HexBinaryTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("hexBinary", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        if (typeof value === "string") {
          return /^[0-9A-Fa-f]*$/.test(value) && value.length % 2 === 0;
        }
        return value instanceof Uint8Array;
      }
      cast(value) {
        if (typeof value === "string") {
          if (!this.validate(value)) {
            throw new Error(`Invalid hexBinary format: "${value}"`);
          }
          return value.toUpperCase();
        }
        if (value instanceof Uint8Array) {
          return Array.from(value).map((b) => b.toString(16).padStart(2, "0")).join("").toUpperCase();
        }
        throw new Error(`Cannot cast ${typeof value} to xs:hexBinary`);
      }
    };
    Base64BinaryTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("base64Binary", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        if (typeof value === "string") {
          return /^[A-Za-z0-9+/]*={0,2}$/.test(value) && value.length % 4 === 0;
        }
        return value instanceof Uint8Array;
      }
      cast(value) {
        if (typeof value === "string") {
          if (!this.validate(value)) {
            throw new Error(`Invalid base64Binary format: "${value}"`);
          }
          return value;
        }
        if (value instanceof Uint8Array) {
          const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          let result = "";
          let i = 0;
          const len = value.length;
          while (i < len) {
            const a = value[i++];
            const hasB = i < len;
            const b = hasB ? value[i++] : 0;
            const hasC = i < len;
            const c = hasC ? value[i++] : 0;
            const bitmap = a << 16 | b << 8 | c;
            result += chars[bitmap >> 18 & 63];
            result += chars[bitmap >> 12 & 63];
            result += hasB ? chars[bitmap >> 6 & 63] : "=";
            result += hasC ? chars[bitmap & 63] : "=";
          }
          return result;
        }
        throw new Error(`Cannot cast ${typeof value} to xs:base64Binary`);
      }
    };
  }
});

// src/xpath/lib/src/types/uri-qname-types.ts
var AnyURITypeImpl, QNameTypeImpl;
var init_uri_qname_types = __esm({
  "src/xpath/lib/src/types/uri-qname-types.ts"() {
    init_base();
    AnyURITypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("anyURI", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "string";
      }
      cast(value) {
        if (typeof value === "string") return value;
        throw new Error(`Cannot cast ${typeof value} to xs:anyURI`);
      }
    };
    QNameTypeImpl = class extends AtomicTypeImpl {
      constructor(baseType) {
        super("QName", XS_NAMESPACE, baseType, void 0);
      }
      validate(value) {
        return typeof value === "object" && value !== null && "localName" in value && "namespaceURI" in value;
      }
      cast(value) {
        if (this.validate(value)) return value;
        if (typeof value === "string") {
          const parts = value.split(":");
          if (parts.length === 1) {
            return { localName: parts[0], namespaceURI: "", prefix: void 0 };
          }
          if (parts.length === 2) {
            return { localName: parts[1], namespaceURI: "", prefix: parts[0] };
          }
        }
        throw new Error(`Cannot cast ${typeof value} to xs:QName`);
      }
    };
  }
});

// src/xpath/lib/src/types/integer-derived-types.ts
var IntegerDerivedTypeImpl;
var init_integer_derived_types = __esm({
  "src/xpath/lib/src/types/integer-derived-types.ts"() {
    init_base();
    IntegerDerivedTypeImpl = class extends AtomicTypeImpl {
      constructor(name, baseType, primitive, min, max) {
        super(name, XS_NAMESPACE, baseType, primitive);
        this.min = min;
        this.max = max;
      }
      validate(value) {
        if (typeof value !== "number" || !Number.isInteger(value) || !isFinite(value) || !Number.isSafeInteger(value)) {
          return false;
        }
        if (this.min !== void 0 && value < this.min) return false;
        if (this.max !== void 0 && value > this.max) return false;
        return true;
      }
      cast(value) {
        const num = this.baseType.cast(value);
        if (!Number.isSafeInteger(num)) {
          throw new Error(`Value ${num} is not a safe integer for ${this.name}`);
        }
        if (this.min !== void 0 && num < this.min) {
          throw new Error(`Value ${num} is below minimum ${this.min} for ${this.name}`);
        }
        if (this.max !== void 0 && num > this.max) {
          throw new Error(`Value ${num} is above maximum ${this.max} for ${this.name}`);
        }
        return num;
      }
    };
  }
});

// src/xpath/lib/src/types/function-type.ts
var function_type_exports = {};
__export(function_type_exports, {
  ARRAY_NAMESPACE: () => ARRAY_NAMESPACE,
  FN_NAMESPACE: () => FN_NAMESPACE,
  MAP_NAMESPACE: () => MAP_NAMESPACE,
  MATH_NAMESPACE: () => MATH_NAMESPACE,
  createFunctionItem: () => createFunctionItem,
  createFunctionTest: () => createFunctionTest,
  createFunctionType: () => createFunctionType,
  describeFunctionType: () => describeFunctionType,
  isFunctionItem: () => isFunctionItem
});
function createFunctionItem(implementation, arity, name, namespace, type) {
  return {
    __isFunctionItem: true,
    implementation,
    arity,
    name,
    namespace,
    type
  };
}
function createFunctionTest(parameterTypes = null, returnType = null, opts) {
  var _a, _b;
  const isWildcard = (_a = opts == null ? void 0 : opts.isWildcard) != null ? _a : parameterTypes === null && returnType === null;
  const paramCount = Array.isArray(parameterTypes) ? parameterTypes.length : void 0;
  const typeName = isWildcard ? "function(*)" : `function(${(_b = parameterTypes == null ? void 0 : parameterTypes.map((p) => p.toString()).join(", ")) != null ? _b : ""})` + (returnType ? ` as ${returnType.toString()}` : "");
  return {
    name: typeName,
    isFunctionTest: true,
    isWildcard,
    parameterTypes: parameterTypes != null ? parameterTypes : void 0,
    returnType: returnType != null ? returnType : void 0,
    matches(value) {
      if (value === null || value === void 0) {
        return false;
      }
      const isFunctionItemLike = typeof value === "object" && value.__isFunctionItem === true || typeof value === "function";
      const isTypedMap = typeof value === "object" && (value == null ? void 0 : value.__isMap) === true;
      const isTypedArray = typeof value === "object" && (value == null ? void 0 : value.__isArray) === true;
      if (!isFunctionItemLike && !isTypedMap && !isTypedArray) {
        return false;
      }
      if (isWildcard) {
        return true;
      }
      if (paramCount !== void 0) {
        const observedArity = isTypedMap || isTypedArray ? 1 : typeof value === "function" ? value.length : typeof (value == null ? void 0 : value.arity) === "number" ? value.arity : void 0;
        if (observedArity !== void 0 && observedArity !== paramCount) {
          return false;
        }
      }
      return true;
    }
  };
}
function isFunctionItem(value) {
  return value && typeof value === "object" && value.__isFunctionItem === true;
}
function createFunctionType(parameterTypes, returnType) {
  return {
    kind: "function",
    parameterTypes,
    returnType,
    arity: parameterTypes.length
  };
}
function describeFunctionType(type) {
  const params = type.parameterTypes.map((p) => String(p)).join(", ");
  return `function(${params}) as ${type.returnType}`;
}
var FN_NAMESPACE, MATH_NAMESPACE, MAP_NAMESPACE, ARRAY_NAMESPACE;
var init_function_type = __esm({
  "src/xpath/lib/src/types/function-type.ts"() {
    FN_NAMESPACE = "http://www.w3.org/2005/xpath-functions";
    MATH_NAMESPACE = "http://www.w3.org/2005/xpath-functions/math";
    MAP_NAMESPACE = "http://www.w3.org/2005/xpath-functions/map";
    ARRAY_NAMESPACE = "http://www.w3.org/2005/xpath-functions/array";
  }
});

// src/xpath/lib/src/schema/psvi.ts
var init_psvi = __esm({
  "src/xpath/lib/src/schema/psvi.ts"() {
  }
});

// src/xpath/lib/src/types/schema-aware-types.ts
var init_schema_aware_types = __esm({
  "src/xpath/lib/src/types/schema-aware-types.ts"() {
    init_psvi();
  }
});

// src/xpath/lib/src/types/index.ts
function getAtomicType(name) {
  return ATOMIC_TYPES[name];
}
function castAs(value, typeName) {
  const type = getAtomicType(typeName);
  if (!type) {
    throw new Error(`Unknown atomic type: ${typeName}`);
  }
  return type.cast(value);
}
var anyAtomicType, untypedAtomic, stringType, booleanType, decimalType, floatType, doubleType, durationType, dateTimeType, dateType, timeType, anyURIType, qnameType, gYearMonthType, gYearType, gMonthDayType, gDayType, gMonthType, hexBinaryType, base64BinaryType, integerType, longType, intType, shortType, byteType, nonPositiveIntegerType, negativeIntegerType, nonNegativeIntegerType, positiveIntegerType, unsignedLongType, unsignedIntType, unsignedShortType, unsignedByteType, ATOMIC_TYPES;
var init_types = __esm({
  "src/xpath/lib/src/types/index.ts"() {
    init_base();
    init_base();
    init_sequence_type();
    init_kind_tests();
    init_sequence_type_matcher();
    init_typed_collection_types();
    init_union_type();
    init_type_promotion();
    init_atomization();
    init_simple_types();
    init_numeric_types();
    init_datetime_types();
    init_datetime_types();
    init_gregorian_types();
    init_binary_types();
    init_uri_qname_types();
    init_integer_derived_types();
    init_function_type();
    init_schema_aware_types();
    init_simple_types();
    init_simple_types();
    init_simple_types();
    init_simple_types();
    init_numeric_types();
    init_numeric_types();
    init_numeric_types();
    init_numeric_types();
    init_datetime_types();
    init_datetime_types();
    init_datetime_types();
    init_datetime_types();
    init_gregorian_types();
    init_gregorian_types();
    init_gregorian_types();
    init_gregorian_types();
    init_gregorian_types();
    init_binary_types();
    init_binary_types();
    init_uri_qname_types();
    init_uri_qname_types();
    init_integer_derived_types();
    anyAtomicType = new AnyAtomicTypeImpl();
    untypedAtomic = new UntypedAtomicImpl(anyAtomicType);
    stringType = new StringTypeImpl(anyAtomicType);
    booleanType = new BooleanTypeImpl(anyAtomicType);
    decimalType = new DecimalTypeImpl(anyAtomicType);
    floatType = new FloatTypeImpl(anyAtomicType);
    doubleType = new DoubleTypeImpl(anyAtomicType);
    durationType = new DurationTypeImpl(anyAtomicType);
    dateTimeType = new DateTimeTypeImpl(anyAtomicType);
    dateType = new DateTypeImpl(dateTimeType, dateTimeType);
    timeType = new TimeTypeImpl(dateTimeType, dateTimeType);
    anyURIType = new AnyURITypeImpl(anyAtomicType);
    qnameType = new QNameTypeImpl(anyAtomicType);
    gYearMonthType = new GYearMonthTypeImpl(anyAtomicType);
    gYearType = new GYearTypeImpl(anyAtomicType);
    gMonthDayType = new GMonthDayTypeImpl(anyAtomicType);
    gDayType = new GDayTypeImpl(anyAtomicType);
    gMonthType = new GMonthTypeImpl(anyAtomicType);
    hexBinaryType = new HexBinaryTypeImpl(anyAtomicType);
    base64BinaryType = new Base64BinaryTypeImpl(anyAtomicType);
    integerType = new IntegerTypeImpl(decimalType, decimalType);
    longType = new IntegerDerivedTypeImpl(
      "long",
      integerType,
      decimalType,
      -9223372036854776e3,
      9223372036854776e3
    );
    intType = new IntegerDerivedTypeImpl("int", longType, decimalType, -2147483648, 2147483647);
    shortType = new IntegerDerivedTypeImpl("short", intType, decimalType, -32768, 32767);
    byteType = new IntegerDerivedTypeImpl("byte", shortType, decimalType, -128, 127);
    nonPositiveIntegerType = new IntegerDerivedTypeImpl(
      "nonPositiveInteger",
      integerType,
      decimalType,
      void 0,
      0
    );
    negativeIntegerType = new IntegerDerivedTypeImpl(
      "negativeInteger",
      nonPositiveIntegerType,
      decimalType,
      void 0,
      -1
    );
    nonNegativeIntegerType = new IntegerDerivedTypeImpl(
      "nonNegativeInteger",
      integerType,
      decimalType,
      0,
      void 0
    );
    positiveIntegerType = new IntegerDerivedTypeImpl(
      "positiveInteger",
      nonNegativeIntegerType,
      decimalType,
      1,
      void 0
    );
    unsignedLongType = new IntegerDerivedTypeImpl(
      "unsignedLong",
      nonNegativeIntegerType,
      decimalType,
      0,
      18446744073709552e3
    );
    unsignedIntType = new IntegerDerivedTypeImpl(
      "unsignedInt",
      unsignedLongType,
      decimalType,
      0,
      4294967295
    );
    unsignedShortType = new IntegerDerivedTypeImpl(
      "unsignedShort",
      unsignedIntType,
      decimalType,
      0,
      65535
    );
    unsignedByteType = new IntegerDerivedTypeImpl(
      "unsignedByte",
      unsignedShortType,
      decimalType,
      0,
      255
    );
    ATOMIC_TYPES = {
      anyAtomicType,
      untypedAtomic,
      string: stringType,
      boolean: booleanType,
      decimal: decimalType,
      float: floatType,
      double: doubleType,
      integer: integerType,
      duration: durationType,
      dateTime: dateTimeType,
      date: dateType,
      time: timeType,
      anyURI: anyURIType,
      QName: qnameType,
      // Gregorian types
      gYearMonth: gYearMonthType,
      gYear: gYearType,
      gMonthDay: gMonthDayType,
      gDay: gDayType,
      gMonth: gMonthType,
      // Binary types
      hexBinary: hexBinaryType,
      base64Binary: base64BinaryType,
      // Integer-derived types
      long: longType,
      int: intType,
      short: shortType,
      byte: byteType,
      nonPositiveInteger: nonPositiveIntegerType,
      negativeInteger: negativeIntegerType,
      nonNegativeInteger: nonNegativeIntegerType,
      positiveInteger: positiveIntegerType,
      unsignedLong: unsignedLongType,
      unsignedInt: unsignedIntType,
      unsignedShort: unsignedShortType,
      unsignedByte: unsignedByteType
    };
  }
});

// src/xpath/lib/src/expressions/instance-of-expression.ts
var XPathInstanceOfExpression;
var init_instance_of_expression = __esm({
  "src/xpath/lib/src/expressions/instance-of-expression.ts"() {
    init_types();
    init_expression();
    XPathInstanceOfExpression = class extends XPathExpression {
      constructor(expression, sequenceType) {
        super();
        this.expression = expression;
        this.sequenceType = sequenceType;
      }
      evaluate(context) {
        const value = this.expression.evaluate(context);
        return matchesSequenceType(value, this.sequenceType).matches;
      }
    };
  }
});

// src/xpath/lib/src/expressions/castable-expression.ts
var XPathCastableExpression;
var init_castable_expression = __esm({
  "src/xpath/lib/src/expressions/castable-expression.ts"() {
    init_types();
    init_sequence_type();
    init_expression();
    XPathCastableExpression = class extends XPathExpression {
      constructor(expression, sequenceType) {
        super();
        this.expression = expression;
        this.sequenceType = sequenceType;
      }
      evaluate(context) {
        const value = this.expression.evaluate(context);
        const sequence = Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];
        if (sequence.length > 1) {
          return false;
        }
        if (sequence.length === 0) {
          return this.sequenceType.getOccurrence() === "?" /* ZERO_OR_ONE */;
        }
        const item = sequence[0];
        const itemType = this.sequenceType.getItemType();
        if (itemType === "empty" || !itemType.atomicType) {
          return false;
        }
        try {
          castAs(item, itemType.atomicType.name);
          return true;
        } catch (e) {
          return false;
        }
      }
    };
  }
});

// src/xpath/lib/src/expressions/treat-expression.ts
var XPathTreatExpression;
var init_treat_expression = __esm({
  "src/xpath/lib/src/expressions/treat-expression.ts"() {
    init_expression();
    init_sequence_type_matcher();
    XPathTreatExpression = class extends XPathExpression {
      constructor(expression, sequenceType) {
        super();
        this.expression = expression;
        this.sequenceType = sequenceType;
      }
      evaluate(context) {
        var _a;
        const value = this.expression.evaluate(context);
        const result = matchesSequenceType(value, this.sequenceType);
        if (!result.matches) {
          const reason = (_a = result.reason) != null ? _a : `Value does not match ${this.sequenceType.toString()}`;
          throw new Error(`Treat expression type mismatch: ${reason}`);
        }
        return value;
      }
    };
  }
});

// src/xpath/lib/src/expressions/union-expression.ts
var XPathUnionExpression;
var init_union_expression = __esm({
  "src/xpath/lib/src/expressions/union-expression.ts"() {
    init_expression();
    XPathUnionExpression = class extends XPathExpression {
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      evaluate(context) {
        const leftResult = this.left.evaluate(context);
        const rightResult = this.right.evaluate(context);
        const leftNodes = Array.isArray(leftResult) ? leftResult : [];
        const rightNodes = Array.isArray(rightResult) ? rightResult : [];
        return this.unionNodes(leftNodes, rightNodes);
      }
      unionNodes(left, right) {
        const seen = /* @__PURE__ */ new Set();
        const result = [];
        for (const node of left) {
          if (!seen.has(node)) {
            seen.add(node);
            result.push(node);
          }
        }
        for (const node of right) {
          if (!seen.has(node)) {
            seen.add(node);
            result.push(node);
          }
        }
        return this.sortByDocumentOrder(result);
      }
      sortByDocumentOrder(nodes) {
        return nodes.sort((a, b) => {
          if (a === b) return 0;
          if (typeof a.compareDocumentPosition === "function") {
            const position = a.compareDocumentPosition(b);
            if (position & 4) return -1;
            if (position & 2) return 1;
          }
          return 0;
        });
      }
    };
  }
});

// src/xpath/lib/src/expressions/sequence-construction.ts
function createSequence(value) {
  let items;
  if (value === void 0 || value === null) {
    items = [];
  } else if (Array.isArray(value)) {
    items = value;
  } else {
    items = [value];
  }
  return {
    items,
    isEmpty: () => items.length === 0,
    first: () => items[0],
    last: () => items[items.length - 1],
    length: () => items.length
  };
}
function flattenSequence(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [value];
}
function concatenateSequences(...sequences) {
  const result = [];
  for (const seq of sequences) {
    if (Array.isArray(seq)) {
      result.push(...seq);
    } else if (seq !== void 0 && seq !== null) {
      result.push(seq);
    }
  }
  return result;
}
function isXPathNode(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  return typeof value.nodeType === "string" || typeof value.nodeName === "string" || typeof value.textContent === "string";
}
function getNodeId(node) {
  if (!isXPathNode(node)) {
    return String(node);
  }
  return `${node.nodeType}:${node.nodeName || node.localName || ""}:${node.__id || ""}`;
}
var CommaExpression, RangeExpression, EmptySequenceExpression, ParenthesizedExpression;
var init_sequence_construction = __esm({
  "src/xpath/lib/src/expressions/sequence-construction.ts"() {
    init_expression();
    CommaExpression = class extends XPathExpression {
      constructor(operands) {
        super();
        this.operands = operands;
        if (operands.length < 2) {
          throw new Error("CommaExpression requires at least 2 operands");
        }
      }
      evaluate(context) {
        const result = [];
        for (const operand of this.operands) {
          const value = operand.evaluate(context);
          if (Array.isArray(value)) {
            result.push(...value);
          } else if (value !== void 0 && value !== null) {
            result.push(value);
          }
        }
        return result.length > 0 ? result : [];
      }
      getOperands() {
        return this.operands;
      }
      toString() {
        return this.operands.map((op) => op.toString()).join(", ");
      }
    };
    RangeExpression = class extends XPathExpression {
      constructor(startExpr, endExpr) {
        super();
        this.startExpr = startExpr;
        this.endExpr = endExpr;
      }
      evaluate(context) {
        const startValue = this.startExpr.evaluate(context);
        const endValue = this.endExpr.evaluate(context);
        let start;
        let end;
        try {
          const startItem = Array.isArray(startValue) ? startValue[0] : startValue;
          const endItem = Array.isArray(endValue) ? endValue[0] : endValue;
          start = this.toInteger(startItem);
          end = this.toInteger(endItem);
        } catch (e) {
          throw new Error(`Range expression operands must be integers: ${String(e)}`);
        }
        if (start > end) {
          return [];
        }
        const result = [];
        for (let i = start; i <= end; i++) {
          result.push(i);
        }
        return result;
      }
      toInteger(value) {
        if (typeof value === "number") {
          return Math.trunc(value);
        }
        if (typeof value === "string") {
          const num = parseInt(value, 10);
          if (isNaN(num)) {
            throw new Error(`Cannot convert "${value}" to integer`);
          }
          return num;
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        throw new Error(`Cannot convert ${typeof value} to integer`);
      }
      toString() {
        return `${this.startExpr.toString()} to ${this.endExpr.toString()}`;
      }
    };
    EmptySequenceExpression = class extends XPathExpression {
      evaluate(context) {
        return [];
      }
      toString() {
        return "empty-sequence()";
      }
    };
    ParenthesizedExpression = class extends XPathExpression {
      constructor(operand) {
        super();
        this.operand = operand;
      }
      evaluate(context) {
        return this.operand.evaluate(context);
      }
      getOperand() {
        return this.operand;
      }
      toString() {
        return `(${this.operand.toString()})`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/predicate-expression.ts
var XPathPredicate;
var init_predicate_expression = __esm({
  "src/xpath/lib/src/expressions/predicate-expression.ts"() {
    init_expression();
    XPathPredicate = class extends XPathExpression {
      constructor(expression) {
        super();
        this.expression = expression;
      }
      evaluate(context) {
        return this.expression.evaluate(context);
      }
      test(context) {
        const result = this.evaluate(context);
        if (typeof result === "number") {
          return result === (context == null ? void 0 : context.position);
        }
        return this.toBoolean(result);
      }
      toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
    };
  }
});

// src/xpath/lib/src/expressions/value-comparison.ts
var ValueComparisonExpression;
var init_value_comparison = __esm({
  "src/xpath/lib/src/expressions/value-comparison.ts"() {
    init_expression();
    ValueComparisonExpression = class extends XPathExpression {
      constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        const leftAtom = this.atomize(leftValue);
        const rightAtom = this.atomize(rightValue);
        if (leftAtom === void 0 || rightAtom === void 0) {
          throw new Error("Value comparison requires non-empty sequences");
        }
        return this.compare(leftAtom, rightAtom, this.operator);
      }
      /**
       * Atomize a value - convert to single atomic value
       */
      atomize(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return void 0;
          }
          if (value.length === 1) {
            return value[0];
          }
          throw new Error("Value comparison requires single atomic values");
        }
        if (this.isNode(value)) {
          return this.getNodeStringValue(value);
        }
        return value;
      }
      /**
       * Compare two atomic values
       */
      compare(left, right, operator) {
        const [promotedLeft, promotedRight] = this.promoteTypes(left, right);
        switch (operator) {
          case "eq":
            return this.equal(promotedLeft, promotedRight);
          case "ne":
            return !this.equal(promotedLeft, promotedRight);
          case "lt":
            return this.lessThan(promotedLeft, promotedRight);
          case "le":
            return this.lessThan(promotedLeft, promotedRight) || this.equal(promotedLeft, promotedRight);
          case "gt":
            return this.greaterThan(promotedLeft, promotedRight);
          case "ge":
            return this.greaterThan(promotedLeft, promotedRight) || this.equal(promotedLeft, promotedRight);
          default:
            throw new Error(`Unknown comparison operator: ${operator}`);
        }
      }
      /**
       * Promote types to common type for comparison
       */
      promoteTypes(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return [left, right];
        }
        if (typeof left === "number") {
          return [left, this.toNumber(right)];
        }
        if (typeof right === "number") {
          return [this.toNumber(left), right];
        }
        if (typeof left === "string" && typeof right === "string") {
          return [left, right];
        }
        if (typeof left === "string") {
          return [left, this.valueToString(right)];
        }
        if (typeof right === "string") {
          return [this.valueToString(left), right];
        }
        if (typeof left === "boolean" || typeof right === "boolean") {
          return [this.toBoolean(left), this.toBoolean(right)];
        }
        return [left, right];
      }
      /**
       * Check equality of two values
       */
      equal(left, right) {
        if (typeof left !== typeof right) {
          return false;
        }
        if (typeof left === "number") {
          if (isNaN(left) && isNaN(right)) {
            return false;
          }
          return left === right;
        }
        return left === right;
      }
      /**
       * Check if left < right
       */
      lessThan(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return left < right;
        }
        if (typeof left === "string" && typeof right === "string") {
          return left < right;
        }
        throw new Error(`Cannot compare ${typeof left} with ${typeof right}`);
      }
      /**
       * Check if left > right
       */
      greaterThan(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return left > right;
        }
        if (typeof left === "string" && typeof right === "string") {
          return left > right;
        }
        throw new Error(`Cannot compare ${typeof left} with ${typeof right}`);
      }
      /**
       * Convert value to number
       */
      toNumber(value) {
        if (typeof value === "number") return value;
        if (typeof value === "boolean") return value ? 1 : 0;
        if (typeof value === "string") {
          const num = parseFloat(value);
          return isNaN(num) ? NaN : num;
        }
        return NaN;
      }
      /**
       * Convert value to string
       */
      valueToString(value) {
        if (typeof value === "string") return value;
        if (typeof value === "number") return String(value);
        if (typeof value === "boolean") return value ? "true" : "false";
        if (this.isNode(value)) return this.getNodeStringValue(value);
        return String(value);
      }
      /**
       * Convert value to boolean
       */
      toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
      /**
       * Check if value is a node
       */
      isNode(value) {
        return value && typeof value === "object" && ("nodeType" in value || "nodeName" in value);
      }
      /**
       * Get string value of a node
       */
      getNodeStringValue(node) {
        if (node.textContent !== void 0) return String(node.textContent);
        if (node.nodeValue !== void 0) return String(node.nodeValue);
        if (node.value !== void 0) return String(node.value);
        return "";
      }
      toString() {
        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/general-comparison.ts
var GeneralComparisonExpression;
var init_general_comparison = __esm({
  "src/xpath/lib/src/expressions/general-comparison.ts"() {
    init_expression();
    GeneralComparisonExpression = class extends XPathExpression {
      constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
      }
      evaluate(context) {
        let leftValue = this.left.evaluate(context);
        let rightValue = this.right.evaluate(context);
        const leftItems = this.flatten(leftValue);
        const rightItems = this.flatten(rightValue);
        if (leftItems.length === 0 || rightItems.length === 0) {
          return false;
        }
        for (const left of leftItems) {
          for (const right of rightItems) {
            if (this.compareValues(left, right, this.operator)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Flatten a value into an array
       */
      flatten(value) {
        if (value === void 0 || value === null) {
          return [];
        }
        if (Array.isArray(value)) {
          const result = [];
          for (const item of value) {
            if (item !== void 0 && item !== null) {
              result.push(item);
            }
          }
          return result;
        }
        return [value];
      }
      /**
       * Compare two values from the existential quantification
       */
      compareValues(left, right, operator) {
        const leftVal = this.getComparableValue(left);
        const rightVal = this.getComparableValue(right);
        const [promotedLeft, promotedRight] = this.promoteTypes(leftVal, rightVal);
        switch (operator) {
          case "=":
            return this.equal(promotedLeft, promotedRight);
          case "!=":
            return !this.equal(promotedLeft, promotedRight);
          case "<":
            return this.lessThan(promotedLeft, promotedRight);
          case "<=":
            return this.lessThan(promotedLeft, promotedRight) || this.equal(promotedLeft, promotedRight);
          case ">":
            return this.greaterThan(promotedLeft, promotedRight);
          case ">=":
            return this.greaterThan(promotedLeft, promotedRight) || this.equal(promotedLeft, promotedRight);
          default:
            throw new Error(`Unknown comparison operator: ${operator}`);
        }
      }
      /**
       * Get comparable value (extract from nodes if needed)
       */
      getComparableValue(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (this.isNode(value)) {
          return this.getNodeStringValue(value);
        }
        return value;
      }
      /**
       * Promote types to common type for comparison
       */
      promoteTypes(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return [left, right];
        }
        if (typeof left === "number") {
          return [left, this.toNumber(right)];
        }
        if (typeof right === "number") {
          return [this.toNumber(left), right];
        }
        if (typeof left === "string" && typeof right === "string") {
          return [left, right];
        }
        if (typeof left === "string") {
          return [left, this.valueToString(right)];
        }
        if (typeof right === "string") {
          return [this.valueToString(left), right];
        }
        if (typeof left === "boolean" || typeof right === "boolean") {
          return [this.toBoolean(left), this.toBoolean(right)];
        }
        return [left, right];
      }
      /**
       * Check equality of two values
       */
      equal(left, right) {
        if (typeof left !== typeof right) {
          return false;
        }
        if (typeof left === "number") {
          if (isNaN(left) && isNaN(right)) {
            return false;
          }
          return left === right;
        }
        return left === right;
      }
      /**
       * Check if left < right
       */
      lessThan(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return left < right;
        }
        if (typeof left === "string" && typeof right === "string") {
          return left < right;
        }
        throw new Error(`Cannot compare ${typeof left} with ${typeof right}`);
      }
      /**
       * Check if left > right
       */
      greaterThan(left, right) {
        if (typeof left === "number" && typeof right === "number") {
          return left > right;
        }
        if (typeof left === "string" && typeof right === "string") {
          return left > right;
        }
        throw new Error(`Cannot compare ${typeof left} with ${typeof right}`);
      }
      /**
       * Convert value to number
       */
      toNumber(value) {
        if (typeof value === "number") return value;
        if (typeof value === "boolean") return value ? 1 : 0;
        if (typeof value === "string") {
          const num = parseFloat(value);
          return isNaN(num) ? NaN : num;
        }
        return NaN;
      }
      /**
       * Convert value to string
       */
      valueToString(value) {
        if (typeof value === "string") return value;
        if (typeof value === "number") return String(value);
        if (typeof value === "boolean") return value ? "true" : "false";
        if (this.isNode(value)) return this.getNodeStringValue(value);
        return String(value);
      }
      /**
       * Convert value to boolean
       */
      toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
      /**
       * Check if value is a node
       */
      isNode(value) {
        return value && typeof value === "object" && ("nodeType" in value || "nodeName" in value);
      }
      /**
       * Get string value of a node
       */
      getNodeStringValue(node) {
        if (node.textContent !== void 0) return String(node.textContent);
        if (node.nodeValue !== void 0) return String(node.nodeValue);
        if (node.value !== void 0) return String(node.value);
        return "";
      }
      toString() {
        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/node-comparison.ts
var NodeComparisonExpression;
var init_node_comparison = __esm({
  "src/xpath/lib/src/expressions/node-comparison.ts"() {
    init_expression();
    NodeComparisonExpression = class extends XPathExpression {
      constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        const leftNode = this.extractNode(leftValue);
        const rightNode = this.extractNode(rightValue);
        if (!this.isNode(leftNode) || !this.isNode(rightNode)) {
          throw new Error("Node comparison requires node operands");
        }
        switch (this.operator) {
          case "is":
            return this.isIdentical(leftNode, rightNode);
          case "<<":
            return this.isDocumentOrderBefore(leftNode, rightNode);
          case ">>":
            return this.isDocumentOrderAfter(leftNode, rightNode);
          default:
            throw new Error(`Unknown node comparison operator: ${this.operator}`);
        }
      }
      /**
       * Extract single node from a value
       */
      extractNode(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (this.isNode(value)) {
          return value;
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return void 0;
          }
          if (value.length === 1) {
            return value[0];
          }
          return value[0];
        }
        return void 0;
      }
      /**
       * Check if two nodes are identical (same object)
       */
      isIdentical(left, right) {
        if (left.__id !== void 0 && right.__id !== void 0) {
          return left.__id === right.__id;
        }
        return left === right;
      }
      /**
       * Check if left node comes before right node in document order
       */
      isDocumentOrderBefore(left, right) {
        const leftPos = this.getDocumentPosition(left);
        const rightPos = this.getDocumentPosition(right);
        if (leftPos !== -1 && rightPos !== -1) {
          return leftPos < rightPos;
        }
        return this.compareDocumentOrder(left, right) < 0;
      }
      /**
       * Check if left node comes after right node in document order
       */
      isDocumentOrderAfter(left, right) {
        const leftPos = this.getDocumentPosition(left);
        const rightPos = this.getDocumentPosition(right);
        if (leftPos !== -1 && rightPos !== -1) {
          return leftPos > rightPos;
        }
        return this.compareDocumentOrder(left, right) > 0;
      }
      /**
       * Get document position if available (optional optimization)
       */
      getDocumentPosition(node) {
        if (node.__documentPosition !== void 0) {
          return node.__documentPosition;
        }
        return -1;
      }
      /**
       * Compare nodes by walking up to ancestors and comparing positions
       * Returns: -1 if left before right, 0 if same, 1 if left after right
       */
      compareDocumentOrder(left, right) {
        if (left === right) {
          return 0;
        }
        const leftAncestors = this.getAncestors(left);
        const rightAncestors = this.getAncestors(right);
        let i = 0;
        while (i < leftAncestors.length && i < rightAncestors.length && leftAncestors[i] === rightAncestors[i]) {
          i++;
        }
        if (i === leftAncestors.length) {
          return -1;
        }
        if (i === rightAncestors.length) {
          return 1;
        }
        const leftChild = leftAncestors[i];
        const rightChild = rightAncestors[i];
        const leftPosition = this.getChildPosition(leftChild);
        const rightPosition = this.getChildPosition(rightChild);
        if (leftPosition < rightPosition) {
          return -1;
        } else if (leftPosition > rightPosition) {
          return 1;
        }
        return 0;
      }
      /**
       * Get ancestors of a node (from root to node)
       */
      getAncestors(node) {
        const ancestors = [node];
        let current = node;
        while (current && current.parentNode) {
          current = current.parentNode;
          ancestors.unshift(current);
        }
        return ancestors;
      }
      /**
       * Get position of a node among its siblings
       */
      getChildPosition(node) {
        if (!node.parentNode) {
          return 0;
        }
        const parent = node.parentNode;
        const children = parent.childNodes || [];
        for (let i = 0; i < children.length; i++) {
          if (children[i] === node) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Check if value is a node
       */
      isNode(value) {
        return value && typeof value === "object" && ("nodeType" in value || "nodeName" in value);
      }
      toString() {
        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/json-to-xml-converter.ts
var JsonToXmlConverter;
var init_json_to_xml_converter = __esm({
  "src/xpath/lib/src/expressions/json-to-xml-converter.ts"() {
    init_constants();
    JsonToXmlConverter = class {
      constructor() {
        this.elementId = 0;
      }
      /**
       * Convert JSON string to XML document node
       * @param jsonText - JSON string to convert
       * @param options - Conversion options
       * @returns XML document node or null if input is null/empty
       */
      convert(jsonText, options) {
        if (jsonText === null || jsonText === void 0) {
          return null;
        }
        if (typeof jsonText !== "string") {
          jsonText = String(jsonText);
        }
        const trimmedText = jsonText.trim();
        if (trimmedText === "") {
          return null;
        }
        try {
          const jsonValue = JSON.parse(trimmedText);
          return this.createDocumentNode(jsonValue, options);
        } catch (error) {
          if ((options == null ? void 0 : options.fallback) && typeof options.fallback === "function") {
            try {
              const fallbackValue = options.fallback(trimmedText);
              return this.createDocumentNode(fallbackValue, options);
            } catch (fallbackError) {
              return null;
            }
          }
          if (!(options == null ? void 0 : options.liberal)) {
            return null;
          }
          return this.liberalParse(trimmedText, options);
        }
      }
      /**
       * Create a document node wrapping the JSON value
       */
      createDocumentNode(value, options) {
        this.elementId = 0;
        const rootElement = this.valueToElement(value, "root", options);
        const documentNode = {
          nodeType: NodeType.DOCUMENT_NODE,
          nodeName: "#document",
          localName: "#document",
          childNodes: [rootElement],
          documentElement: rootElement
        };
        rootElement.ownerDocument = documentNode;
        return documentNode;
      }
      /**
       * Convert a JSON value to an XML element
       */
      valueToElement(value, elementName, options, parent) {
        const element = {
          nodeType: NodeType.ELEMENT_NODE,
          nodeName: elementName,
          localName: elementName,
          childNodes: [],
          attributes: []
          // Don't set parentNode to avoid circular reference issues with testing/serialization
          // parentNode: parent,
        };
        if (value === null || value === void 0) {
          return element;
        }
        if (typeof value === "object" && !Array.isArray(value)) {
          const childNodes = [];
          const seenKeys = /* @__PURE__ */ new Set();
          for (const key in value) {
            if (Object.prototype.hasOwnProperty.call(value, key)) {
              if (seenKeys.has(key)) {
                if ((options == null ? void 0 : options.duplicates) === "reject") {
                  throw new Error(`Duplicate key: ${key}`);
                } else if ((options == null ? void 0 : options.duplicates) === "use-first") {
                  continue;
                }
              }
              seenKeys.add(key);
              const sanitizedKey = this.sanitizeElementName(key);
              const childElement = this.valueToElement(
                value[key],
                sanitizedKey,
                options,
                element
              );
              childNodes.push(childElement);
            }
          }
          element.childNodes = childNodes;
        } else if (Array.isArray(value)) {
          const childNodes = value.map((item, index) => {
            const itemElement = this.valueToElement(item, "item", options, element);
            return itemElement;
          });
          element.childNodes = childNodes;
        } else if (typeof value === "string") {
          const textNode = {
            nodeType: NodeType.TEXT_NODE,
            nodeName: "#text",
            localName: "#text",
            textContent: value
            // Don't set parentNode to avoid circular reference
            // parentNode: element,
          };
          element.childNodes = [textNode];
          element.textContent = value;
        } else if (typeof value === "number") {
          const textValue = String(value);
          const textNode = {
            nodeType: NodeType.TEXT_NODE,
            nodeName: "#text",
            localName: "#text",
            textContent: textValue
            // Don't set parentNode to avoid circular reference
            // parentNode: element,
          };
          element.childNodes = [textNode];
          element.textContent = textValue;
        } else if (typeof value === "boolean") {
          const textValue = value ? "true" : "false";
          const textNode = {
            nodeType: NodeType.TEXT_NODE,
            nodeName: "#text",
            localName: "#text",
            textContent: textValue
            // Don't set parentNode to avoid circular reference
            // parentNode: element,
          };
          element.childNodes = [textNode];
          element.textContent = textValue;
        }
        return element;
      }
      /**
       * Sanitize a JSON key to be a valid XML element name
       * XML names must start with letter/underscore and contain only valid characters
       */
      sanitizeElementName(name) {
        if (/^[a-zA-Z_][\w.-]*$/.test(name)) {
          return name;
        }
        let sanitized = name.replace(/[^a-zA-Z0-9_.-]/g, "_");
        if (!/^[a-zA-Z_]/.test(sanitized)) {
          sanitized = "_" + sanitized;
        }
        if (!sanitized || sanitized === "_") {
          sanitized = "item";
        }
        return sanitized;
      }
      /**
       * Liberal JSON parsing - attempts to parse loosely formatted JSON
       */
      liberalParse(jsonText, options) {
        try {
          let lenient = jsonText.replace(/,(\s*[}\]])/g, "$1");
          lenient = lenient.replace(/'/g, '"');
          const value = JSON.parse(lenient);
          return this.createDocumentNode(value, options);
        } catch (e) {
          return null;
        }
      }
    };
  }
});

// src/xpath/lib/src/functions/higher-order-functions.ts
function forEach(context, seq, action) {
  if (!isFunctionItem(action)) {
    throw new Error("fn:for-each: second argument must be a function");
  }
  const funcItem = action;
  if (seq === null || seq === void 0) {
    return [];
  }
  const items = Array.isArray(seq) ? seq : [seq];
  const results = [];
  for (const item of items) {
    const result = funcItem.implementation(item);
    if (Array.isArray(result)) {
      results.push(...result);
    } else if (result !== null && result !== void 0) {
      results.push(result);
    }
  }
  return results.length === 0 ? [] : results;
}
function filter(context, seq, predicate) {
  if (!isFunctionItem(predicate)) {
    throw new Error("fn:filter: second argument must be a function");
  }
  const funcItem = predicate;
  if (seq === null || seq === void 0) {
    return [];
  }
  const items = Array.isArray(seq) ? seq : [seq];
  const results = items.filter((item) => {
    const result = funcItem.implementation(item);
    return Boolean(result);
  });
  return results.length === 0 ? [] : results;
}
function foldLeft(context, seq, zero, f) {
  if (!isFunctionItem(f)) {
    throw new Error("fn:fold-left: third argument must be a function");
  }
  const funcItem = f;
  if (seq === null || seq === void 0) {
    return zero;
  }
  const items = Array.isArray(seq) ? seq : [seq];
  let accumulator = zero;
  for (const item of items) {
    accumulator = funcItem.implementation(accumulator, item);
  }
  return accumulator;
}
function foldRight(context, seq, zero, f) {
  if (!isFunctionItem(f)) {
    throw new Error("fn:fold-right: third argument must be a function");
  }
  const funcItem = f;
  if (seq === null || seq === void 0) {
    return zero;
  }
  const items = Array.isArray(seq) ? seq : [seq];
  let accumulator = zero;
  for (let i = items.length - 1; i >= 0; i--) {
    accumulator = funcItem.implementation(items[i], accumulator);
  }
  return accumulator;
}
function forEachPair(context, seq1, seq2, action) {
  if (!isFunctionItem(action)) {
    throw new Error("fn:for-each-pair: third argument must be a function");
  }
  const funcItem = action;
  if (seq1 === null || seq1 === void 0 || seq2 === null || seq2 === void 0) {
    return [];
  }
  const items1 = Array.isArray(seq1) ? seq1 : [seq1];
  const items2 = Array.isArray(seq2) ? seq2 : [seq2];
  const results = [];
  const minLength = Math.min(items1.length, items2.length);
  for (let i = 0; i < minLength; i++) {
    const result = funcItem.implementation(items1[i], items2[i]);
    if (Array.isArray(result)) {
      results.push(...result);
    } else if (result !== null && result !== void 0) {
      results.push(result);
    }
  }
  return results.length === 0 ? [] : results;
}
function apply(context, func, array) {
  if (!isFunctionItem(func)) {
    throw new Error("fn:apply: first argument must be a function");
  }
  const funcItem = func;
  if (array === null || array === void 0) {
    return funcItem.implementation();
  }
  const args = Array.isArray(array) ? array : [array];
  return funcItem.implementation(...args);
}
function functionName(context, func) {
  if (!isFunctionItem(func)) {
    throw new Error("fn:function-name: argument must be a function");
  }
  const funcItem = func;
  if (funcItem.name) {
    if (funcItem.namespace) {
      return `Q{${funcItem.namespace}}${funcItem.name}`;
    }
    return funcItem.name;
  }
  return null;
}
function functionArity(context, func) {
  if (!isFunctionItem(func)) {
    throw new Error("fn:function-arity: argument must be a function");
  }
  const funcItem = func;
  return funcItem.arity;
}
var init_higher_order_functions = __esm({
  "src/xpath/lib/src/functions/higher-order-functions.ts"() {
    init_function_type();
  }
});

// src/xpath/lib/src/functions/math-functions.ts
function pi(context) {
  return Math.PI;
}
function exp(context, arg) {
  const value = toNumber(arg);
  return Math.exp(value);
}
function exp10(context, arg) {
  const value = toNumber(arg);
  return Math.pow(10, value);
}
function log(context, arg) {
  const value = toNumber(arg);
  return Math.log(value);
}
function log10(context, arg) {
  const value = toNumber(arg);
  return Math.log10(value);
}
function pow(context, x, y) {
  const base = toNumber(x);
  const exponent = toNumber(y);
  return Math.pow(base, exponent);
}
function sqrt(context, arg) {
  const value = toNumber(arg);
  return Math.sqrt(value);
}
function sin(context, arg) {
  const value = toNumber(arg);
  return Math.sin(value);
}
function cos(context, arg) {
  const value = toNumber(arg);
  return Math.cos(value);
}
function tan(context, arg) {
  const value = toNumber(arg);
  return Math.tan(value);
}
function asin(context, arg) {
  const value = toNumber(arg);
  return Math.asin(value);
}
function acos(context, arg) {
  const value = toNumber(arg);
  return Math.acos(value);
}
function atan(context, arg) {
  const value = toNumber(arg);
  return Math.atan(value);
}
function atan2(context, y, x) {
  const yValue = toNumber(y);
  const xValue = toNumber(x);
  return Math.atan2(yValue, xValue);
}
function toNumber(value) {
  if (value === null || value === void 0) {
    return NaN;
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return NaN;
    }
    return toNumber(value[0]);
  }
  const num = Number(value);
  return num;
}
var init_math_functions = __esm({
  "src/xpath/lib/src/functions/math-functions.ts"() {
  }
});

// src/xpath/lib/src/functions/sequence-functions.ts
function head(arg) {
  if (arg === null || arg === void 0) return null;
  if (Array.isArray(arg)) {
    return arg.length > 0 ? arg[0] : null;
  }
  return arg;
}
function tail(arg) {
  if (arg === null || arg === void 0) return [];
  if (Array.isArray(arg)) {
    return arg.length > 1 ? arg.slice(1) : [];
  }
  return [];
}
function unordered(sourceSeq) {
  return toSequence2(sourceSeq);
}
function zeroOrOne(arg) {
  const seq = toSequence2(arg);
  if (seq.length > 1) {
    throw typeMismatch("zero or one item", `sequence of ${seq.length} items`, "fn:zero-or-one");
  }
  return seq.length === 0 ? null : seq[0];
}
function oneOrMore(arg) {
  const seq = toSequence2(arg);
  if (seq.length === 0) {
    throw typeMismatch("one or more items", "empty sequence", "fn:one-or-more");
  }
  return seq;
}
function exactlyOne(arg) {
  const seq = toSequence2(arg);
  if (seq.length !== 1) {
    throw typeMismatch(
      "exactly one item",
      seq.length === 0 ? "empty sequence" : `sequence of ${seq.length} items`,
      "fn:exactly-one"
    );
  }
  return seq[0];
}
function toSequence2(value) {
  if (value === null || value === void 0) return [];
  if (Array.isArray(value)) return value;
  return [value];
}
var init_sequence_functions = __esm({
  "src/xpath/lib/src/functions/sequence-functions.ts"() {
    init_errors();
  }
});

// src/xpath/lib/src/functions/sequence-functions-30.ts
function innermost(context, nodes) {
  const nodeList = Array.isArray(nodes) ? nodes : nodes ? [nodes] : [];
  if (nodeList.length === 0) {
    return [];
  }
  return nodeList.filter((node) => {
    if (!isNode2(node)) {
      return false;
    }
    return !nodeList.some((otherNode) => {
      if (!isNode2(otherNode) || node === otherNode) {
        return false;
      }
      return isAncestor(node, otherNode);
    });
  });
}
function outermost(context, nodes) {
  const nodeList = Array.isArray(nodes) ? nodes : nodes ? [nodes] : [];
  if (nodeList.length === 0) {
    return [];
  }
  return nodeList.filter((node) => {
    if (!isNode2(node)) {
      return false;
    }
    return !nodeList.some((otherNode) => {
      if (!isNode2(otherNode) || node === otherNode) {
        return false;
      }
      return isAncestor(otherNode, node);
    });
  });
}
function sort(context, input, collation, keyFn) {
  const items = Array.isArray(input) ? input : input ? [input] : [];
  if (items.length <= 1) {
    return input;
  }
  const indexed = items.map((item, index) => ({ item, index }));
  if (keyFn && typeof keyFn === "object" && keyFn.__isFunctionItem) {
    indexed.sort((a, b) => {
      const keyA = keyFn.implementation(a.item);
      const keyB = keyFn.implementation(b.item);
      return compareValues(keyA, keyB);
    });
  } else {
    indexed.sort((a, b) => {
      return compareValues(a.item, b.item);
    });
  }
  return indexed.map((x) => x.item);
}
function isNode2(value) {
  return value !== null && value !== void 0 && typeof value === "object" && ("nodeType" in value || "localName" in value);
}
function isAncestor(potential, node) {
  if (!isNode2(potential) || !isNode2(node)) {
    return false;
  }
  let current = node.parent || node.parentNode;
  let depth = 0;
  const MAX_DEPTH = 1e4;
  const visited = /* @__PURE__ */ new Set();
  while (current && depth < MAX_DEPTH) {
    if (visited.has(current)) {
      break;
    }
    visited.add(current);
    if (current === potential) {
      return true;
    }
    current = current.parent || current.parentNode;
    depth++;
  }
  return false;
}
function compareValues(a, b) {
  if (Array.isArray(a) && a.length > 0) {
    a = a[0];
  }
  if (Array.isArray(b) && b.length > 0) {
    b = b[0];
  }
  if (a == null && b == null) return 0;
  if (a == null) return -1;
  if (b == null) return 1;
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  const aStr = String(a);
  const bStr = String(b);
  return aStr.localeCompare(bStr);
}
var init_sequence_functions_30 = __esm({
  "src/xpath/lib/src/functions/sequence-functions-30.ts"() {
    init_sequence_functions();
  }
});

// src/xpath/lib/src/functions/environment-functions.ts
function environmentVariable(context, name) {
  const varName = String(name);
  if (typeof process !== "undefined" && process.env) {
    const value = process.env[varName];
    return value !== void 0 ? value : null;
  }
  return null;
}
function availableEnvironmentVariables(context) {
  if (typeof process !== "undefined" && process.env) {
    return Object.keys(process.env);
  }
  return [];
}
var init_environment_functions = __esm({
  "src/xpath/lib/src/functions/environment-functions.ts"() {
  }
});

// src/xpath/lib/src/functions/string-functions-30.ts
function analyzeString(context, input, pattern, flags) {
  const str = input === null || input === void 0 ? "" : String(input);
  const pat = String(pattern);
  const flgs = flags ? String(flags) : "";
  try {
    let regexFlags = "";
    if (flgs.includes("i")) regexFlags += "i";
    if (flgs.includes("m")) regexFlags += "m";
    if (flgs.includes("s")) regexFlags += "s";
    if (flgs.includes("x")) regexFlags += "x";
    const regex = new RegExp(pat, regexFlags + "g");
    const result = [];
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(str)) !== null) {
      if (match.index > lastIndex) {
        result.push({
          type: "non-match",
          value: str.substring(lastIndex, match.index)
        });
      }
      result.push({
        type: "match",
        value: match[0],
        groups: match.slice(1).map((g) => g || "")
      });
      lastIndex = regex.lastIndex;
    }
    if (lastIndex < str.length) {
      result.push({
        type: "non-match",
        value: str.substring(lastIndex)
      });
    }
    if (result.length === 0) {
      result.push({
        type: "non-match",
        value: str
      });
    }
    return result;
  } catch (e) {
    throw new Error(`Invalid regular expression: ${pat}`);
  }
}
function formatInteger(context, value, picture, lang2) {
  if (value === null || value === void 0) {
    return "";
  }
  const num = Array.isArray(value) ? value.length > 0 ? Number(value[0]) : 0 : Number(value);
  const pic = String(picture);
  const intValue = Math.floor(num);
  const isNegative = intValue < 0;
  const absValue = Math.abs(intValue);
  if (pic === "1") {
    return String(intValue);
  } else if (pic === "01") {
    return String(Math.abs(intValue)).padStart(2, "0");
  } else if (pic === "a") {
    return toLetters(absValue, "a");
  } else if (pic === "A") {
    return toLetters(absValue, "A");
  } else if (pic === "i") {
    return toRoman(absValue).toLowerCase();
  } else if (pic === "I") {
    return toRoman(absValue);
  } else if (pic === "w") {
    return toWords(absValue);
  } else if (pic === "W") {
    return toWords(absValue).replace(/^\w/, (c) => c.toUpperCase());
  }
  const paddingMatch = pic.match(/^(0+)$/);
  if (paddingMatch) {
    const padLength = paddingMatch[1].length;
    return String(absValue).padStart(padLength, "0");
  }
  return String(intValue);
}
function formatNumber(context, value, picture, formatName) {
  if (value === null || value === void 0) {
    return "NaN";
  }
  const num = Array.isArray(value) ? value.length > 0 ? Number(value[0]) : NaN : Number(value);
  if (isNaN(num)) {
    return "NaN";
  }
  if (!isFinite(num)) {
    return num > 0 ? "Infinity" : "-Infinity";
  }
  const pic = String(picture);
  const parts = pic.split(".");
  const integerPart = parts[0] || "0";
  const decimalPart = parts[1] || "";
  const minIntDigits = (integerPart.match(/0/g) || []).length;
  const minDecDigits = (decimalPart.match(/0/g) || []).length;
  const maxDecDigits = decimalPart.length;
  let result;
  if (minDecDigits > 0 || maxDecDigits > 0) {
    const decimals = Math.max(minDecDigits, Math.min(maxDecDigits, 6));
    result = num.toFixed(decimals);
  } else {
    result = String(Math.round(num));
  }
  const [intPart, decPart] = result.split(".");
  const paddedInt = intPart.padStart(minIntDigits, "0");
  return decPart !== void 0 ? `${paddedInt}.${decPart}` : paddedInt;
}
function toLetters(num, baseChar) {
  if (num <= 0) return "";
  const base = baseChar.charCodeAt(0);
  let result = "";
  let n = num;
  while (n > 0) {
    n--;
    result = String.fromCharCode(base + n % 26) + result;
    n = Math.floor(n / 26);
  }
  return result;
}
function toRoman(num) {
  if (num <= 0 || num >= 4e3) return String(num);
  const romanMap = [
    { value: 1e3, numeral: "M" },
    { value: 900, numeral: "CM" },
    { value: 500, numeral: "D" },
    { value: 400, numeral: "CD" },
    { value: 100, numeral: "C" },
    { value: 90, numeral: "XC" },
    { value: 50, numeral: "L" },
    { value: 40, numeral: "XL" },
    { value: 10, numeral: "X" },
    { value: 9, numeral: "IX" },
    { value: 5, numeral: "V" },
    { value: 4, numeral: "IV" },
    { value: 1, numeral: "I" }
  ];
  let result = "";
  let n = num;
  for (const { value, numeral } of romanMap) {
    while (n >= value) {
      result += numeral;
      n -= value;
    }
  }
  return result;
}
function toWords(num) {
  if (num === 0) return "zero";
  if (num < 0) return "negative " + toWords(-num);
  const ones = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  const teens = [
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen"
  ];
  const tens = [
    "",
    "",
    "twenty",
    "thirty",
    "forty",
    "fifty",
    "sixty",
    "seventy",
    "eighty",
    "ninety"
  ];
  const scales = ["", "thousand", "million", "billion", "trillion"];
  let result = "";
  let scaleIndex = 0;
  while (num > 0) {
    const chunk = num % 1e3;
    if (chunk !== 0) {
      result = convertHundreds(chunk, ones, teens, tens) + (scales[scaleIndex] ? " " + scales[scaleIndex] : "") + (result ? " " : "") + result;
    }
    num = Math.floor(num / 1e3);
    scaleIndex++;
  }
  return result.trim();
}
function convertHundreds(num, ones, teens, tens) {
  let result = "";
  const hundreds = Math.floor(num / 100);
  if (hundreds > 0) {
    result += ones[hundreds] + " hundred";
  }
  const remainder = num % 100;
  if (remainder >= 20) {
    if (result) result += " ";
    const tenDigit = Math.floor(remainder / 10);
    const oneDigit = remainder % 10;
    result += tens[tenDigit];
    if (oneDigit > 0) {
      result += " " + ones[oneDigit];
    }
  } else if (remainder >= 10) {
    if (result) result += " ";
    result += teens[remainder - 10];
  } else if (remainder > 0) {
    if (result) result += " ";
    result += ones[remainder];
  }
  return result;
}
var init_string_functions_30 = __esm({
  "src/xpath/lib/src/functions/string-functions-30.ts"() {
  }
});

// src/xpath/lib/src/functions/array-functions.ts
function requireArray(value, funcName) {
  if (Array.isArray(value) && !isXPathArray(value)) {
    if (value.length === 1) {
      value = value[0];
    } else if (value.length === 0) {
      throw new Error(`XPTY0004: ${funcName} requires an array, got empty sequence`);
    } else {
      throw new Error(
        `XPTY0004: ${funcName} requires a single array, got sequence of ${value.length} items`
      );
    }
  }
  if (!isXPathArray(value)) {
    throw new Error(`XPTY0004: ${funcName} requires an array, got ${typeof value}`);
  }
  return value;
}
function validatePosition(arr, position, funcName) {
  if (!Number.isInteger(position)) {
    throw new Error(`XPTY0004: ${funcName} position must be an integer, got ${position}`);
  }
  if (position < 1 || position > arr.members.length) {
    throw new Error(
      `FOAY0001: ${funcName} position ${position} is out of bounds (array size: ${arr.members.length})`
    );
  }
}
function arraySize(context, array) {
  const arr = requireArray(array, "array:size");
  return arr.members.length;
}
function arrayGet(context, array, position) {
  const arr = requireArray(array, "array:get");
  validatePosition(arr, position, "array:get");
  return arr.members[position - 1];
}
function arrayPut(context, array, position, member) {
  const arr = requireArray(array, "array:put");
  validatePosition(arr, position, "array:put");
  const newMembers = [...arr.members];
  newMembers[position - 1] = member;
  return createXPathArray(newMembers);
}
function arrayAppend(context, array, appendage) {
  const arr = requireArray(array, "array:append");
  return createXPathArray([...arr.members, appendage]);
}
function arraySubarray(context, array, start, length) {
  const arr = requireArray(array, "array:subarray");
  if (!Number.isInteger(start)) {
    throw new Error(`XPTY0004: array:subarray start must be an integer, got ${start}`);
  }
  if (start < 1) {
    throw new Error(`FOAY0001: array:subarray start ${start} must be >= 1`);
  }
  if (start > arr.members.length + 1) {
    throw new Error(
      `FOAY0001: array:subarray start ${start} is out of bounds (array size: ${arr.members.length})`
    );
  }
  const startIdx = start - 1;
  if (length === void 0) {
    return createXPathArray(arr.members.slice(startIdx));
  }
  if (!Number.isInteger(length)) {
    throw new Error(`XPTY0004: array:subarray length must be an integer, got ${length}`);
  }
  if (length < 0) {
    throw new Error(`FOAY0002: array:subarray length ${length} must be >= 0`);
  }
  if (startIdx + length > arr.members.length) {
    throw new Error(
      `FOAY0001: array:subarray range [${start}, ${start + length - 1}] exceeds array bounds`
    );
  }
  return createXPathArray(arr.members.slice(startIdx, startIdx + length));
}
function arrayRemove(context, array, positions) {
  const arr = requireArray(array, "array:remove");
  const posArray = Array.isArray(positions) ? positions : [positions];
  for (const pos of posArray) {
    if (!Number.isInteger(pos)) {
      throw new Error(`XPTY0004: array:remove position must be an integer, got ${pos}`);
    }
    if (pos < 1 || pos > arr.members.length) {
      throw new Error(
        `FOAY0001: array:remove position ${pos} is out of bounds (array size: ${arr.members.length})`
      );
    }
  }
  const indicesToRemove = new Set(posArray.map((p) => p - 1));
  const newMembers = arr.members.filter((_, idx) => !indicesToRemove.has(idx));
  return createXPathArray(newMembers);
}
function arrayInsertBefore(context, array, position, member) {
  const arr = requireArray(array, "array:insert-before");
  if (!Number.isInteger(position)) {
    throw new Error(
      `XPTY0004: array:insert-before position must be an integer, got ${position}`
    );
  }
  if (position < 1 || position > arr.members.length + 1) {
    throw new Error(
      `FOAY0001: array:insert-before position ${position} is out of bounds (valid range: 1 to ${arr.members.length + 1})`
    );
  }
  const newMembers = [...arr.members];
  newMembers.splice(position - 1, 0, member);
  return createXPathArray(newMembers);
}
function arrayHead(context, array) {
  const arr = requireArray(array, "array:head");
  if (arr.members.length === 0) {
    throw new Error(`FOAY0001: array:head called on empty array`);
  }
  return arr.members[0];
}
function arrayTail(context, array) {
  const arr = requireArray(array, "array:tail");
  if (arr.members.length === 0) {
    throw new Error(`FOAY0001: array:tail called on empty array`);
  }
  return createXPathArray(arr.members.slice(1));
}
function arrayReverse(context, array) {
  const arr = requireArray(array, "array:reverse");
  return createXPathArray([...arr.members].reverse());
}
function arrayJoin(context, arrays) {
  const arrList = Array.isArray(arrays) ? arrays : [arrays];
  const allMembers = [];
  for (const arr of arrList) {
    if (arr === null || arr === void 0) continue;
    const xpathArr = requireArray(arr, "array:join");
    allMembers.push(...xpathArr.members);
  }
  return createXPathArray(allMembers);
}
function arrayFlatten(context, input) {
  const result = [];
  const flatten = (item) => {
    if (isXPathArray(item)) {
      for (const member of item.members) {
        flatten(member);
      }
    } else if (Array.isArray(item)) {
      for (const elem of item) {
        flatten(elem);
      }
    } else {
      result.push(item);
    }
  };
  flatten(input);
  return result;
}
function arrayForEach(context, array, action) {
  const arr = requireArray(array, "array:for-each");
  if (!action || typeof action !== "function" && !action.__isFunctionItem) {
    throw new Error(`XPTY0004: array:for-each requires a function as second argument`);
  }
  const fn = action.__isFunctionItem ? action.implementation : action;
  const newMembers = arr.members.map((member, index) => {
    return fn(member);
  });
  return createXPathArray(newMembers);
}
function arrayFilter(context, array, predicate) {
  const arr = requireArray(array, "array:filter");
  if (!predicate || typeof predicate !== "function" && !predicate.__isFunctionItem) {
    throw new Error(`XPTY0004: array:filter requires a function as second argument`);
  }
  const fn = predicate.__isFunctionItem ? predicate.implementation : predicate;
  const filteredMembers = arr.members.filter((member) => {
    const result = fn(member);
    if (typeof result === "boolean") return result;
    if (typeof result === "number") return result !== 0 && !isNaN(result);
    if (typeof result === "string") return result.length > 0;
    if (Array.isArray(result)) return result.length > 0;
    return !!result;
  });
  return createXPathArray(filteredMembers);
}
function arrayFoldLeft(context, array, zero, f) {
  const arr = requireArray(array, "array:fold-left");
  if (!f || typeof f !== "function" && !f.__isFunctionItem) {
    throw new Error(`XPTY0004: array:fold-left requires a function as third argument`);
  }
  const fn = f.__isFunctionItem ? f.implementation : f;
  let accumulator = zero;
  for (const member of arr.members) {
    accumulator = fn(accumulator, member);
  }
  return accumulator;
}
function arrayFoldRight(context, array, zero, f) {
  const arr = requireArray(array, "array:fold-right");
  if (!f || typeof f !== "function" && !f.__isFunctionItem) {
    throw new Error(`XPTY0004: array:fold-right requires a function as third argument`);
  }
  const fn = f.__isFunctionItem ? f.implementation : f;
  let accumulator = zero;
  for (let i = arr.members.length - 1; i >= 0; i--) {
    accumulator = fn(arr.members[i], accumulator);
  }
  return accumulator;
}
function arraySort(context, array, collation, key) {
  const arr = requireArray(array, "array:sort");
  const keyFn = key && (key.__isFunctionItem ? key.implementation : key);
  const indexedMembers = arr.members.map((member, idx) => ({ member, idx }));
  indexedMembers.sort((a, b) => {
    let aKey = keyFn ? keyFn(a.member) : a.member;
    let bKey = keyFn ? keyFn(b.member) : b.member;
    if (Array.isArray(aKey)) aKey = aKey[0];
    if (Array.isArray(bKey)) bKey = bKey[0];
    if (typeof aKey === "number" && typeof bKey === "number") {
      return aKey - bKey;
    }
    const aStr = String(aKey != null ? aKey : "");
    const bStr = String(bKey != null ? bKey : "");
    const result = aStr.localeCompare(bStr);
    return result !== 0 ? result : a.idx - b.idx;
  });
  return createXPathArray(indexedMembers.map((item) => item.member));
}
var init_array_functions = __esm({
  "src/xpath/lib/src/functions/array-functions.ts"() {
    init_array_constructor_expression();
  }
});

// src/xpath/lib/src/functions/map-functions.ts
function requireMap(value, funcName) {
  if (Array.isArray(value) && !isXPathMap(value)) {
    if (value.length === 1) {
      value = value[0];
    } else if (value.length === 0) {
      throw new Error(`XPTY0004: ${funcName} requires a map, got empty sequence`);
    } else {
      throw new Error(
        `XPTY0004: ${funcName} requires a single map, got sequence of ${value.length} items`
      );
    }
  }
  if (!isXPathMap(value)) {
    throw new Error(`XPTY0004: ${funcName} requires a map, got ${typeof value}`);
  }
  return value;
}
function cloneMap(map) {
  const newMap = /* @__PURE__ */ Object.create(null);
  newMap.__isMap = true;
  Object.assign(newMap, map);
  return newMap;
}
function mapSize(context, map) {
  const m = requireMap(map, "map:size");
  return Object.keys(m).filter((k) => !k.startsWith("__")).length;
}
function mapKeys(context, map) {
  const m = requireMap(map, "map:keys");
  return Object.keys(m).filter((k) => !k.startsWith("__"));
}
function mapContains(context, map, key) {
  const m = requireMap(map, "map:contains");
  const k = String(key);
  return Object.prototype.hasOwnProperty.call(m, k);
}
function mapGet(context, map, key) {
  const m = requireMap(map, "map:get");
  const k = String(key);
  if (Object.prototype.hasOwnProperty.call(m, k)) {
    return m[k];
  }
  return void 0;
}
function mapPut(context, map, key, value) {
  const m = requireMap(map, "map:put");
  const k = String(key);
  const newMap = cloneMap(m);
  newMap[k] = value;
  return newMap;
}
function mapEntry(context, key, value) {
  const k = String(key);
  const newMap = /* @__PURE__ */ Object.create(null);
  newMap.__isMap = true;
  newMap[k] = value;
  return newMap;
}
function mapMerge(context, maps, options) {
  const mapList = Array.isArray(maps) ? maps : [maps];
  let duplicateHandling = "use-last";
  if (options && isXPathMap(options)) {
    if (options.duplicates !== void 0) {
      duplicateHandling = String(options.duplicates);
    }
  }
  const validOptions = ["use-first", "use-last", "combine", "reject"];
  if (!validOptions.includes(duplicateHandling)) {
    throw new Error(
      `XPST0003: Invalid duplicates option '${duplicateHandling}'. Must be one of: ${validOptions.join(", ")}`
    );
  }
  const result = /* @__PURE__ */ Object.create(null);
  result.__isMap = true;
  const keyOccurrences = {};
  for (const m of mapList) {
    const mm = requireMap(m, "map:merge");
    for (const k of Object.keys(mm)) {
      if (k.startsWith("__")) continue;
      if (!keyOccurrences[k]) {
        keyOccurrences[k] = 0;
      }
      keyOccurrences[k]++;
      if (duplicateHandling === "use-first") {
        if (!(k in result)) {
          result[k] = mm[k];
        }
      } else if (duplicateHandling === "use-last") {
        result[k] = mm[k];
      } else if (duplicateHandling === "combine") {
        if (k in result) {
          if (Array.isArray(result[k])) {
            result[k].push(mm[k]);
          } else {
            result[k] = [result[k], mm[k]];
          }
        } else {
          result[k] = mm[k];
        }
      } else if (duplicateHandling === "reject") {
        result[k] = mm[k];
      }
    }
  }
  if (duplicateHandling === "reject") {
    for (const k in keyOccurrences) {
      if (keyOccurrences[k] > 1) {
        throw new Error(
          `XUST0003: Duplicate key '${k}' found in map:merge with duplicates='reject'`
        );
      }
    }
  }
  return result;
}
function mapForEach(context, map, fn) {
  const m = requireMap(map, "map:for-each");
  if (!fn || typeof fn !== "function" && !fn.__isFunctionItem) {
    throw new Error(`XPTY0004: map:for-each requires a function as second argument`);
  }
  const impl = fn.__isFunctionItem ? fn.implementation : fn;
  const result = /* @__PURE__ */ Object.create(null);
  result.__isMap = true;
  for (const k of Object.keys(m)) {
    if (k.startsWith("__")) continue;
    const v = m[k];
    result[k] = impl(k, v);
  }
  return result;
}
function mapRemove(context, map, keys) {
  const m = requireMap(map, "map:remove");
  const keyList = Array.isArray(keys) ? keys : [keys];
  const toRemove = new Set(keyList.map((k) => String(k)));
  const result = cloneMap(m);
  for (const k of Array.from(toRemove)) {
    if (Object.prototype.hasOwnProperty.call(result, k)) {
      delete result[k];
    }
  }
  return result;
}
var init_map_functions = __esm({
  "src/xpath/lib/src/functions/map-functions.ts"() {
    init_map_constructor_expression();
  }
});

// src/xpath/lib/src/functions/json-functions.ts
function jsToXPath(value) {
  if (value === null) return null;
  if (Array.isArray(value)) return createXPathArray(value.map(jsToXPath));
  if (typeof value === "object") {
    const map = /* @__PURE__ */ Object.create(null);
    map.__isMap = true;
    for (const [k, v] of Object.entries(value)) {
      map[k] = jsToXPath(v);
    }
    return map;
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean")
    return value;
  throw new XPathError("FOJS0001", "Unsupported JSON value type");
}
function processLiberalJson(json) {
  let result = "";
  let i = 0;
  let inString = false;
  let stringChar = "";
  let escaped = false;
  while (i < json.length) {
    const char = json[i];
    const nextChar = i + 1 < json.length ? json[i + 1] : "";
    if (inString) {
      if (escaped) {
        result += char;
        escaped = false;
        i++;
        continue;
      }
      if (char === "\\") {
        result += char;
        escaped = true;
        i++;
        continue;
      }
      if (char === stringChar) {
        result += '"';
        inString = false;
        i++;
        continue;
      }
      if (stringChar === "'" && char === '"') {
        result += '\\"';
      } else {
        result += char;
      }
      i++;
      continue;
    }
    if (char === '"' || char === "'") {
      inString = true;
      stringChar = char;
      result += '"';
      i++;
      continue;
    }
    if (char === "/" && nextChar === "/") {
      i += 2;
      while (i < json.length && json[i] !== "\n" && json[i] !== "\r") {
        i++;
      }
      continue;
    }
    if (char === "/" && nextChar === "*") {
      i += 2;
      while (i < json.length - 1) {
        if (json[i] === "*" && json[i + 1] === "/") {
          i += 2;
          break;
        }
        i++;
      }
      continue;
    }
    if (char === ",") {
      let j = i + 1;
      while (j < json.length && /[\s\n\r\t]/.test(json[j])) {
        j++;
      }
      while (j < json.length) {
        if (json[j] === "/" && j + 1 < json.length && json[j + 1] === "/") {
          j += 2;
          while (j < json.length && json[j] !== "\n" && json[j] !== "\r") {
            j++;
          }
          while (j < json.length && /[\s\n\r\t]/.test(json[j])) {
            j++;
          }
        } else if (json[j] === "/" && j + 1 < json.length && json[j + 1] === "*") {
          j += 2;
          while (j < json.length - 1) {
            if (json[j] === "*" && json[j + 1] === "/") {
              j += 2;
              break;
            }
            j++;
          }
          while (j < json.length && /[\s\n\r\t]/.test(json[j])) {
            j++;
          }
        } else {
          break;
        }
      }
      if (j < json.length && (json[j] === "}" || json[j] === "]")) {
        i++;
        while (i < j) {
          if (/[\s\n\r\t]/.test(json[i])) {
            result += json[i];
          }
          i++;
        }
        continue;
      }
    }
    result += char;
    i++;
  }
  return result;
}
function parseJsonImpl(jsonString, options) {
  if (typeof jsonString !== "string")
    throw new XPathError("XPTY0004", "parse-json: first argument must be a string");
  let opts = { liberal: false, duplicates: "use-last" };
  if (options && isXPathMap(options)) {
    const lib = options["liberal"];
    if (lib === true) opts.liberal = true;
    const dups = options["duplicates"];
    if (typeof dups === "string") opts.duplicates = dups;
  }
  try {
    if (opts.duplicates !== "use-last")
      throw new XPathError("FOJS0001", 'Only duplicates="use-last" is supported');
    const processedJson = opts.liberal ? processLiberalJson(jsonString) : jsonString;
    const parsed = JSON.parse(processedJson);
    return jsToXPath(parsed);
  } catch (e) {
    throw new XPathError("FOJS0001", "parse-json: " + (e && e.message ? e.message : String(e)));
  }
}
function parseJson(_contextOrJson, jsonStringOrOptions, options) {
  if (typeof _contextOrJson === "string") {
    return parseJsonImpl(_contextOrJson, jsonStringOrOptions);
  }
  return parseJsonImpl(jsonStringOrOptions, options);
}
function xpathToJs(value) {
  if (value === null || value === void 0) return null;
  if (isXPathArray(value)) {
    return value.members.map(xpathToJs);
  }
  if (isXPathMap(value)) {
    const obj = {};
    for (const [k, v] of Object.entries(value)) {
      if (!k.startsWith("__")) {
        obj[k] = xpathToJs(v);
      }
    }
    return obj;
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean")
    return value;
  if (Array.isArray(value)) {
    return value.map(xpathToJs);
  }
  throw new XPathError("FOJS0002", `Cannot serialize value of type ${typeof value}`);
}
function serializeImpl(value, options) {
  let opts = { indent: void 0, method: "json" };
  if (options && isXPathMap(options)) {
    const ind = options["indent"];
    if (typeof ind === "number") opts.indent = ind;
    const meth = options["method"];
    if (typeof meth === "string") opts.method = meth;
  }
  try {
    let toSerialize;
    if (Array.isArray(value)) {
      if (value.length === 0) {
        toSerialize = null;
      } else if (value.length === 1) {
        toSerialize = value[0];
      } else {
        toSerialize = value;
      }
    } else {
      toSerialize = value;
    }
    const jsValue = xpathToJs(toSerialize);
    const indent = opts.indent !== void 0 ? opts.indent : void 0;
    return JSON.stringify(jsValue, null, indent);
  } catch (e) {
    if (e instanceof XPathError) throw e;
    throw new XPathError("FOJS0002", "serialize: " + (e && e.message ? e.message : String(e)));
  }
}
function serialize(_contextOrValue, valueOrOptions, options) {
  if (options !== void 0) {
    return serializeImpl(valueOrOptions, options);
  }
  if (_contextOrValue && typeof _contextOrValue === "object" && !("__isMap" in _contextOrValue) && !("__isArray" in _contextOrValue) && valueOrOptions !== void 0) {
    return serializeImpl(valueOrOptions, options);
  }
  return serializeImpl(_contextOrValue, valueOrOptions);
}
function jsonToXmlImpl(jsonString, options) {
  if (jsonString === null || jsonString === void 0 || jsonString === "") {
    return null;
  }
  if (typeof jsonString !== "string") {
    throw new XPathError("XPTY0004", "json-to-xml: first argument must be a string or null");
  }
  let opts = { liberal: false, duplicates: "reject" };
  if (options && isXPathMap(options)) {
    const lib = options["liberal"];
    if (lib === true) opts.liberal = true;
    const dups = options["duplicates"];
    if (typeof dups === "string") opts.duplicates = dups;
  }
  try {
    const converter = new JsonToXmlConverter();
    return converter.convert(jsonString, opts);
  } catch (e) {
    throw new XPathError(
      "FOJS0001",
      "json-to-xml: " + (e && e.message ? e.message : String(e))
    );
  }
}
function jsonToXml(_contextOrJson, jsonStringOrOptions, options) {
  if (typeof _contextOrJson === "string" || _contextOrJson === null || _contextOrJson === void 0) {
    return jsonToXmlImpl(_contextOrJson, jsonStringOrOptions);
  }
  if (typeof _contextOrJson !== "object") {
    throw new XPathError("XPTY0004", "json-to-xml: first argument must be a string or null");
  }
  return jsonToXmlImpl(jsonStringOrOptions, options);
}
var init_json_functions = __esm({
  "src/xpath/lib/src/functions/json-functions.ts"() {
    init_map_constructor_expression();
    init_array_constructor_expression();
    init_errors();
    init_json_to_xml_converter();
    init_constants();
  }
});

// src/xpath/lib/src/functions/qname-functions.ts
function QName(paramURI, paramQName) {
  const uri = toString(paramURI);
  const qname = toString(paramQName);
  if (!qname) {
    throw new Error("FOCA0002: Invalid QName: empty string");
  }
  const colonIndex = qname.indexOf(":");
  if (colonIndex !== -1) {
    const prefix = qname.substring(0, colonIndex);
    const localName = qname.substring(colonIndex + 1);
    if (!isValidNCName(prefix) || !isValidNCName(localName)) {
      throw new Error(`FOCA0002: Invalid QName: ${qname}`);
    }
    if (!uri) {
      throw new Error(`FONS0004: No namespace for prefix: ${prefix}`);
    }
  } else {
    if (!isValidNCName(qname)) {
      throw new Error(`FOCA0002: Invalid QName: ${qname}`);
    }
  }
  return uri ? `{${uri}}${qname}` : qname;
}
function resolveQName(qname, element) {
  var _a, _b;
  const qnameStr = toString(qname);
  if (!qnameStr) return null;
  const elem = getElement(element);
  if (!elem) {
    throw new Error("FORG0001: Second argument to resolve-QName must be an element");
  }
  const colonIndex = qnameStr.indexOf(":");
  if (colonIndex === -1) {
    const defaultNS = (_b = (_a = elem.getAttribute) == null ? void 0 : _a.call(elem, "xmlns")) != null ? _b : "";
    return defaultNS ? `{${defaultNS}}${qnameStr}` : qnameStr;
  }
  const prefix = qnameStr.substring(0, colonIndex);
  const localName = qnameStr.substring(colonIndex + 1);
  const ns = getNamespaceForPrefix(elem, prefix);
  if (!ns) {
    throw new Error(`FONS0004: No namespace for prefix: ${prefix}`);
  }
  return `{${ns}}${qnameStr}`;
}
function prefixFromQName(arg) {
  const qname = toString(arg);
  if (!qname) return null;
  let effectiveQName = qname;
  if (qname.startsWith("{")) {
    const closeBrace = qname.indexOf("}");
    if (closeBrace !== -1) {
      effectiveQName = qname.substring(closeBrace + 1);
    }
  }
  const colonIndex = effectiveQName.indexOf(":");
  if (colonIndex === -1) return null;
  return effectiveQName.substring(0, colonIndex);
}
function localNameFromQName(arg) {
  const qname = toString(arg);
  if (!qname) return null;
  let effectiveQName = qname;
  if (qname.startsWith("{")) {
    const closeBrace = qname.indexOf("}");
    if (closeBrace !== -1) {
      effectiveQName = qname.substring(closeBrace + 1);
    }
  }
  const colonIndex = effectiveQName.indexOf(":");
  if (colonIndex === -1) {
    return effectiveQName;
  }
  return effectiveQName.substring(colonIndex + 1);
}
function namespaceUriFromQName(arg) {
  const qname = toString(arg);
  if (!qname) return null;
  if (qname.startsWith("{")) {
    const closeBrace = qname.indexOf("}");
    if (closeBrace !== -1) {
      return qname.substring(1, closeBrace);
    }
  }
  return null;
}
function inScopePrefixes(element) {
  const elem = getElement(element);
  if (!elem) {
    throw new Error("FORG0001: Argument to in-scope-prefixes must be an element");
  }
  const prefixes = /* @__PURE__ */ new Set();
  prefixes.add("xml");
  let current = elem;
  while (current) {
    if ("attributes" in current && current.attributes) {
      const attrs = current.attributes;
      if (typeof attrs.getNamedItem === "function") {
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs.item(i);
          if (attr) {
            const name = attr.name || attr.nodeName;
            if (name === "xmlns") {
              prefixes.add("");
            } else if (name.startsWith("xmlns:")) {
              prefixes.add(name.substring(6));
            }
          }
        }
      } else if (Array.isArray(attrs)) {
        for (const attr of attrs) {
          if (attr && typeof attr === "object") {
            const name = attr.name || attr.nodeName;
            if (name === "xmlns") {
              prefixes.add("");
            } else if (name && typeof name === "string" && name.startsWith("xmlns:")) {
              prefixes.add(name.substring(6));
            }
          }
        }
      } else {
        for (const name of Object.keys(attrs)) {
          if (name === "xmlns") {
            prefixes.add("");
          } else if (name.startsWith("xmlns:")) {
            prefixes.add(name.substring(6));
          }
        }
      }
    }
    current = current.parentNode;
  }
  return Array.from(prefixes);
}
function namespaceUriForPrefix(prefix, element) {
  const prefixStr = toString(prefix);
  const elem = getElement(element);
  if (!elem) {
    throw new Error("FORG0001: Second argument to namespace-uri-for-prefix must be an element");
  }
  if (prefixStr === "xml") {
    return "http://www.w3.org/XML/1998/namespace";
  }
  return getNamespaceForPrefix(elem, prefixStr);
}
function toString(value) {
  var _a;
  if (value === null || value === void 0) return "";
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    value = value[0];
  }
  if (typeof value === "object" && value !== null && "textContent" in value) {
    return (_a = value.textContent) != null ? _a : "";
  }
  return String(value);
}
function getElement(value) {
  if (value === null || value === void 0) return null;
  if (Array.isArray(value)) {
    if (value.length === 0) return null;
    value = value[0];
  }
  if (typeof value === "object" && value !== null && "nodeType" in value) {
    const node = value;
    if (node.nodeType === NodeType.ELEMENT_NODE) {
      return node;
    }
  }
  return null;
}
function isValidNCName(name) {
  if (!name) return false;
  const firstChar = name.charAt(0);
  if (/[0-9\-.]/.test(firstChar)) return false;
  if (name.includes(":")) return false;
  return /^[a-zA-Z_][\w.\-]*$/.test(name);
}
function getNamespaceForPrefix(elem, prefix) {
  var _a;
  let current = elem;
  while (current) {
    const attrName = prefix ? `xmlns:${prefix}` : "xmlns";
    const ns = (_a = current.getAttribute) == null ? void 0 : _a.call(current, attrName);
    if (ns !== null && ns !== void 0) {
      return ns;
    }
    current = current.parentNode;
  }
  return null;
}
var init_qname_functions = __esm({
  "src/xpath/lib/src/functions/qname-functions.ts"() {
    init_constants();
  }
});

// src/xpath/lib/src/functions/uri-functions.ts
function resolveUri(relative, base, context) {
  var _a;
  const rel = toString2(relative);
  if (rel === "") return null;
  const baseUri2 = base !== void 0 ? toString2(base) : (_a = context == null ? void 0 : context.baseUri) != null ? _a : "";
  try {
    if (baseUri2) {
      return new URL(rel, baseUri2).toString();
    }
    return new URL(rel).toString();
  } catch (e) {
    return null;
  }
}
function encodeForUri(uriPart) {
  const str = toString2(uriPart);
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (ch) => "%" + ch.charCodeAt(0).toString(16).toUpperCase()
  );
}
function iriToUri(iri) {
  const str = toString2(iri);
  return encodeURI(str);
}
function escapeHtmlUri(uri) {
  const str = toString2(uri);
  return encodeURI(str).replace(/\+/g, "%2B").replace(/'/g, "%27").replace(/"/g, "%22").replace(/</g, "%3C").replace(/>/g, "%3E");
}
function toString2(value) {
  if (value === null || value === void 0) return "";
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    value = value[0];
  }
  return String(value);
}
var init_uri_functions = __esm({
  "src/xpath/lib/src/functions/uri-functions.ts"() {
  }
});

// src/xpath/lib/src/functions/node-functions.ts
function nodeName(arg, context) {
  var _a;
  const node = getNode(arg, context);
  if (!node) return null;
  const nodeType = node.nodeType;
  if (nodeType !== 1 && // ELEMENT_NODE
  nodeType !== 2 && // ATTRIBUTE_NODE
  nodeType !== 7) {
    return null;
  }
  return (_a = node.nodeName) != null ? _a : null;
}
function nilled(arg, context) {
  var _a;
  const node = getNode(arg, context);
  if (!node) return null;
  if (node.nodeType !== 1) return null;
  const nilAttr = (_a = node.getAttribute) == null ? void 0 : _a.call(node, "xsi:nil");
  return nilAttr === "true" || nilAttr === "1";
}
function data(arg) {
  if (arg === null || arg === void 0) return [];
  const items = Array.isArray(arg) ? arg : [arg];
  const result = [];
  for (const item of items) {
    result.push(atomize2(item));
  }
  return result;
}
function baseUri(arg, context) {
  var _a, _b;
  const node = getNode(arg, context);
  if (!node) return null;
  if ("baseURI" in node && node.baseURI) {
    return node.baseURI;
  }
  const xmlBase = (_a = node.getAttribute) == null ? void 0 : _a.call(node, "xml:base");
  if (xmlBase) return xmlBase;
  if (node.parentNode && isNode3(node.parentNode)) {
    return baseUri([node.parentNode], context);
  }
  return (_b = context.baseUri) != null ? _b : null;
}
function documentUri(arg, context) {
  const node = getNode(arg, context);
  if (!node) return null;
  if (node.nodeType !== 9) return null;
  if ("documentURI" in node && node.documentURI) {
    return node.documentURI;
  }
  return null;
}
function root(arg, context) {
  const node = getNode(arg, context);
  if (!node) return null;
  let current = node;
  let depth = 0;
  const visited = /* @__PURE__ */ new Set();
  while (current.parentNode && depth < 1e4) {
    if (visited.has(current)) {
      return current;
    }
    visited.add(current);
    current = current.parentNode;
    depth++;
  }
  return current;
}
function lang(testlang, nodeArg, context) {
  var _a, _b;
  const targetLang = toString3(testlang).toLowerCase();
  if (!targetLang) return false;
  const node = nodeArg !== void 0 ? getNode(nodeArg, context) : context.node;
  if (!node) return false;
  let current = node;
  while (current) {
    const langAttr = ((_a = current.getAttribute) == null ? void 0 : _a.call(current, "xml:lang")) || ((_b = current.getAttribute) == null ? void 0 : _b.call(current, "lang"));
    if (langAttr) {
      const nodeLang = langAttr.toLowerCase();
      return nodeLang === targetLang || nodeLang.startsWith(targetLang + "-");
    }
    current = current.parentNode;
  }
  return false;
}
function generateId(arg, context) {
  const node = getNode(arg, context);
  if (!node) return "";
  const idSymbol = /* @__PURE__ */ Symbol.for("__xpath_node_id__");
  if (!node[idSymbol]) {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    const counter = Math.floor(Math.random() * 1e4).toString(36);
    node[idSymbol] = `n${timestamp}${random}${counter}`;
  }
  return node[idSymbol];
}
function path(arg, context) {
  const node = getNode(arg, context);
  if (!node) return "";
  const pathSegments = [];
  let current = node;
  let depth = 0;
  const visited = /* @__PURE__ */ new Set();
  while (current && depth < 1e4) {
    if (visited.has(current)) {
      break;
    }
    visited.add(current);
    const segment = buildPathSegment(current);
    if (segment) {
      pathSegments.unshift(segment);
    }
    current = current.parentNode;
    depth++;
  }
  return "/" + pathSegments.join("/");
}
function hasChildren(arg, context) {
  const node = getNode(arg, context);
  if (!node) return false;
  if ("childNodes" in node && Array.isArray(node.childNodes)) {
    return node.childNodes.length > 0;
  }
  return false;
}
function getNode(arg, context) {
  var _a;
  if (arg === null || arg === void 0) {
    return (_a = context.node) != null ? _a : null;
  }
  if (Array.isArray(arg)) {
    if (arg.length === 0) return null;
    arg = arg[0];
  }
  if (isNode3(arg)) {
    return arg;
  }
  return null;
}
function isNode3(value) {
  return typeof value === "object" && value !== null && "nodeType" in value;
}
function getStringValue(node) {
  if (node.textContent !== void 0) {
    return node.textContent;
  }
  if (node.nodeType === 1 || // ELEMENT_NODE
  node.nodeType === 9) {
    return getDescendantTextContent(node);
  }
  return String(node);
}
function getDescendantTextContent(node) {
  var _a;
  const parts = [];
  if ("childNodes" in node && Array.isArray(node.childNodes)) {
    for (const child of node.childNodes) {
      if (child.nodeType === 3) {
        parts.push((_a = child.textContent) != null ? _a : "");
      } else if (child.nodeType === 1) {
        parts.push(getDescendantTextContent(child));
      }
    }
  }
  return parts.join("");
}
function atomize2(value) {
  if (value === null || value === void 0) return "";
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return value;
  }
  if (isNode3(value)) {
    return getStringValue(value);
  }
  return String(value);
}
function toString3(value) {
  if (value === null || value === void 0) return "";
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    value = value[0];
  }
  if (isNode3(value)) {
    return getStringValue(value);
  }
  return String(value);
}
function buildPathSegment(node) {
  const nodeName2 = node.nodeName || "node()";
  const nodeType = node.nodeType;
  switch (nodeType) {
    case 1:
      const parent = node.parentNode;
      if (parent && "childNodes" in parent && Array.isArray(parent.childNodes)) {
        const siblings = parent.childNodes.filter(
          (n) => n.nodeType === 1 && n.nodeName === nodeName2
        );
        if (siblings.length > 1) {
          const position = siblings.indexOf(node) + 1;
          return `${nodeName2}[${position}]`;
        }
      }
      return nodeName2;
    case 2:
      return `@${nodeName2}`;
    case 3:
      return "text()";
    case 7:
      return `processing-instruction(${nodeName2})`;
    case 8:
      return "comment()";
    case 9:
      return "";
    default:
      return "node()";
  }
}
var init_node_functions = __esm({
  "src/xpath/lib/src/functions/node-functions.ts"() {
  }
});

// src/xpath/lib/src/expressions/function-call-expression.ts
var function_call_expression_exports = {};
__export(function_call_expression_exports, {
  XPathFunctionCall: () => XPathFunctionCall,
  getBuiltInFunction: () => getBuiltInFunction,
  getBuiltInFunctionArity: () => getBuiltInFunctionArity
});
function getBuiltInFunction(name) {
  return BUILT_IN_FUNCTIONS[name];
}
function getBuiltInFunctionArity(name) {
  return FUNCTION_ARITY[name];
}
var toStringValue, BUILT_IN_FUNCTIONS, FUNCTION_ARITY, XPathFunctionCall;
var init_function_call_expression = __esm({
  "src/xpath/lib/src/expressions/function-call-expression.ts"() {
    init_expression();
    init_json_to_xml_converter();
    init_types();
    init_errors();
    init_higher_order_functions();
    init_math_functions();
    init_sequence_functions_30();
    init_sequence_functions();
    init_environment_functions();
    init_string_functions_30();
    init_array_functions();
    init_map_functions();
    init_json_functions();
    init_qname_functions();
    init_uri_functions();
    init_node_functions();
    toStringValue = (arg) => {
      var _a;
      if (arg && typeof arg === "object") {
        if (typeof arg.stringValue === "function") {
          return arg.stringValue();
        }
        if (Array.isArray(arg)) {
          if (arg.length === 0) return "";
          const firstNode = arg[0];
          return (_a = firstNode == null ? void 0 : firstNode.textContent) != null ? _a : String(firstNode);
        }
        if (typeof arg.textContent === "string") {
          return arg.textContent;
        }
        if (arg.nodeValue !== void 0 && arg.nodeValue !== null) {
          return String(arg.nodeValue);
        }
      }
      return String(arg != null ? arg : "");
    };
    BUILT_IN_FUNCTIONS = {
      // String functions
      "upper-case": (_ctx, arg) => toStringValue(arg).toUpperCase(),
      "lower-case": (_ctx, arg) => toStringValue(arg).toLowerCase(),
      concat: (_ctx, ...args) => args.map((a) => String(a)).join(""),
      "string-join": (_ctx, seq, sep = "") => {
        if (Array.isArray(seq)) {
          return seq.map((s) => String(s)).join(String(sep));
        }
        return String(seq);
      },
      substring: (_ctx, str, start, len) => {
        const s = String(str);
        const startIdx = Math.round(Number(start)) - 1;
        if (len === void 0) {
          return s.substring(Math.max(0, startIdx));
        }
        const length = Math.round(Number(len));
        const adjustedStart = Math.max(0, startIdx);
        return s.substring(adjustedStart, adjustedStart + length);
      },
      "string-length": (_ctx, arg) => String(arg).length,
      "normalize-space": (_ctx, arg) => String(arg).trim().replace(/\s+/g, " "),
      contains: (_ctx, str, sub) => String(str).includes(String(sub)),
      "starts-with": (_ctx, str, sub) => String(str).startsWith(String(sub)),
      "ends-with": (_ctx, str, sub) => String(str).endsWith(String(sub)),
      translate: (_ctx, str, from, to) => {
        const s = String(str);
        const f = String(from);
        const t = String(to);
        let result = "";
        for (const char of s) {
          const idx = f.indexOf(char);
          if (idx === -1) result += char;
          else if (idx < t.length) result += t[idx];
        }
        return result;
      },
      replace: (_ctx, input, pattern, replacement) => {
        const regex = new RegExp(String(pattern), "g");
        return String(input).replace(regex, String(replacement));
      },
      matches: (_ctx, input, pattern) => {
        const regex = new RegExp(String(pattern));
        return regex.test(String(input));
      },
      tokenize: (_ctx, input, pattern = "\\s+") => {
        const regex = new RegExp(String(pattern));
        return String(input).split(regex).filter((s) => s.length > 0);
      },
      // Numeric functions
      abs: (_ctx, arg) => Math.abs(Number(arg)),
      ceiling: (_ctx, arg) => Math.ceil(Number(arg)),
      floor: (_ctx, arg) => Math.floor(Number(arg)),
      round: (_ctx, arg) => Math.round(Number(arg)),
      "round-half-to-even": (_ctx, arg, precision = 0) => {
        const p = Math.pow(10, Number(precision));
        const n = Number(arg) * p;
        const floor = Math.floor(n);
        const decimal = n - floor;
        if (decimal === 0.5) {
          return (floor % 2 === 0 ? floor : floor + 1) / p;
        }
        return Math.round(n) / p;
      },
      number: (_ctx, arg) => Number(arg),
      // Boolean functions
      true: () => true,
      false: () => false,
      not: (_ctx, arg) => !arg,
      boolean: (_ctx, arg) => {
        if (typeof arg === "boolean") return arg;
        if (typeof arg === "number") return arg !== 0 && !isNaN(arg);
        if (typeof arg === "string") return arg.length > 0;
        if (Array.isArray(arg)) return arg.length > 0;
        return !!arg;
      },
      // Sequence functions
      count: (_ctx, seq) => Array.isArray(seq) ? seq.length : seq === null || seq === void 0 ? 0 : 1,
      sum: (_ctx, seq) => {
        if (!Array.isArray(seq)) return Number(seq) || 0;
        return seq.reduce((acc, val) => acc + (Number(val) || 0), 0);
      },
      avg: (_ctx, seq) => {
        if (!Array.isArray(seq)) return Number(seq);
        if (seq.length === 0) return null;
        const sum = seq.reduce((acc, val) => acc + (Number(val) || 0), 0);
        return sum / seq.length;
      },
      min: (_ctx, seq) => {
        if (!Array.isArray(seq)) return Number(seq);
        if (seq.length === 0) return null;
        return Math.min(...seq.map((v) => Number(v)));
      },
      max: (_ctx, seq) => {
        if (!Array.isArray(seq)) return Number(seq);
        if (seq.length === 0) return null;
        return Math.max(...seq.map((v) => Number(v)));
      },
      empty: (_ctx, seq) => {
        if (seq === null || seq === void 0) return true;
        if (Array.isArray(seq)) return seq.length === 0;
        return false;
      },
      exists: (_ctx, seq) => {
        if (seq === null || seq === void 0) return false;
        if (Array.isArray(seq)) return seq.length > 0;
        return true;
      },
      reverse: (_ctx, seq) => {
        if (!Array.isArray(seq)) return [seq];
        return [...seq].reverse();
      },
      "distinct-values": (_ctx, seq) => {
        if (!Array.isArray(seq)) return [seq];
        return Array.from(new Set(seq));
      },
      subsequence: (_ctx, seq, start, length) => {
        if (!Array.isArray(seq)) seq = [seq];
        const startIdx = Math.round(Number(start)) - 1;
        if (length === void 0) {
          return seq.slice(Math.max(0, startIdx));
        }
        const len = Math.round(Number(length));
        return seq.slice(Math.max(0, startIdx), Math.max(0, startIdx) + len);
      },
      "insert-before": (_ctx, seq, pos, inserts) => {
        if (!Array.isArray(seq)) seq = seq === null ? [] : [seq];
        if (!Array.isArray(inserts)) inserts = [inserts];
        const position = Math.max(0, Math.round(Number(pos)) - 1);
        return [...seq.slice(0, position), ...inserts, ...seq.slice(position)];
      },
      remove: (_ctx, seq, pos) => {
        if (!Array.isArray(seq)) seq = [seq];
        const position = Math.round(Number(pos)) - 1;
        if (position < 0 || position >= seq.length) return seq;
        return [...seq.slice(0, position), ...seq.slice(position + 1)];
      },
      // Node functions
      position: (ctx) => {
        var _a;
        return (_a = ctx.position) != null ? _a : 0;
      },
      last: (ctx) => {
        var _a;
        return (_a = ctx.size) != null ? _a : 0;
      },
      string: (ctx, arg) => {
        var _a, _b, _c, _d;
        if (arg === void 0) {
          return (_b = (_a = ctx.node) == null ? void 0 : _a.textContent) != null ? _b : "";
        }
        if (Array.isArray(arg) && arg.length > 0) {
          return (_d = (_c = arg[0]) == null ? void 0 : _c.textContent) != null ? _d : String(arg[0]);
        }
        return String(arg);
      },
      "local-name": (ctx, arg) => {
        var _a;
        const node = arg ? Array.isArray(arg) ? arg[0] : arg : ctx.node;
        return (_a = node == null ? void 0 : node.localName) != null ? _a : "";
      },
      "namespace-uri": (ctx, arg) => {
        var _a;
        const node = arg ? Array.isArray(arg) ? arg[0] : arg : ctx.node;
        return (_a = node == null ? void 0 : node.namespaceUri) != null ? _a : "";
      },
      name: (ctx, arg) => {
        var _a;
        const node = arg ? Array.isArray(arg) ? arg[0] : arg : ctx.node;
        return (_a = node == null ? void 0 : node.nodeName) != null ? _a : "";
      },
      "generate-id": (ctx, arg) => generateId(arg, ctx),
      path: (ctx, arg) => path(arg, ctx),
      "has-children": (ctx, arg) => hasChildren(arg, ctx),
      // Higher-order functions (XPath 3.0)
      "for-each": forEach,
      filter,
      "fold-left": foldLeft,
      "fold-right": foldRight,
      "for-each-pair": forEachPair,
      sort,
      apply,
      "function-name": functionName,
      "function-arity": functionArity,
      // Math functions (XPath 3.0 math namespace)
      "math:pi": pi,
      "math:exp": exp,
      "math:exp10": exp10,
      "math:log": log,
      "math:log10": log10,
      "math:pow": pow,
      "math:sqrt": sqrt,
      "math:sin": sin,
      "math:cos": cos,
      "math:tan": tan,
      "math:asin": asin,
      "math:acos": acos,
      "math:atan": atan,
      "math:atan2": atan2,
      // Sequence functions (XPath 3.0)
      head: (_ctx, seq) => head(seq),
      tail: (_ctx, seq) => tail(seq),
      innermost,
      outermost,
      // Environment functions (XPath 3.0)
      "environment-variable": environmentVariable,
      "available-environment-variables": availableEnvironmentVariables,
      // Array functions (XPath 3.1)
      "array:size": arraySize,
      "array:get": arrayGet,
      "array:put": arrayPut,
      "array:append": arrayAppend,
      "array:subarray": arraySubarray,
      "array:remove": arrayRemove,
      "array:insert-before": arrayInsertBefore,
      "array:head": arrayHead,
      "array:tail": arrayTail,
      "array:reverse": arrayReverse,
      "array:join": arrayJoin,
      "array:flatten": arrayFlatten,
      "array:for-each": arrayForEach,
      "array:filter": arrayFilter,
      "array:fold-left": arrayFoldLeft,
      "array:fold-right": arrayFoldRight,
      "array:sort": arraySort,
      // Map functions (XPath 3.1)
      "map:size": mapSize,
      "map:keys": mapKeys,
      "map:contains": mapContains,
      "map:get": mapGet,
      "map:put": mapPut,
      "map:entry": mapEntry,
      "map:merge": mapMerge,
      "map:for-each": mapForEach,
      "map:remove": mapRemove,
      // JSON functions (XPath 3.1)
      // Note: xml-to-json is NOT registered here because XSLT provides its own version
      // with version checking (only allowed in XSLT 3.0). The XSLT version is registered
      // via context.functions in xpath.ts and takes precedence.
      "parse-json": parseJson,
      serialize,
      "json-to-xml": jsonToXml,
      // String functions (XPath 3.0 additions)
      "analyze-string": analyzeString,
      "format-integer": formatInteger,
      "format-number": formatNumber,
      // XPath 2.0 Type Constructor Functions (xs:* namespace)
      // These wrap the type system's castAs functionality for function references
      "xs:string": (_ctx, arg) => castAs(arg, "string"),
      "xs:boolean": (_ctx, arg) => castAs(arg, "boolean"),
      "xs:decimal": (_ctx, arg) => castAs(arg, "decimal"),
      "xs:float": (_ctx, arg) => castAs(arg, "float"),
      "xs:double": (_ctx, arg) => castAs(arg, "double"),
      "xs:integer": (_ctx, arg) => castAs(arg, "integer"),
      "xs:duration": (_ctx, arg) => castAs(arg, "duration"),
      "xs:dateTime": (_ctx, arg) => castAs(arg, "dateTime"),
      "xs:date": (_ctx, arg) => castAs(arg, "date"),
      "xs:time": (_ctx, arg) => castAs(arg, "time"),
      "xs:anyURI": (_ctx, arg) => castAs(arg, "anyURI"),
      "xs:QName": (_ctx, arg) => castAs(arg, "QName"),
      "xs:untypedAtomic": (_ctx, arg) => castAs(arg, "untypedAtomic"),
      // Gregorian types
      "xs:gYearMonth": (_ctx, arg) => castAs(arg, "gYearMonth"),
      "xs:gYear": (_ctx, arg) => castAs(arg, "gYear"),
      "xs:gMonthDay": (_ctx, arg) => castAs(arg, "gMonthDay"),
      "xs:gDay": (_ctx, arg) => castAs(arg, "gDay"),
      "xs:gMonth": (_ctx, arg) => castAs(arg, "gMonth"),
      // Binary types
      "xs:hexBinary": (_ctx, arg) => castAs(arg, "hexBinary"),
      "xs:base64Binary": (_ctx, arg) => castAs(arg, "base64Binary"),
      // Integer-derived types
      "xs:long": (_ctx, arg) => castAs(arg, "long"),
      "xs:int": (_ctx, arg) => castAs(arg, "int"),
      "xs:short": (_ctx, arg) => castAs(arg, "short"),
      "xs:byte": (_ctx, arg) => castAs(arg, "byte"),
      "xs:nonPositiveInteger": (_ctx, arg) => castAs(arg, "nonPositiveInteger"),
      "xs:negativeInteger": (_ctx, arg) => castAs(arg, "negativeInteger"),
      "xs:nonNegativeInteger": (_ctx, arg) => castAs(arg, "nonNegativeInteger"),
      "xs:positiveInteger": (_ctx, arg) => castAs(arg, "positiveInteger"),
      "xs:unsignedLong": (_ctx, arg) => castAs(arg, "unsignedLong"),
      "xs:unsignedInt": (_ctx, arg) => castAs(arg, "unsignedInt"),
      "xs:unsignedShort": (_ctx, arg) => castAs(arg, "unsignedShort"),
      "xs:unsignedByte": (_ctx, arg) => castAs(arg, "unsignedByte"),
      // XPath 2.0 QName Functions
      QName: (_ctx, uri, qname) => QName(uri, qname),
      "resolve-QName": (_ctx, qname, element) => resolveQName(qname, element),
      "prefix-from-QName": (_ctx, arg) => prefixFromQName(arg),
      "local-name-from-QName": (_ctx, arg) => localNameFromQName(arg),
      "namespace-uri-from-QName": (_ctx, arg) => namespaceUriFromQName(arg),
      "in-scope-prefixes": (_ctx, element) => inScopePrefixes(element),
      "namespace-uri-for-prefix": (_ctx, prefix, element) => namespaceUriForPrefix(prefix, element),
      // XPath 2.0 URI Functions
      "resolve-uri": (ctx, relative, base) => resolveUri(relative, base, ctx),
      "encode-for-uri": (_ctx, uriPart) => encodeForUri(uriPart),
      "iri-to-uri": (_ctx, iri) => iriToUri(iri),
      "escape-html-uri": (_ctx, uri) => escapeHtmlUri(uri),
      // XPath 2.0 Node Functions (enhanced)
      root: (ctx, arg) => root(arg, ctx),
      "base-uri": (ctx, arg) => baseUri(arg, ctx),
      "document-uri": (ctx, arg) => documentUri(arg, ctx),
      nilled: (ctx, arg) => nilled(arg, ctx),
      "node-name": (ctx, arg) => nodeName(arg, ctx),
      data: (_ctx, arg) => data(arg),
      lang: (ctx, testlang, node) => lang(testlang, node, ctx),
      // XPath 2.0 Cardinality Functions
      "zero-or-one": (_ctx, arg) => zeroOrOne(arg),
      "one-or-more": (_ctx, arg) => oneOrMore(arg),
      "exactly-one": (_ctx, arg) => exactlyOne(arg),
      unordered: (_ctx, arg) => unordered(arg)
    };
    FUNCTION_ARITY = {
      concat: [2, Infinity],
      substring: [2, 3],
      "string-join": [1, 2],
      "normalize-space": [0, 1],
      "string-length": [0, 1],
      "local-name": [0, 1],
      "namespace-uri": [0, 1],
      name: [0, 1],
      "generate-id": [0, 1],
      path: [0, 1],
      "has-children": [0, 1],
      round: [1, 2],
      "round-half-to-even": [1, 2],
      string: [0, 1],
      number: [0, 1],
      replace: [3, 4],
      matches: [2, 3],
      tokenize: [1, 3],
      // XSLT 2.0 regex functions
      "regex-group": [1, 1],
      // XSLT 2.0 grouping functions
      "current-group": [0, 0],
      "current-grouping-key": [0, 0],
      subsequence: [2, 3],
      "insert-before": [3, 3],
      remove: [2, 2],
      // Higher-order functions
      "for-each": [2, 2],
      filter: [2, 2],
      "fold-left": [3, 3],
      "fold-right": [3, 3],
      "for-each-pair": [3, 3],
      sort: [1, 3],
      apply: [2, 2],
      "function-name": [1, 1],
      "function-arity": [1, 1],
      // Math functions
      "math:pi": [0, 0],
      "math:exp": [1, 1],
      "math:exp10": [1, 1],
      "math:log": [1, 1],
      "math:log10": [1, 1],
      "math:pow": [2, 2],
      "math:sqrt": [1, 1],
      "math:sin": [1, 1],
      "math:cos": [1, 1],
      "math:tan": [1, 1],
      "math:asin": [1, 1],
      "math:acos": [1, 1],
      "math:atan": [1, 1],
      "math:atan2": [2, 2],
      // Sequence functions (XPath 3.0)
      head: [1, 1],
      tail: [1, 1],
      innermost: [1, 1],
      outermost: [1, 1],
      // Environment functions (XPath 3.0)
      "environment-variable": [1, 1],
      "available-environment-variables": [0, 0],
      // Array functions (XPath 3.1)
      "array:size": [1, 1],
      "array:get": [2, 2],
      "array:put": [3, 3],
      "array:append": [2, 2],
      "array:subarray": [2, 3],
      "array:remove": [2, 2],
      "array:insert-before": [3, 3],
      "array:head": [1, 1],
      "array:tail": [1, 1],
      "array:reverse": [1, 1],
      "array:join": [1, 1],
      "array:flatten": [1, 1],
      "array:for-each": [2, 2],
      "array:filter": [2, 2],
      "array:fold-left": [3, 3],
      "array:fold-right": [3, 3],
      "array:sort": [1, 3],
      // Map functions (XPath 3.1)
      "map:size": [1, 1],
      "map:keys": [1, 1],
      "map:contains": [2, 2],
      "map:get": [2, 2],
      "map:put": [3, 3],
      "map:entry": [2, 2],
      "map:merge": [1, 2],
      "map:for-each": [2, 2],
      "map:remove": [2, 2],
      // JSON functions (XPath 3.1)
      // Note: xml-to-json arity not registered here - handled by XSLT context.functions
      "parse-json": [1, 2],
      serialize: [1, 2],
      "json-to-xml": [1, 2],
      // String functions (XPath 3.0 additions)
      "analyze-string": [2, 3],
      "format-integer": [2, 3],
      "format-number": [2, 3],
      // XPath 2.0 Type Constructor Functions (xs:* namespace)
      "xs:string": [1, 1],
      "xs:boolean": [1, 1],
      "xs:decimal": [1, 1],
      "xs:float": [1, 1],
      "xs:double": [1, 1],
      "xs:integer": [1, 1],
      "xs:duration": [1, 1],
      "xs:dateTime": [1, 1],
      "xs:date": [1, 1],
      "xs:time": [1, 1],
      "xs:anyURI": [1, 1],
      "xs:QName": [1, 1],
      "xs:untypedAtomic": [1, 1],
      "xs:gYearMonth": [1, 1],
      "xs:gYear": [1, 1],
      "xs:gMonthDay": [1, 1],
      "xs:gDay": [1, 1],
      "xs:gMonth": [1, 1],
      "xs:hexBinary": [1, 1],
      "xs:base64Binary": [1, 1],
      "xs:long": [1, 1],
      "xs:int": [1, 1],
      "xs:short": [1, 1],
      "xs:byte": [1, 1],
      "xs:nonPositiveInteger": [1, 1],
      "xs:negativeInteger": [1, 1],
      "xs:nonNegativeInteger": [1, 1],
      "xs:positiveInteger": [1, 1],
      "xs:unsignedLong": [1, 1],
      "xs:unsignedInt": [1, 1],
      "xs:unsignedShort": [1, 1],
      "xs:unsignedByte": [1, 1],
      // XPath 2.0 QName Functions
      QName: [2, 2],
      "resolve-QName": [2, 2],
      "prefix-from-QName": [1, 1],
      "local-name-from-QName": [1, 1],
      "namespace-uri-from-QName": [1, 1],
      "in-scope-prefixes": [1, 1],
      "namespace-uri-for-prefix": [2, 2],
      // XPath 2.0 URI Functions
      "resolve-uri": [1, 2],
      "encode-for-uri": [1, 1],
      "iri-to-uri": [1, 1],
      "escape-html-uri": [1, 1],
      // XPath 2.0 Node Functions (enhanced)
      root: [0, 1],
      "base-uri": [0, 1],
      "document-uri": [1, 1],
      nilled: [1, 1],
      "node-name": [1, 1],
      data: [1, 1],
      lang: [1, 2],
      // XPath 2.0 Cardinality Functions
      "zero-or-one": [1, 1],
      "one-or-more": [1, 1],
      "exactly-one": [1, 1],
      unordered: [1, 1]
    };
    XPathFunctionCall = class extends XPathExpression {
      constructor(name, args) {
        super();
        this.jsonConverter = new JsonToXmlConverter();
        this.name = name;
        this.args = args;
      }
      evaluate(context) {
        var _a, _b, _c, _d, _e, _f;
        const evaluatedArgs = this.args.map((arg) => arg.evaluate(context));
        const constructorType = this.getConstructorType();
        if (constructorType) {
          if (evaluatedArgs.length !== 1) {
            throw functionSignatureMismatch(this.name, "1", evaluatedArgs.length);
          }
          const raw = evaluatedArgs[0];
          if (Array.isArray(raw)) {
            if (raw.length === 0) {
              throw typeMismatch(
                "single item",
                "empty sequence",
                `constructor function ${this.name}`
              );
            }
            if (raw.length !== 1) {
              throw typeMismatch(
                "single item",
                `sequence of ${raw.length} items`,
                `constructor function ${this.name}`
              );
            }
            return this.castConstructorValue(constructorType, raw[0]);
          }
          if (raw === void 0 || raw === null) {
            throw typeMismatch(
              "single item",
              "empty sequence",
              `constructor function ${this.name}`
            );
          }
          return this.castConstructorValue(constructorType, raw);
        }
        switch (this.name) {
          // Node set functions
          case "last":
            return (_a = context.size) != null ? _a : 0;
          case "position":
            return (_b = context.position) != null ? _b : 0;
          case "count":
            return Array.isArray(evaluatedArgs[0]) ? evaluatedArgs[0].length : 0;
          case "local-name":
            return this.localName(evaluatedArgs, context);
          case "namespace-uri":
            return this.namespaceUri(evaluatedArgs, context);
          case "name":
            return this.nodeName(evaluatedArgs, context);
          // String functions
          case "string":
            return this.stringValue(evaluatedArgs, context);
          case "concat":
            return evaluatedArgs.map((arg) => this.convertToString(arg)).join("");
          case "starts-with":
            return String(evaluatedArgs[0]).startsWith(String(evaluatedArgs[1]));
          case "contains":
            return String(evaluatedArgs[0]).includes(String(evaluatedArgs[1]));
          case "substring-before":
            return this.substringBefore(evaluatedArgs);
          case "substring-after":
            return this.substringAfter(evaluatedArgs);
          case "substring":
            return this.substring(evaluatedArgs);
          case "string-length":
            return this.stringLength(evaluatedArgs, context);
          case "normalize-space":
            return this.normalizeSpace(evaluatedArgs, context);
          case "translate":
            return this.translate(evaluatedArgs);
          // Boolean functions
          case "boolean":
            return this.toBoolean(evaluatedArgs[0]);
          case "not":
            return !this.toBoolean(evaluatedArgs[0]);
          case "true":
            return true;
          case "false":
            return false;
          case "lang":
            return this.lang(evaluatedArgs, context);
          // Number functions
          case "number":
            return this.toNumber(evaluatedArgs, context);
          case "sum":
            return this.sum(evaluatedArgs);
          case "floor":
            return Math.floor(Number(evaluatedArgs[0]));
          case "ceiling":
            return Math.ceil(Number(evaluatedArgs[0]));
          case "round":
            return Math.round(Number(evaluatedArgs[0]));
          // JSON functions (XPath 3.1)
          case "json-to-xml":
            return this.jsonToXml(evaluatedArgs, context);
          // XSLT 2.0 regex-group function (used in xsl:analyze-string)
          case "regex-group": {
            const groupIndex = Math.floor(Number(evaluatedArgs[0]));
            const regexGroups = (_c = context.extensions) == null ? void 0 : _c.regexGroups;
            if (regexGroups && groupIndex >= 0 && groupIndex < regexGroups.length) {
              return (_d = regexGroups[groupIndex]) != null ? _d : "";
            }
            return "";
          }
          // XSLT 2.0 current-group function (used in xsl:for-each-group)
          case "current-group": {
            const currentGroup = (_e = context.extensions) == null ? void 0 : _e.currentGroup;
            return currentGroup != null ? currentGroup : [];
          }
          // XSLT 2.0 current-grouping-key function (used in xsl:for-each-group)
          case "current-grouping-key": {
            const currentGroupingKey = (_f = context.extensions) == null ? void 0 : _f.currentGroupingKey;
            return currentGroupingKey != null ? currentGroupingKey : "";
          }
          default:
            if (context.functions && typeof context.functions[this.name] === "function") {
              return context.functions[this.name](context, ...evaluatedArgs);
            }
            let builtInFunc = BUILT_IN_FUNCTIONS[this.name];
            if (!builtInFunc && this.name.startsWith("fn:")) {
              const localName = this.name.substring(3);
              builtInFunc = BUILT_IN_FUNCTIONS[localName];
            }
            if (!builtInFunc && this.name.startsWith("Q{")) {
              const { namespace, localName } = this.parseEQName(this.name);
              builtInFunc = BUILT_IN_FUNCTIONS[localName];
              if (!builtInFunc && namespace === "http://www.w3.org/2005/xpath-functions/math") {
                builtInFunc = BUILT_IN_FUNCTIONS["math:" + localName];
              }
              if (!builtInFunc && namespace === "http://www.w3.org/2005/xpath-functions/array") {
                builtInFunc = BUILT_IN_FUNCTIONS["array:" + localName];
              }
            }
            if (builtInFunc) {
              return builtInFunc(context, ...evaluatedArgs);
            }
            throw unresolvedNameReference(this.name, "function");
        }
      }
      parseEQName(name) {
        const match = name.match(/^Q\{([^}]*)\}(.+)$/);
        if (match) {
          return {
            namespace: match[1],
            localName: match[2]
          };
        }
        return { namespace: "", localName: name };
      }
      getConstructorType() {
        if (!this.name.includes(":")) {
          return void 0;
        }
        const [prefix, localName] = this.name.split(":");
        if (!localName) {
          return void 0;
        }
        if (prefix !== "xs") {
          return void 0;
        }
        return getAtomicType(localName);
      }
      castConstructorValue(constructorType, value) {
        try {
          return constructorType.cast(value);
        } catch (err) {
          throw invalidCastArgument(value, this.name);
        }
      }
      toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "number") return value !== 0 && !isNaN(value);
        if (typeof value === "string") return value.length > 0;
        if (Array.isArray(value)) return value.length > 0;
        return !!value;
      }
      toNumber(args, context) {
        if (args.length === 0) {
          return Number(this.stringValue([], context));
        }
        const value = args[0];
        if (typeof value === "object" && value !== null && "numberValue" in value && typeof value.numberValue === "function") {
          return value.numberValue();
        }
        if (Array.isArray(value)) {
          if (value.length === 0) return NaN;
          const firstNode = value[0];
          const stringValue = this.getNodeStringValue(firstNode);
          return Number(stringValue);
        }
        return Number(value);
      }
      stringValue(args, context) {
        var _a, _b, _c, _d;
        if (args.length === 0) {
          return (_b = (_a = context.node) == null ? void 0 : _a.textContent) != null ? _b : "";
        }
        const value = args[0];
        if (Array.isArray(value) && value.length > 0) {
          return (_d = (_c = value[0]) == null ? void 0 : _c.textContent) != null ? _d : String(value[0]);
        }
        return String(value);
      }
      /**
       * Converts an XPath result to a string according to XPath 1.0 specification.
       * - Node-set: Returns the string-value of the first node in document order
       * - Number: Converts to string representation
       * - Boolean: Converts to 'true' or 'false'
       * - String: Returns as-is
       */
      convertToString(value) {
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "";
          }
          const firstNode = value[0];
          return this.getNodeStringValue(firstNode);
        }
        return String(value);
      }
      /**
       * Gets the string-value of a node according to XPath 1.0 specification.
       * - Element nodes: Concatenation of all descendant text nodes
       * - Text nodes: The character data
       * - Attribute nodes: The attribute value
       * - Other nodes: Their text content
       */
      getNodeStringValue(node) {
        var _a;
        if (!node) {
          return "";
        }
        if (typeof node.textContent === "string") {
          return node.textContent;
        }
        if (node.nodeType === 3 || node.nodeType === 2) {
          return (_a = node.nodeValue) != null ? _a : "";
        }
        if (node.nodeType === 1 || node.nodeType === 9 || node.nodeType === 11) {
          return this.getDescendantTextContent(node);
        }
        if (node.nodeValue !== void 0 && node.nodeValue !== null) {
          return String(node.nodeValue);
        }
        return "";
      }
      /**
       * Recursively gets the text content of all descendant text nodes.
       */
      getDescendantTextContent(node) {
        var _a;
        if (!node.childNodes || node.childNodes.length === 0) {
          return "";
        }
        let text = "";
        for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];
          if (child.nodeType === 3) {
            text += (_a = child.nodeValue) != null ? _a : "";
          } else if (child.nodeType === 1) {
            text += this.getDescendantTextContent(child);
          }
        }
        return text;
      }
      stringLength(args, context) {
        if (args.length === 0) {
          return this.stringValue([], context).length;
        }
        return String(args[0]).length;
      }
      normalizeSpace(args, context) {
        const str = args.length === 0 ? this.stringValue([], context) : String(args[0]);
        return str.trim().replace(/\s+/g, " ");
      }
      substringBefore(args) {
        const str = String(args[0]);
        const search = String(args[1]);
        const index = str.indexOf(search);
        return index === -1 ? "" : str.substring(0, index);
      }
      substringAfter(args) {
        const str = String(args[0]);
        const search = String(args[1]);
        const index = str.indexOf(search);
        return index === -1 ? "" : str.substring(index + search.length);
      }
      substring(args) {
        const str = String(args[0]);
        const start = Math.round(Number(args[1])) - 1;
        if (args.length === 2) {
          return str.substring(Math.max(0, start));
        }
        const length = Math.round(Number(args[2]));
        const adjustedStart = Math.max(0, start);
        const adjustedLength = Math.min(
          length - (adjustedStart - start),
          str.length - adjustedStart
        );
        return str.substring(adjustedStart, adjustedStart + adjustedLength);
      }
      translate(args) {
        const str = String(args[0]);
        const from = String(args[1]);
        const to = String(args[2]);
        let result = "";
        for (const char of str) {
          const index = from.indexOf(char);
          if (index === -1) {
            result += char;
          } else if (index < to.length) {
            result += to[index];
          }
        }
        return result;
      }
      localName(args, context) {
        var _a;
        const node = this.getNodeArg(args, context);
        return (_a = node == null ? void 0 : node.localName) != null ? _a : "";
      }
      namespaceUri(args, context) {
        var _a;
        const node = this.getNodeArg(args, context);
        return (_a = node == null ? void 0 : node.namespaceUri) != null ? _a : "";
      }
      nodeName(args, context) {
        var _a;
        const node = this.getNodeArg(args, context);
        return (_a = node == null ? void 0 : node.nodeName) != null ? _a : "";
      }
      getNodeArg(args, context) {
        if (args.length > 0 && Array.isArray(args[0]) && args[0].length > 0) {
          return args[0][0];
        }
        return context.node;
      }
      sum(args) {
        const nodeSet = args[0];
        if (!Array.isArray(nodeSet)) return 0;
        return nodeSet.reduce((acc, node) => {
          var _a;
          const value = Number((_a = node == null ? void 0 : node.textContent) != null ? _a : node);
          return acc + (isNaN(value) ? 0 : value);
        }, 0);
      }
      lang(args, context) {
        var _a, _b;
        const targetLang = String(args[0]).toLowerCase();
        let node = context.node;
        while (node) {
          const lang2 = ((_a = node.getAttribute) == null ? void 0 : _a.call(node, "xml:lang")) || ((_b = node.getAttribute) == null ? void 0 : _b.call(node, "lang"));
          if (lang2) {
            const nodeLang = lang2.toLowerCase();
            return nodeLang === targetLang || nodeLang.startsWith(targetLang + "-");
          }
          node = node.parentNode;
        }
        return false;
      }
      jsonToXml(args, context) {
        if (context.xsltVersion && context.xsltVersion !== "3.0") {
          throw new Error(
            'json-to-xml() is only supported in XSLT 3.0. Use version="3.0" in your stylesheet.'
          );
        }
        const jsonText = args.length > 0 ? String(args[0]) : null;
        let options;
        if (args.length > 1 && typeof args[1] === "object" && args[1] !== null) {
          options = this.mapToOptions(args[1]);
        }
        const documentNode = this.jsonConverter.convert(jsonText, options);
        return documentNode ? [documentNode] : [];
      }
      mapToOptions(optionsMap) {
        const options = {};
        if (optionsMap["liberal"] !== void 0) {
          options.liberal = Boolean(optionsMap["liberal"]);
        }
        if (optionsMap["duplicates"] !== void 0) {
          const dup = String(optionsMap["duplicates"]).toLowerCase();
          if (dup === "reject" || dup === "use-first" || dup === "retain") {
            options.duplicates = dup;
          }
        }
        if (optionsMap["validate"] !== void 0) {
          options.validate = Boolean(optionsMap["validate"]);
        }
        if (optionsMap["escape"] !== void 0) {
          options.escape = Boolean(optionsMap["escape"]);
        }
        if (optionsMap["fallback"] !== void 0 && typeof optionsMap["fallback"] === "function") {
          options.fallback = optionsMap["fallback"];
        }
        return options;
      }
    };
  }
});

// src/xpath/lib/src/expressions/let-expression.ts
var XPathLetExpression;
var init_let_expression = __esm({
  "src/xpath/lib/src/expressions/let-expression.ts"() {
    init_expression();
    XPathLetExpression = class extends XPathExpression {
      constructor(bindings, returnExpr) {
        super();
        this.bindings = bindings;
        this.returnExpr = returnExpr;
      }
      evaluate(context) {
        var _a;
        const variables = __spreadValues({}, (_a = context.variables) != null ? _a : {});
        let currentContext = __spreadProps(__spreadValues({}, context), { variables });
        for (const binding of this.bindings) {
          const value = binding.expression.evaluate(currentContext);
          variables[binding.variable] = value;
          currentContext = __spreadProps(__spreadValues({}, currentContext), { variables: __spreadValues({}, variables) });
        }
        return this.returnExpr.evaluate(currentContext);
      }
      toString() {
        const bindingStrs = this.bindings.map((b) => `$${b.variable} := ${b.expression}`);
        return `let ${bindingStrs.join(", ")} return ${this.returnExpr}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/simple-map-expression.ts
var XPathSimpleMapExpression;
var init_simple_map_expression = __esm({
  "src/xpath/lib/src/expressions/simple-map-expression.ts"() {
    init_expression();
    XPathSimpleMapExpression = class extends XPathExpression {
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const sequence = this.normalizeToSequence(leftValue);
        if (sequence.length === 0) {
          return [];
        }
        const results = [];
        const size = sequence.length;
        for (let i = 0; i < size; i++) {
          const item = sequence[i];
          const itemContext = __spreadProps(__spreadValues({}, context), {
            position: i + 1,
            size
          });
          if (this.isNode(item)) {
            itemContext.node = item;
          }
          itemContext.contextItem = item;
          const rightValue = this.right.evaluate(itemContext);
          this.appendResults(results, rightValue);
        }
        return results;
      }
      /**
       * Normalize a value to a sequence (array).
       */
      normalizeToSequence(value) {
        if (value === null || value === void 0) {
          return [];
        }
        if (Array.isArray(value)) {
          return value;
        }
        return [value];
      }
      /**
       * Check if a value is a DOM node.
       */
      isNode(value) {
        return value && typeof value === "object" && "nodeType" in value;
      }
      /**
       * Append results to the output array, flattening sequences.
       */
      appendResults(results, value) {
        if (value === null || value === void 0) {
          return;
        }
        if (Array.isArray(value)) {
          results.push(...value);
        } else {
          results.push(value);
        }
      }
      toString() {
        return `${this.left} ! ${this.right}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/string-concat-expression.ts
var XPathStringConcatExpression;
var init_string_concat_expression = __esm({
  "src/xpath/lib/src/expressions/string-concat-expression.ts"() {
    init_expression();
    XPathStringConcatExpression = class extends XPathExpression {
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      evaluate(context) {
        const leftValue = this.left.evaluate(context);
        const rightValue = this.right.evaluate(context);
        const leftStr = this.atomizeToString(leftValue);
        const rightStr = this.atomizeToString(rightValue);
        return leftStr + rightStr;
      }
      /**
       * Atomize a value and convert to string.
       * Empty sequence becomes empty string.
       */
      atomizeToString(value) {
        if (value === null || value === void 0) {
          return "";
        }
        if (typeof value === "object" && "stringValue" in value && typeof value.stringValue === "function") {
          return value.stringValue();
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "";
          }
          return this.valueToString(value[0]);
        }
        return this.valueToString(value);
      }
      /**
       * Convert a single value to string.
       */
      valueToString(value) {
        if (value === null || value === void 0) {
          return "";
        }
        if (typeof value === "object" && "stringValue" in value && typeof value.stringValue === "function") {
          return value.stringValue();
        }
        if (typeof value === "string") {
          return value;
        }
        if (typeof value === "number") {
          if (Number.isNaN(value)) return "NaN";
          if (value === Infinity) return "INF";
          if (value === -Infinity) return "-INF";
          return String(value);
        }
        if (typeof value === "boolean") {
          return value ? "true" : "false";
        }
        if (this.isNode(value)) {
          return this.getNodeStringValue(value);
        }
        return String(value);
      }
      /**
       * Check if a value is a DOM node.
       */
      isNode(value) {
        return value && typeof value === "object" && "nodeType" in value;
      }
      /**
       * Get the string value of a node.
       */
      getNodeStringValue(node) {
        if (!node) return "";
        if (node.nodeType === 3 || node.nodeType === 4) {
          return node.nodeValue || "";
        }
        if (node.nodeType === 2) {
          return node.value || node.nodeValue || "";
        }
        if (node.nodeType === 1 || node.nodeType === 9) {
          return node.textContent || "";
        }
        if (node.nodeType === 7 || node.nodeType === 8) {
          return node.nodeValue || "";
        }
        return "";
      }
      toString() {
        return `${this.left} || ${this.right}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/string-template-expression.ts
function parseStringTemplate(template) {
  const parts = [];
  let current = "";
  let i = 0;
  while (i < template.length) {
    const char = template[i];
    if (char === "\\" && i + 1 < template.length) {
      const nextChar = template[i + 1];
      switch (nextChar) {
        case "`":
          current += "`";
          i += 2;
          break;
        case "{":
          current += "{";
          i += 2;
          break;
        case "}":
          current += "}";
          i += 2;
          break;
        case "n":
          current += "\n";
          i += 2;
          break;
        case "r":
          current += "\r";
          i += 2;
          break;
        case "t":
          current += "	";
          i += 2;
          break;
        case "\\":
          current += "\\";
          i += 2;
          break;
        default:
          current += char;
          i++;
      }
    } else if (char === "{" && i + 1 < template.length && template[i + 1] !== "{") {
      if (current.length > 0) {
        parts.push(current);
        current = "";
      }
      let depth = 1;
      let j = i + 1;
      while (j < template.length && depth > 0) {
        if (template[j] === "{" && template[j - 1] !== "\\") {
          depth++;
        } else if (template[j] === "}" && template[j - 1] !== "\\") {
          depth--;
        }
        j++;
      }
      if (depth !== 0) {
        throw new Error("Unclosed expression in string template");
      }
      const exprStr = template.substring(i + 1, j - 1);
      parts.push({ expressionString: exprStr });
      i = j;
    } else {
      current += char;
      i++;
    }
  }
  if (current.length > 0) {
    parts.push(current);
  }
  return parts;
}
var StringTemplateExpression;
var init_string_template_expression = __esm({
  "src/xpath/lib/src/expressions/string-template-expression.ts"() {
    StringTemplateExpression = class {
      constructor(parts) {
        this.parts = parts;
      }
      evaluate(context) {
        const result = [];
        for (const part of this.parts) {
          if (typeof part === "string") {
            result.push(part);
          } else {
            const value = part.evaluate(context);
            result.push(this.valueToString(value));
          }
        }
        return result.join("");
      }
      /**
       * Convert a value to string for concatenation in template.
       */
      valueToString(value) {
        if (value === null || value === void 0) {
          return "";
        }
        if (typeof value === "string") {
          return value;
        }
        if (typeof value === "number") {
          if (Number.isNaN(value)) return "NaN";
          if (value === Infinity) return "INF";
          if (value === -Infinity) return "-INF";
          return String(value);
        }
        if (typeof value === "boolean") {
          return value ? "true" : "false";
        }
        if (Array.isArray(value)) {
          if (value.length === 0) return "";
          return this.valueToString(value[0]);
        }
        if (typeof value === "object" && value !== null) {
          if ("nodeType" in value && value.nodeType) {
            return this.getNodeStringValue(value);
          }
          if (typeof value.toString === "function") {
            const str = value.toString();
            if (str !== "[object Object]") {
              return str;
            }
          }
        }
        return String(value);
      }
      /**
       * Get string value of a node.
       */
      getNodeStringValue(node) {
        if (node.textContent !== void 0) {
          return String(node.textContent);
        }
        if (node.nodeType === 3) {
          return node.data || node.textContent || "";
        }
        if (node.nodeType === 1 || node.nodeType === 9) {
          return this.getDescendantTextContent(node);
        }
        return "";
      }
      /**
       * Get all text content from node and descendants.
       */
      getDescendantTextContent(node) {
        var _a, _b;
        const parts = [];
        if ("childNodes" in node && Array.isArray(node.childNodes)) {
          for (const child of node.childNodes) {
            if (child.nodeType === 3) {
              parts.push((_b = (_a = child.textContent) != null ? _a : child.data) != null ? _b : "");
            } else if (child.nodeType === 1) {
              parts.push(this.getDescendantTextContent(child));
            }
          }
        }
        return parts.join("");
      }
    };
  }
});

// src/xpath/lib/src/expressions/arrow-expression.ts
var XPathArrowExpression;
var init_arrow_expression = __esm({
  "src/xpath/lib/src/expressions/arrow-expression.ts"() {
    init_expression();
    init_function_call_expression();
    XPathArrowExpression = class extends XPathExpression {
      constructor(input, functionName2, args) {
        super();
        this.input = input;
        this.functionName = functionName2;
        this.args = args;
      }
      evaluate(context) {
        const allArgs = [this.input, ...this.args];
        const funcCall = new XPathFunctionCall(this.functionName, allArgs);
        return funcCall.evaluate(context);
      }
      toString() {
        const argsStr = this.args.length > 0 ? this.args.map((a) => a.toString()).join(", ") : "";
        return `${this.input} => ${this.functionName}(${argsStr})`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/named-function-ref-expression.ts
var XPathNamedFunctionRef;
var init_named_function_ref_expression = __esm({
  "src/xpath/lib/src/expressions/named-function-ref-expression.ts"() {
    init_function_type();
    init_expression();
    init_function_call_expression();
    XPathNamedFunctionRef = class extends XPathExpression {
      constructor(name, arity) {
        super();
        this.name = name;
        this.arity = arity;
      }
      evaluate(context) {
        const funcItem = this.resolveFunction(context);
        if (!funcItem) {
          throw new Error(`Unknown function: ${this.name}#${this.arity}`);
        }
        return funcItem;
      }
      /**
       * Resolve the named function to a function item.
       */
      resolveFunction(context) {
        const { namespace: parsedNamespace, localName } = this.parseNameWithNamespace(
          this.name,
          context
        );
        const namespace = parsedNamespace;
        let builtIn = getBuiltInFunction(localName);
        let lookupName = localName;
        if (!builtIn && namespace === MATH_NAMESPACE) {
          builtIn = getBuiltInFunction("math:" + localName);
          lookupName = "math:" + localName;
        }
        if (builtIn) {
          const expectedArity = getBuiltInFunctionArity(lookupName);
          if (expectedArity !== void 0 && !this.arityMatches(lookupName, this.arity)) {
            throw new Error(`Function ${this.name} does not accept ${this.arity} arguments`);
          }
          const implementation = (...args) => {
            return builtIn(context, ...args);
          };
          return {
            __isFunctionItem: true,
            implementation,
            arity: this.arity,
            name: localName,
            namespace
          };
        }
        if (context.functionRegistry) {
          const registeredFunc = context.functionRegistry[localName] || context.functionRegistry[this.name];
          if (registeredFunc) {
            return {
              __isFunctionItem: true,
              implementation: registeredFunc,
              arity: this.arity,
              name: localName,
              namespace
            };
          }
        }
        if (context.functions) {
          const customFunc = context.functions[this.name] || context.functions[localName];
          if (customFunc) {
            return {
              __isFunctionItem: true,
              implementation: customFunc,
              arity: this.arity,
              name: localName,
              namespace
            };
          }
        }
        return null;
      }
      /**
       * Check if the given arity is valid for the function.
       */
      arityMatches(funcName, arity) {
        const variableArityFuncs = {
          concat: [2, Infinity],
          substring: [2, 3],
          "string-join": [1, 2],
          "normalize-space": [0, 1],
          "string-length": [0, 1],
          "local-name": [0, 1],
          "namespace-uri": [0, 1],
          name: [0, 1],
          round: [1, 2],
          "format-number": [2, 3]
        };
        const range = variableArityFuncs[funcName];
        if (range) {
          return arity >= range[0] && arity <= range[1];
        }
        return arity >= 0 && arity <= 10;
      }
      /**
       * Parse a QName or EQName into namespace and local name.
       * Handles both prefix:local format and Q{uri}local format.
       */
      parseNameWithNamespace(name, context) {
        if (name.startsWith("Q{")) {
          const match = name.match(/^Q\{([^}]*)\}(.+)$/);
          if (match) {
            const [, uri, localName] = match;
            return {
              namespace: uri || void 0,
              localName
            };
          }
        }
        const colonIndex = name.indexOf(":");
        if (colonIndex > 0) {
          const prefix = name.substring(0, colonIndex);
          const localName = name.substring(colonIndex + 1);
          let namespace;
          if (prefix === "fn") {
            namespace = FN_NAMESPACE;
          } else if (prefix === "math") {
            namespace = MATH_NAMESPACE;
          } else if (context.namespaces && context.namespaces[prefix]) {
            namespace = context.namespaces[prefix];
          }
          return { namespace, localName };
        }
        return { namespace: FN_NAMESPACE, localName: name };
      }
      toString() {
        return `${this.name}#${this.arity}`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/inline-function-expression.ts
var XPathInlineFunctionExpression;
var init_inline_function_expression = __esm({
  "src/xpath/lib/src/expressions/inline-function-expression.ts"() {
    init_expression();
    XPathInlineFunctionExpression = class extends XPathExpression {
      constructor(params, body, returnType) {
        super();
        this.params = params;
        this.body = body;
        this.returnType = returnType;
      }
      evaluate(context) {
        var _a;
        const closureVariables = __spreadValues({}, (_a = context.variables) != null ? _a : {});
        const self = this;
        const implementation = function(...args) {
          const variables = __spreadValues({}, closureVariables);
          for (let i = 0; i < self.params.length; i++) {
            const param = self.params[i];
            const arg = i < args.length ? args[i] : null;
            variables[param.name] = arg;
          }
          const evalContext = __spreadProps(__spreadValues({}, context), {
            variables
          });
          return self.body.evaluate(evalContext);
        };
        return {
          __isFunctionItem: true,
          implementation,
          arity: this.params.length,
          name: void 0,
          namespace: void 0
        };
      }
      toString() {
        const paramsStr = this.params.map((p) => {
          let s = `$${p.name}`;
          if (p.type) s += ` as ${p.type}`;
          return s;
        }).join(", ");
        let result = `function(${paramsStr})`;
        if (this.returnType) {
          result += ` as ${this.returnType}`;
        }
        result += ` { ${this.body} }`;
        return result;
      }
    };
  }
});

// src/xpath/lib/src/expressions/dynamic-function-call-expression.ts
function isFunctionItem2(value) {
  return value && typeof value === "object" && value.__isFunctionItem === true;
}
var XPathDynamicFunctionCall;
var init_dynamic_function_call_expression = __esm({
  "src/xpath/lib/src/expressions/dynamic-function-call-expression.ts"() {
    init_expression();
    init_map_constructor_expression();
    init_array_constructor_expression();
    XPathDynamicFunctionCall = class extends XPathExpression {
      constructor(functionExpr, args) {
        super();
        this.functionExpr = functionExpr;
        this.args = args;
      }
      evaluate(context) {
        const funcValue = this.functionExpr.evaluate(context);
        if (isXPathMap(funcValue)) {
          if (this.args.length !== 1) {
            throw new Error(`Map lookup expects 1 argument but got ${this.args.length}`);
          }
          const key = String(this.args[0].evaluate(context));
          const value = funcValue[key];
          if (value === void 0) {
            throw new Error(`XPDY0002: Key "${key}" not found in map`);
          }
          return value;
        }
        if (isXPathArray(funcValue)) {
          if (this.args.length !== 1) {
            throw new Error(`Array lookup expects 1 argument but got ${this.args.length}`);
          }
          const position = Number(this.args[0].evaluate(context));
          return getArrayMember(funcValue, position);
        }
        if (isFunctionItem2(funcValue)) {
          const funcItem = funcValue;
          if (funcItem.arity !== this.args.length) {
            throw new Error(
              `Function expects ${funcItem.arity} arguments but got ${this.args.length}`
            );
          }
          const evaluatedArgs = this.args.map((arg) => arg.evaluate(context));
          return funcItem.implementation(...evaluatedArgs);
        }
        if (typeof funcValue === "function") {
          const evaluatedArgs = this.args.map((arg) => arg.evaluate(context));
          return funcValue(...evaluatedArgs);
        }
        throw new Error("Dynamic function call: expression does not evaluate to a function item");
      }
      toString() {
        const argsStr = this.args.map((a) => a.toString()).join(", ");
        return `${this.functionExpr}(${argsStr})`;
      }
    };
  }
});

// src/xpath/lib/src/expressions/try-expression.ts
function createTryExpression(tryExpression, catchExpression, errorPattern, errorVariableName) {
  return new TryExpression(tryExpression, catchExpression, errorPattern, errorVariableName);
}
function createTryOnly(tryExpression) {
  return new TryExpression(tryExpression, null);
}
function createTryWithFallback(tryExpression, fallbackValue) {
  const fallbackExpr = new class extends XPathExpression {
    evaluate() {
      return fallbackValue;
    }
    toString() {
      return JSON.stringify(fallbackValue);
    }
  }();
  return new TryExpression(tryExpression, fallbackExpr);
}
function safeEvaluate(expr, context) {
  const tryExpr = createTryOnly(expr);
  return tryExpr.evaluate(context);
}
var TryExpression, XSLT3ErrorCodes;
var init_try_expression = __esm({
  "src/xpath/lib/src/expressions/try-expression.ts"() {
    init_expression();
    TryExpression = class extends XPathExpression {
      constructor(tryExpression, catchExpression, errorPattern, errorVariableName) {
        super();
        this.tryExpr = tryExpression;
        this.catchExpr = catchExpression || null;
        this.errorPattern = errorPattern || null;
        this.errorVariableName = errorVariableName || null;
      }
      /**
       * Evaluate the try-catch expression
       *
       * Note: This is a synchronous implementation for compatibility.
       * For full async support, the base XPathExpression class would need updating.
       */
      evaluate(context) {
        try {
          const result = this.tryExpr.evaluate(context);
          if (result && typeof result === "object" && typeof result.catch === "function") {
            return result.catch((error) => this.handleError(error, context));
          }
          return result;
        } catch (error) {
          if (!this.catchExpr) {
            return void 0;
          }
          return this.handleError(error, context);
        }
      }
      /**
       * Handle caught error and evaluate catch expression
       */
      handleError(error, context) {
        const caughtError = this.createCaughtError(error);
        if (this.errorPattern && !this.matchesErrorPattern(caughtError, this.errorPattern)) {
          throw error;
        }
        const catchContext = {
          node: context.node,
          position: context.position,
          size: context.size,
          variables: context.variables ? new Map(context.variables) : /* @__PURE__ */ new Map(),
          functions: context.functions || {}
        };
        if (this.errorVariableName) {
          catchContext.variables.set(this.errorVariableName, caughtError);
        }
        catchContext.variables.set("err:code", caughtError.code);
        catchContext.variables.set("err:description", caughtError.description);
        catchContext.variables.set("err:value", caughtError.value);
        return this.catchExpr.evaluate(catchContext);
      }
      /**
       * Create caught error information from thrown error
       */
      createCaughtError(error) {
        let code = "UNKNOWN";
        let description = "Unknown error";
        let type = "dynamic";
        if (typeof error === "string") {
          description = error;
        } else if (error && typeof error === "object") {
          if (error.message) {
            description = error.message;
          }
          if (error.code) {
            code = error.code;
          }
          if (error.type) {
            type = error.type;
          }
        }
        return {
          code,
          description,
          value: error,
          stack: error == null ? void 0 : error.stack,
          type
        };
      }
      /**
       * Check if caught error matches error pattern
       */
      matchesErrorPattern(caughtError, pattern) {
        if (pattern === "*") {
          return true;
        }
        return caughtError.code === pattern || caughtError.code.includes(pattern);
      }
      /**
       * Get string representation
       */
      toString() {
        let result = `try { ${this.tryExpr.toString()} }`;
        if (this.catchExpr) {
          result += ` catch`;
          if (this.errorPattern) {
            result += ` (${this.errorPattern})`;
          }
          result += ` { ${this.catchExpr.toString()} }`;
        }
        return result;
      }
    };
    XSLT3ErrorCodes = {
      /**
       * Type error
       */
      XPTY0004: "XPTY0004",
      /**
       * Division by zero
       */
      FOAR0001: "FOAR0001",
      /**
       * Invalid argument
       */
      FORG0001: "FORG0001",
      /**
       * Invalid QName
       */
      FONS0004: "FONS0004",
      /**
       * Sequence is empty
       */
      FORG0004: "FORG0004",
      /**
       * Sequence has more than one item
       */
      FORG0005: "FORG0005",
      /**
       * Variable not defined
       */
      XPST0008: "XPST0008",
      /**
       * Context item is not a node
       */
      XPTY0019: "XPTY0019",
      /**
       * Invalid format-string
       */
      FODF1310: "FODF1310",
      /**
       * Schema not available
       */
      XPST0051: "XPST0051"
    };
  }
});

// src/xpath/lib/src/expressions/lookup-expression.ts
var KeySpecifierType, XPathLookupExpression;
var init_lookup_expression = __esm({
  "src/xpath/lib/src/expressions/lookup-expression.ts"() {
    init_array_constructor_expression();
    init_map_constructor_expression();
    KeySpecifierType = /* @__PURE__ */ ((KeySpecifierType2) => {
      KeySpecifierType2["NCNAME"] = "NCNAME";
      KeySpecifierType2["INTEGER_LITERAL"] = "INTEGER_LITERAL";
      KeySpecifierType2["PARENTHESIZED_EXPR"] = "PARENTHESIZED_EXPR";
      KeySpecifierType2["WILDCARD"] = "WILDCARD";
      return KeySpecifierType2;
    })(KeySpecifierType || {});
    XPathLookupExpression = class {
      constructor(baseExpr, keySpecifier) {
        this.baseExpr = baseExpr;
        this.keySpecifier = keySpecifier;
      }
      evaluate(context) {
        let target;
        if (this.baseExpr) {
          target = this.baseExpr.evaluate(context);
        } else {
          target = context.contextItem;
          if (target === void 0) {
            throw new Error("XPDY0002: Context item is undefined for unary lookup");
          }
        }
        if (isXPathMap(target)) {
          return this.lookupInMap(target, this.keySpecifier, context);
        } else if (isXPathArray(target)) {
          return this.lookupInArray(target, this.keySpecifier, context);
        } else {
          throw new Error("XPTY0004: Lookup operator can only be applied to maps and arrays");
        }
      }
      lookupInMap(map, keySpecifier, context) {
        switch (keySpecifier.type) {
          case "NCNAME" /* NCNAME */:
            const key = keySpecifier.value;
            return map[key];
          case "INTEGER_LITERAL" /* INTEGER_LITERAL */:
            const intKey = keySpecifier.value.toString();
            return map[intKey];
          case "PARENTHESIZED_EXPR" /* PARENTHESIZED_EXPR */:
            const expr = keySpecifier.value;
            const dynamicKey = expr.evaluate(context);
            const stringKey = this.atomizeToString(dynamicKey);
            return map[stringKey];
          case "WILDCARD" /* WILDCARD */:
            return Object.keys(map).filter((key2) => !key2.startsWith("__")).map((key2) => map[key2]);
          default:
            throw new Error("FOAY0001: Invalid key specifier for map lookup");
        }
      }
      lookupInArray(array, keySpecifier, context) {
        switch (keySpecifier.type) {
          case "INTEGER_LITERAL" /* INTEGER_LITERAL */:
            const position = keySpecifier.value;
            if (position < 1) {
              throw new Error("FOAY0001: Array index must be positive");
            }
            if (position > array.members.length) {
              throw new Error("FOAY0001: Array index out of bounds");
            }
            return array.members[position - 1];
          // 1-based indexing
          case "PARENTHESIZED_EXPR" /* PARENTHESIZED_EXPR */:
            const expr = keySpecifier.value;
            const dynamicPos = expr.evaluate(context);
            const positionNum = this.atomizeToNumber(dynamicPos);
            if (positionNum < 1) {
              throw new Error("FOAY0001: Array index must be positive");
            }
            if (positionNum > array.members.length) {
              throw new Error("FOAY0001: Array index out of bounds");
            }
            return array.members[positionNum - 1];
          case "WILDCARD" /* WILDCARD */:
            return this.flattenArrayMembers(array.members);
          case "NCNAME" /* NCNAME */:
            throw new Error("XPTY0004: NCName key not valid for array lookup");
          default:
            throw new Error("FOAY0001: Invalid key specifier for array lookup");
        }
      }
      /**
       * Flatten array members, handling nested arrays.
       * For wildcard lookup, nested arrays are flattened.
       */
      flattenArrayMembers(members) {
        const result = [];
        for (const member of members) {
          if (isXPathArray(member)) {
            result.push(...this.flattenArrayMembers(member.members));
          } else {
            result.push(member);
          }
        }
        return result;
      }
      /**
       * Atomize a value to a string for use as a map key.
       * Per XPath 2.0 Section 2.4.2: Atomization
       * - Atomic values pass through unchanged
       * - Arrays/Maps: extract atomic values and convert to string
       * - Nodes: use string value
       * - Function items: should error (cannot atomize function items)
       */
      atomizeToString(value) {
        if (value === null || value === void 0) {
          return "";
        }
        if (typeof value === "string") return value;
        if (typeof value === "number") return value.toString();
        if (typeof value === "boolean") return value.toString();
        if (Array.isArray(value)) {
          if (value.length === 0) return "";
          if (value.length === 1) return this.atomizeToString(value[0]);
          return this.atomizeToString(value[0]);
        }
        if (typeof value === "object" && value.$isXPathMap) {
          throw new Error("XPTY0004: Cannot atomize a map to string");
        }
        if (typeof value === "object" && (value.nodeType || value.nodeName || value.textContent)) {
          return (value.textContent || value.value || "").toString();
        }
        if (typeof value === "function") {
          throw new Error("XPTY0004: Cannot atomize a function item");
        }
        try {
          return String(value);
        } catch (e) {
          throw new Error("XPTY0004: Cannot atomize value");
        }
      }
      /**
       * Atomize a value to a number for use as an array index.
       * Per XPath 2.0 Section 2.4.2: Atomization
       * - Numbers pass through unchanged
       * - Strings: convert to number
       * - Booleans: error
       * - Arrays/Maps/Function items: error
       */
      atomizeToNumber(value) {
        if (value === null || value === void 0) {
          throw new Error("XPTY0004: Cannot convert empty sequence to number");
        }
        if (typeof value === "number") return value;
        if (typeof value === "string") {
          const num = parseFloat(value);
          if (isNaN(num)) throw new Error("FORG0001: Invalid number");
          return num;
        }
        if (typeof value === "boolean") {
          throw new Error("XPTY0004: Cannot convert boolean to number for array index");
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            throw new Error("XPTY0004: Cannot convert empty sequence to number");
          }
          if (value.length === 1) {
            return this.atomizeToNumber(value[0]);
          }
          throw new Error("XPTY0004: Cannot convert sequence to single number");
        }
        if (typeof value === "object" && value.$isXPathMap) {
          throw new Error("XPTY0004: Cannot atomize a map to number");
        }
        if (typeof value === "object" && (value.nodeType || value.nodeName || value.textContent)) {
          const str = (value.textContent || value.value || "").toString();
          const num = parseFloat(str);
          if (isNaN(num)) throw new Error("FORG0001: Invalid number from node");
          return num;
        }
        if (typeof value === "function") {
          throw new Error("XPTY0004: Cannot atomize a function item");
        }
        throw new Error("FORG0001: Cannot convert to number");
      }
      toString() {
        const base = this.baseExpr ? this.baseExpr.toString() : "";
        let keyStr;
        switch (this.keySpecifier.type) {
          case "NCNAME" /* NCNAME */:
            keyStr = this.keySpecifier.value;
            break;
          case "INTEGER_LITERAL" /* INTEGER_LITERAL */:
            keyStr = this.keySpecifier.value.toString();
            break;
          case "PARENTHESIZED_EXPR" /* PARENTHESIZED_EXPR */:
            keyStr = `(${this.keySpecifier.value})`;
            break;
          case "WILDCARD" /* WILDCARD */:
            keyStr = "*";
            break;
          default:
            keyStr = "?";
        }
        return base + "?" + keyStr;
      }
    };
  }
});

// src/xpath/lib/src/expressions/index.ts
var expressions_exports = {};
__export(expressions_exports, {
  CommaExpression: () => CommaExpression,
  EmptySequenceExpression: () => EmptySequenceExpression,
  FilteredPathExpression: () => FilteredPathExpression,
  GeneralComparisonExpression: () => GeneralComparisonExpression,
  JsonToXmlConverter: () => JsonToXmlConverter,
  KeySpecifierType: () => KeySpecifierType,
  NodeComparisonExpression: () => NodeComparisonExpression,
  ParenthesizedExpression: () => ParenthesizedExpression,
  RangeExpression: () => RangeExpression,
  StringTemplateExpression: () => StringTemplateExpression,
  TryExpression: () => TryExpression,
  ValueComparisonExpression: () => ValueComparisonExpression,
  XPathArithmeticExpression: () => XPathArithmeticExpression,
  XPathArrowExpression: () => XPathArrowExpression,
  XPathBinaryExpression: () => XPathBinaryExpression,
  XPathCastableExpression: () => XPathCastableExpression,
  XPathConditionalExpression: () => XPathConditionalExpression,
  XPathCurlyBraceArrayConstructor: () => XPathCurlyBraceArrayConstructor,
  XPathDynamicFunctionCall: () => XPathDynamicFunctionCall,
  XPathExpression: () => XPathExpression,
  XPathFilterExpression: () => XPathFilterExpression,
  XPathForExpression: () => XPathForExpression,
  XPathFunctionCall: () => XPathFunctionCall,
  XPathInlineFunctionExpression: () => XPathInlineFunctionExpression,
  XPathInstanceOfExpression: () => XPathInstanceOfExpression,
  XPathLetExpression: () => XPathLetExpression,
  XPathLocationPath: () => XPathLocationPath,
  XPathLogicalExpression: () => XPathLogicalExpression,
  XPathLookupExpression: () => XPathLookupExpression,
  XPathMapConstructorExpression: () => XPathMapConstructorExpression,
  XPathNamedFunctionRef: () => XPathNamedFunctionRef,
  XPathNumberLiteral: () => XPathNumberLiteral,
  XPathPredicate: () => XPathPredicate,
  XPathQuantifiedExpression: () => XPathQuantifiedExpression,
  XPathSimpleMapExpression: () => XPathSimpleMapExpression,
  XPathSquareBracketArrayConstructor: () => XPathSquareBracketArrayConstructor,
  XPathStep: () => XPathStep,
  XPathStringConcatExpression: () => XPathStringConcatExpression,
  XPathStringLiteral: () => XPathStringLiteral,
  XPathTreatExpression: () => XPathTreatExpression,
  XPathUnaryExpression: () => XPathUnaryExpression,
  XPathUnionExpression: () => XPathUnionExpression,
  XPathVariableReference: () => XPathVariableReference,
  XSLT3ErrorCodes: () => XSLT3ErrorCodes,
  concatenateSequences: () => concatenateSequences,
  createSequence: () => createSequence,
  createTryExpression: () => createTryExpression,
  createTryOnly: () => createTryOnly,
  createTryWithFallback: () => createTryWithFallback,
  createXPathArray: () => createXPathArray,
  flattenSequence: () => flattenSequence,
  getArrayMember: () => getArrayMember,
  getArraySize: () => getArraySize,
  getBuiltInFunction: () => getBuiltInFunction,
  getBuiltInFunctionArity: () => getBuiltInFunctionArity,
  getNodeId: () => getNodeId,
  isXPathArray: () => isXPathArray,
  isXPathMap: () => isXPathMap,
  isXPathNode: () => isXPathNode,
  parseStringTemplate: () => parseStringTemplate,
  safeEvaluate: () => safeEvaluate
});
var init_expressions = __esm({
  "src/xpath/lib/src/expressions/index.ts"() {
    init_expression();
    init_literal_expression();
    init_variable_reference_expression();
    init_step_expression();
    init_location_path_expression();
    init_filter_expression();
    init_unary_expression();
    init_binary_expression();
    init_arithmetic_expression();
    init_logical_expression();
    init_conditional_expression();
    init_for_expression();
    init_quantified_expression();
    init_instance_of_expression();
    init_castable_expression();
    init_treat_expression();
    init_union_expression();
    init_sequence_construction();
    init_predicate_expression();
    init_value_comparison();
    init_general_comparison();
    init_node_comparison();
    init_function_call_expression();
    init_json_to_xml_converter();
    init_let_expression();
    init_simple_map_expression();
    init_string_concat_expression();
    init_string_template_expression();
    init_arrow_expression();
    init_named_function_ref_expression();
    init_inline_function_expression();
    init_dynamic_function_call_expression();
    init_try_expression();
    init_map_constructor_expression();
    init_array_constructor_expression();
    init_lookup_expression();
  }
});

// src/xpath/lib/src/lexer/token.ts
var XPathToken = class {
  constructor(type, lexeme) {
    this.type = type;
    this.lexeme = lexeme;
  }
};

// src/xpath/lib/src/lexer/lexer.ts
var DEFAULT_LEXER_VERSION = "1.0";
var COMMON_RESERVED_WORDS = {
  // Location axes (XPath 1.0 complete list)
  ancestor: { type: "LOCATION", value: "ancestor" },
  "ancestor-or-self": { type: "LOCATION", value: "ancestor-or-self" },
  attribute: { type: "LOCATION", value: "attribute" },
  child: { type: "LOCATION", value: "child" },
  descendant: { type: "LOCATION", value: "descendant" },
  "descendant-or-self": { type: "LOCATION", value: "descendant-or-self" },
  following: { type: "LOCATION", value: "following" },
  "following-sibling": { type: "LOCATION", value: "following-sibling" },
  namespace: { type: "LOCATION", value: "namespace" },
  parent: { type: "LOCATION", value: "parent" },
  preceding: { type: "LOCATION", value: "preceding" },
  "preceding-sibling": { type: "LOCATION", value: "preceding-sibling" },
  self: { type: "LOCATION", value: "self" },
  // Node type tests
  node: { type: "NODE_TYPE", value: "node" },
  text: { type: "NODE_TYPE", value: "text" },
  comment: { type: "NODE_TYPE", value: "comment" },
  "processing-instruction": { type: "NODE_TYPE", value: "processing-instruction" },
  // Operators
  and: { type: "OPERATOR", value: "and" },
  or: { type: "OPERATOR", value: "or" },
  div: { type: "OPERATOR", value: "div" },
  mod: { type: "OPERATOR", value: "mod" },
  // Node set functions (XPath 1.0, also valid in later versions)
  last: { type: "FUNCTION", value: "last" },
  position: { type: "FUNCTION", value: "position" },
  count: { type: "FUNCTION", value: "count" },
  id: { type: "FUNCTION", value: "id" },
  "local-name": { type: "FUNCTION", value: "local-name" },
  "namespace-uri": { type: "FUNCTION", value: "namespace-uri" },
  name: { type: "FUNCTION", value: "name" },
  // String functions
  string: { type: "FUNCTION", value: "string" },
  concat: { type: "FUNCTION", value: "concat" },
  "starts-with": { type: "FUNCTION", value: "starts-with" },
  contains: { type: "FUNCTION", value: "contains" },
  "substring-before": { type: "FUNCTION", value: "substring-before" },
  "substring-after": { type: "FUNCTION", value: "substring-after" },
  substring: { type: "FUNCTION", value: "substring" },
  "string-length": { type: "FUNCTION", value: "string-length" },
  "normalize-space": { type: "FUNCTION", value: "normalize-space" },
  translate: { type: "FUNCTION", value: "translate" },
  // Boolean functions
  boolean: { type: "FUNCTION", value: "boolean" },
  not: { type: "FUNCTION", value: "not" },
  true: { type: "FUNCTION", value: "true" },
  false: { type: "FUNCTION", value: "false" },
  lang: { type: "FUNCTION", value: "lang" },
  // Number functions
  number: { type: "FUNCTION", value: "number" },
  sum: { type: "FUNCTION", value: "sum" },
  floor: { type: "FUNCTION", value: "floor" },
  ceiling: { type: "FUNCTION", value: "ceiling" },
  round: { type: "FUNCTION", value: "round" }
};
var XPATH20_RESERVED_WORDS = {
  // Conditional expression keywords (XPath 2.0)
  if: { type: "RESERVED_WORD", value: "if" },
  then: { type: "RESERVED_WORD", value: "then" },
  else: { type: "RESERVED_WORD", value: "else" },
  // FLWOR expressions (XPath 2.0)
  for: { type: "RESERVED_WORD", value: "for" },
  in: { type: "RESERVED_WORD", value: "in" },
  return: { type: "RESERVED_WORD", value: "return" },
  // Quantified expressions (XPath 2.0)
  some: { type: "RESERVED_WORD", value: "some" },
  every: { type: "RESERVED_WORD", value: "every" },
  satisfies: { type: "RESERVED_WORD", value: "satisfies" },
  // SequenceType operations (XPath 2.0)
  instance: { type: "RESERVED_WORD", value: "instance" },
  of: { type: "RESERVED_WORD", value: "of" },
  // Cast expressions (XPath 2.0)
  cast: { type: "RESERVED_WORD", value: "cast" },
  as: { type: "RESERVED_WORD", value: "as" },
  castable: { type: "RESERVED_WORD", value: "castable" },
  treat: { type: "RESERVED_WORD", value: "treat" },
  // Range expression (XPath 2.0)
  to: { type: "RESERVED_WORD", value: "to" }
};
var XPATH30_RESERVED_WORDS = {
  // Let expression (XPath 3.0)
  let: { type: "RESERVED_WORD", value: "let" },
  // Function keyword for inline functions (XPath 3.0)
  function: { type: "RESERVED_WORD", value: "function" }
};
var XPATH31_RESERVED_WORDS = {
  // Map constructor keyword (XPath 3.1)
  map: { type: "RESERVED_WORD", value: "map" },
  // Array constructor keyword (XPath 3.1)
  array: { type: "RESERVED_WORD", value: "array" }
};
function buildReservedWords(version) {
  const merged = __spreadValues({}, COMMON_RESERVED_WORDS);
  if (version !== "1.0") {
    Object.assign(merged, XPATH20_RESERVED_WORDS);
  }
  if (version === "3.0" || version === "3.1") {
    Object.assign(merged, XPATH30_RESERVED_WORDS);
  }
  if (version === "3.1") {
    Object.assign(merged, XPATH31_RESERVED_WORDS);
  }
  return merged;
}
var XPathLexer = class {
  /**
   * Create a new XPath lexer.
   *
   * @param versionOrOptions - Either an XPath version string ('1.0', '2.0', '3.0', '3.1')
   *                           or an options object with a version property.
   *                           Defaults to '1.0' for backward compatibility.
   *
   * @example
   * ```typescript
   * // All of these create an XPath 1.0 lexer:
   * const lexer1 = new XPathLexer();
   * const lexer2 = new XPathLexer('1.0');
   * const lexer3 = new XPathLexer({ version: '1.0' });
   *
   * // Create an XPath 2.0 lexer:
   * const lexer4 = new XPathLexer('2.0');
   * const lexer5 = new XPathLexer({ version: '2.0' });
   * ```
   */
  constructor(versionOrOptions) {
    var _a;
    if (typeof versionOrOptions === "object") {
      this.version = (_a = versionOrOptions.version) != null ? _a : DEFAULT_LEXER_VERSION;
    } else {
      this.version = versionOrOptions != null ? versionOrOptions : DEFAULT_LEXER_VERSION;
    }
    this.reservedWords = buildReservedWords(this.version);
  }
  /**
   * Get the XPath version this lexer is configured for.
   */
  getVersion() {
    return this.version;
  }
  /**
   * Register additional function names to be recognized by the lexer.
   * Used for XSLT extension functions.
   */
  registerFunctions(functionNames) {
    if (!this.additionalFunctions) {
      this.additionalFunctions = /* @__PURE__ */ new Set();
    }
    for (const name of functionNames) {
      this.additionalFunctions.add(name);
    }
  }
  /**
   * Check if character is a valid start of an identifier.
   * Supports Unicode letters according to XML NCName specification.
   */
  isAlpha(char) {
    return /^[a-zA-Z_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]$/.test(
      char
    );
  }
  /**
   * Check if character is valid in an identifier (after the first character).
   * Supports Unicode letters and digits according to XML NCName specification.
   * Note: Hyphen is handled separately in parseIdentifier for reserved words.
   */
  isAlphaNumeric(char) {
    return /^[a-zA-Z0-9_\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0300-\u036F\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]$/.test(
      char
    );
  }
  isNumber(char) {
    return /^[0-9]$/.test(char);
  }
  isWhitespace(char) {
    return /^[\s\t\n\r]$/.test(char);
  }
  peek() {
    return this.expression[this.current];
  }
  peekNext() {
    return this.expression[this.current + 1];
  }
  next() {
    return this.expression[this.current++];
  }
  match(expected) {
    if (this.current >= this.expression.length) return false;
    if (this.expression[this.current] !== expected) return false;
    this.current++;
    return true;
  }
  parseIdentifier(firstCharacter) {
    let characters = firstCharacter;
    while (this.current < this.expression.length) {
      const char = this.expression[this.current];
      if (this.isAlphaNumeric(char)) {
        characters += this.next();
      } else if (char === "-") {
        const nextChar = this.expression[this.current + 1];
        if (nextChar && this.isAlphaNumeric(nextChar)) {
          this.current++;
          characters += "-";
          while (this.current < this.expression.length && this.isAlphaNumeric(this.expression[this.current])) {
            characters += this.next();
          }
        } else {
          break;
        }
      } else {
        break;
      }
    }
    const likelyReservedWord = this.reservedWords[characters.toLowerCase()];
    if (likelyReservedWord) {
      return new XPathToken(likelyReservedWord.type, characters);
    }
    if (this.additionalFunctions && this.additionalFunctions.has(characters)) {
      return new XPathToken("FUNCTION", characters);
    }
    if (characters.length > 0) {
      return new XPathToken("IDENTIFIER", characters);
    }
    throw new Error(`Invalid identifier: ${characters}`);
  }
  parseString(quoteChar) {
    let value = "";
    while (this.current < this.expression.length && this.expression[this.current] !== quoteChar) {
      value += this.next();
    }
    if (this.current >= this.expression.length) {
      throw new Error(`Unterminated string literal`);
    }
    this.next();
    return new XPathToken("STRING", value);
  }
  /**
   * Parse string template: `Hello {$name}!`
   * Returns the entire template as-is for the parser to handle interpolation.
   */
  parseStringTemplate() {
    let value = "";
    let depth = 0;
    while (this.current < this.expression.length) {
      const char = this.expression[this.current];
      if (char === "\\" && this.current + 1 < this.expression.length) {
        const nextChar = this.expression[this.current + 1];
        if (nextChar === "`" || nextChar === "{" || nextChar === "}" || nextChar === "n" || nextChar === "r" || nextChar === "t" || nextChar === "\\") {
          value += char;
          this.next();
          value += this.next();
          continue;
        }
      }
      if (char === "`" && depth === 0) {
        this.next();
        return new XPathToken("STRING_TEMPLATE", value);
      }
      if (char === "{") {
        depth++;
      } else if (char === "}") {
        depth--;
      }
      value += this.next();
    }
    throw new Error("Unterminated string template");
  }
  parseNumber(firstCharacter) {
    let characters = firstCharacter;
    while (this.current < this.expression.length && this.isNumber(this.expression[this.current]) && this.expression[this.current] !== ".") {
      characters += this.next();
    }
    if (this.current < this.expression.length && this.expression[this.current] === ".") {
      characters += this.next();
      while (this.current < this.expression.length && this.isNumber(this.expression[this.current])) {
        characters += this.next();
      }
    }
    if (characters.length > 0) {
      return new XPathToken("NUMBER", characters);
    }
    throw new Error(`Invalid number: ${characters}`);
  }
  /**
   * Parse EQName (Expanded QName): Q{uri}local-name
   * XPath 3.0 syntax for directly specifying namespace URIs.
   * Example: Q{http://www.w3.org/2005/xpath-functions/math}pi
   */
  parseEQName() {
    this.next();
    let uri = "";
    while (this.current < this.expression.length && this.expression[this.current] !== "}") {
      uri += this.next();
    }
    if (this.current >= this.expression.length) {
      throw new Error(`Unterminated EQName: missing '}' after URI`);
    }
    this.next();
    let localName = "";
    if (this.current < this.expression.length && this.isAlpha(this.expression[this.current])) {
      while (this.current < this.expression.length) {
        const char = this.expression[this.current];
        if (this.isAlphaNumeric(char) || char === "-" || char === "_") {
          localName += this.next();
        } else {
          break;
        }
      }
    }
    if (localName.length === 0) {
      throw new Error(`EQName missing local name after '}': Q{${uri}}`);
    }
    const fullEQName = `Q{${uri}}${localName}`;
    return new XPathToken("EQNAME", fullEQName);
  }
  scanToken() {
    const char = this.next();
    if (this.isWhitespace(char)) {
      return null;
    }
    switch (char) {
      case "@":
        return new XPathToken("AT", char);
      case "$":
        return new XPathToken("DOLLAR", char);
      case "|":
        if (this.match("|")) {
          return new XPathToken("CONCAT", "||");
        }
        return new XPathToken("PIPE", char);
      case "#":
        return new XPathToken("HASH", char);
      case "{":
        return new XPathToken("OPEN_CURLY_BRACKET", char);
      case "}":
        return new XPathToken("CLOSE_CURLY_BRACKET", char);
      case "[":
        return new XPathToken("OPEN_SQUARE_BRACKET", char);
      case "]":
        return new XPathToken("CLOSE_SQUARE_BRACKET", char);
      case "(":
        return new XPathToken("OPEN_PAREN", char);
      case ")":
        return new XPathToken("CLOSE_PAREN", char);
      case "+":
        return new XPathToken("PLUS", char);
      case "-":
        return new XPathToken("MINUS", char);
      case "*":
        return new XPathToken("ASTERISK", char);
      case ",":
        return new XPathToken("COMMA", char);
      case "?":
        return new XPathToken("QUESTION", char);
      case "Q":
        if (this.peek() === "{") {
          return this.parseEQName();
        }
        return this.parseIdentifier(char);
      // Tokens that may be single or double character
      case ".":
        if (this.match(".")) {
          return new XPathToken("DOT_DOT", "..");
        }
        if (this.peek() && this.isNumber(this.peek())) {
          return this.parseNumber(char);
        }
        return new XPathToken("DOT", char);
      case "/":
        if (this.match("/")) {
          return new XPathToken("DOUBLE_SLASH", "//");
        }
        return new XPathToken("SLASH", char);
      case ":":
        if (this.match(":")) {
          return new XPathToken("COLON_COLON", "::");
        }
        if (this.match("=")) {
          return new XPathToken("ASSIGNMENT", ":=");
        }
        return new XPathToken("COLON", char);
      case "=":
        if (this.match(">")) {
          return new XPathToken("FAT_ARROW", "=>");
        }
        return new XPathToken("EQUALS", char);
      case "!":
        if (this.match("=")) {
          return new XPathToken("NOT_EQUALS", "!=");
        }
        return new XPathToken("SIMPLE_MAP", char);
      case "<":
        if (this.match("=")) {
          return new XPathToken("LESS_THAN_OR_EQUAL", "<=");
        }
        return new XPathToken("LESS_THAN", char);
      case ">":
        if (this.match("=")) {
          return new XPathToken("GREATER_THAN_OR_EQUAL", ">=");
        }
        return new XPathToken("GREATER_THAN", char);
      // String literals
      case "'":
        return this.parseString("'");
      case '"':
        return this.parseString('"');
      // String template (XPath 3.0+): `Hello {$name}!`
      case "`":
        return this.parseStringTemplate();
      default:
        if (this.isNumber(char)) {
          return this.parseNumber(char);
        }
        if (this.isAlpha(char)) {
          return this.parseIdentifier(char);
        }
        throw new Error(`Unexpected character: ${char}`);
    }
  }
  scan(expression) {
    this.expression = expression;
    this.tokens = [];
    this.current = 0;
    while (this.current < this.expression.length) {
      const token = this.scanToken();
      if (token !== null) {
        this.tokens.push(token);
      }
    }
    return this.tokens;
  }
};

// src/xpath/lib/src/parser/base-parser.ts
init_expressions();

// src/xpath/lib/src/static-context.ts
init_sequence_type();
init_constants();
var ensureDefaultCollationPresent = (collations, defaultCollation) => {
  const set = new Set(collations);
  if (!set.has(defaultCollation)) {
    collations.push(defaultCollation);
  }
  return Array.from(new Set(collations));
};
function createStaticContext(overrides) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const reserved = (overrides == null ? void 0 : overrides.reservedFunctionNames) ? new Set(overrides.reservedFunctionNames) : new Set(RESERVED_FUNCTION_NAMES);
  const defaultCollation = (_a = overrides == null ? void 0 : overrides.defaultCollation) != null ? _a : DEFAULT_COLLATION;
  const collations = ensureDefaultCollationPresent(
    (_b = overrides == null ? void 0 : overrides.collations) != null ? _b : [DEFAULT_COLLATION],
    defaultCollation
  );
  return {
    schemaTypes: (_c = overrides == null ? void 0 : overrides.schemaTypes) != null ? _c : {},
    elementDeclarations: (_d = overrides == null ? void 0 : overrides.elementDeclarations) != null ? _d : {},
    attributeDeclarations: (_e = overrides == null ? void 0 : overrides.attributeDeclarations) != null ? _e : {},
    defaultElementNamespace: (_f = overrides == null ? void 0 : overrides.defaultElementNamespace) != null ? _f : "",
    defaultTypeNamespace: (_g = overrides == null ? void 0 : overrides.defaultTypeNamespace) != null ? _g : XS_NAMESPACE,
    functionSignatures: (_h = overrides == null ? void 0 : overrides.functionSignatures) != null ? _h : {},
    defaultFunctionNamespace: (_i = overrides == null ? void 0 : overrides.defaultFunctionNamespace) != null ? _i : DEFAULT_FUNCTION_NAMESPACE,
    reservedFunctionNames: reserved,
    collations,
    defaultCollation,
    variableTypes: (_j = overrides == null ? void 0 : overrides.variableTypes) != null ? _j : {},
    contextItemType: overrides == null ? void 0 : overrides.contextItemType
  };
}

// src/xpath/lib/src/xslt-extensions.ts
function validateExtensions(extensions) {
  const errors = [];
  const functionNames = /* @__PURE__ */ new Set();
  for (const func of extensions.functions) {
    if (functionNames.has(func.name)) {
      errors.push(`Duplicate function name: ${func.name}`);
    }
    functionNames.add(func.name);
    if (func.minArgs < 0) {
      errors.push(`Function ${func.name}: minArgs cannot be negative`);
    }
    if (func.maxArgs !== void 0 && func.maxArgs < func.minArgs) {
      errors.push(`Function ${func.name}: maxArgs cannot be less than minArgs`);
    }
    if (typeof func.implementation !== "function") {
      errors.push(`Function ${func.name}: implementation must be a function`);
    }
  }
  return errors;
}

// src/xpath/lib/src/parser/base-parser.ts
init_errors();

// src/xpath/lib/src/warnings.ts
var WARNING_CODES = {
  // ========================================================================
  // DEPRECATION WARNINGS
  // ========================================================================
  XPWD0001: {
    code: "XPWD0001",
    severity: "deprecation",
    category: "deprecation",
    title: "Namespace axis deprecated",
    description: "The namespace axis (namespace::) is deprecated in XPath 2.0 and may not be supported in all implementations. Consider using fn:namespace-uri-for-prefix() or fn:in-scope-prefixes() instead.",
    migration: "Replace namespace::* with fn:in-scope-prefixes(.) to get namespace prefixes, or use fn:namespace-uri-for-prefix($prefix, .) to get namespace URIs.",
    specReference: "XPath 2.0 Section 3.2.1.1"
  },
  XPWD0002: {
    code: "XPWD0002",
    severity: "deprecation",
    category: "deprecation",
    title: "Implicit string conversion",
    description: "Implicit conversion of node-sets to strings using the first node is deprecated. In XPath 2.0, this requires explicit conversion using fn:string() or data().",
    migration: "Use fn:string($nodeset) or fn:data($nodeset) for explicit conversion.",
    specReference: "XPath 2.0 Appendix I.2"
  },
  // ========================================================================
  // COMPATIBILITY WARNINGS
  // ========================================================================
  XPWC0001: {
    code: "XPWC0001",
    severity: "warning",
    category: "compatibility",
    title: "XPath 1.0 compatibility mode active",
    description: "XPath 1.0 compatibility mode is enabled. Some XPath 2.0 type safety features are relaxed to maintain backward compatibility.",
    migration: "Consider migrating to XPath 2.0 semantics for improved type safety.",
    specReference: "XPath 2.0 Section 3.6"
  },
  XPWC0002: {
    code: "XPWC0002",
    severity: "warning",
    category: "compatibility",
    title: "String comparison in XPath 2.0",
    description: "String comparisons in XPath 2.0 are performed using Unicode codepoint collation by default, which may produce different results than XPath 1.0.",
    migration: "Use explicit collation specification if locale-specific comparison is needed.",
    specReference: "XPath 2.0 Appendix I.4"
  },
  XPWC0003: {
    code: "XPWC0003",
    severity: "warning",
    category: "compatibility",
    title: "Empty sequence handling differs",
    description: "In XPath 2.0, operations on empty sequences may return empty sequences instead of NaN or false as in XPath 1.0.",
    migration: "Use explicit empty sequence handling with fn:empty() or default values.",
    specReference: "XPath 2.0 Appendix I.3"
  },
  // ========================================================================
  // TYPE COERCION WARNINGS
  // ========================================================================
  XPWT0001: {
    code: "XPWT0001",
    severity: "warning",
    category: "type-coercion",
    title: "Implicit numeric conversion",
    description: "Value is being implicitly converted to a number. In XPath 2.0, this requires explicit conversion in strict mode.",
    migration: "Use xs:decimal(), xs:double(), or number() for explicit conversion.",
    specReference: "XPath 2.0 Appendix I.2"
  },
  XPWT0002: {
    code: "XPWT0002",
    severity: "warning",
    category: "type-coercion",
    title: "Implicit boolean conversion",
    description: "Value is being implicitly converted to boolean using XPath 1.0 rules. In XPath 2.0, this is called Effective Boolean Value (EBV).",
    migration: "Use fn:boolean() for explicit conversion.",
    specReference: "XPath 2.0 Section 2.4.3"
  },
  XPWT0003: {
    code: "XPWT0003",
    severity: "info",
    category: "type-coercion",
    title: "Numeric type promotion",
    description: "Numeric value is being promoted in the type hierarchy (integer \u2192 decimal \u2192 float \u2192 double). This may result in precision loss.",
    migration: "Consider using explicit casting if precision is important.",
    specReference: "XPath 2.0 Appendix B.1"
  },
  // ========================================================================
  // BEHAVIOR CHANGE WARNINGS
  // ========================================================================
  XPWB0001: {
    code: "XPWB0001",
    severity: "warning",
    category: "behavior-change",
    title: "Arithmetic with empty sequence",
    description: "In XPath 2.0, arithmetic operations with empty sequences return empty sequences, not NaN as in XPath 1.0.",
    migration: "Handle empty sequences explicitly before arithmetic operations.",
    specReference: "XPath 2.0 Appendix I.3"
  },
  XPWB0002: {
    code: "XPWB0002",
    severity: "warning",
    category: "behavior-change",
    title: "Comparison with empty sequence",
    description: "In XPath 2.0, value comparisons (eq, ne, etc.) with empty sequences return empty sequences, not false.",
    migration: "Use fn:empty() or fn:exists() to check for empty sequences before comparison.",
    specReference: "XPath 2.0 Appendix I.3"
  },
  XPWB0003: {
    code: "XPWB0003",
    severity: "warning",
    category: "behavior-change",
    title: "Multiple values in singleton context",
    description: "A sequence with multiple items is being used where a single item is expected. In XPath 2.0, this may raise a type error.",
    migration: "Use predicates or fn:head() to select a single item.",
    specReference: "XPath 2.0 Section 2.4.4"
  },
  XPWB0004: {
    code: "XPWB0004",
    severity: "warning",
    category: "behavior-change",
    title: "String value of nodes",
    description: "The string value of typed nodes in XPath 2.0 may differ from XPath 1.0 when schema type information is present.",
    migration: "Use fn:string() for consistent string conversion.",
    specReference: "XPath 2.0 Appendix I.1"
  },
  // ========================================================================
  // PERFORMANCE WARNINGS
  // ========================================================================
  XPWP0001: {
    code: "XPWP0001",
    severity: "info",
    category: "performance",
    title: "Descendant axis on large document",
    description: "Using descendant or descendant-or-self axis on large documents may impact performance. Consider using more specific path expressions.",
    migration: "Use more specific paths or indexes if available."
  },
  XPWP0002: {
    code: "XPWP0002",
    severity: "info",
    category: "performance",
    title: "General comparison on sequences",
    description: "General comparisons (=, !=, etc.) on sequences perform existential quantification, which may be slower than value comparisons on single items.",
    migration: "Use value comparisons (eq, ne, etc.) when comparing single values.",
    specReference: "XPath 2.0 Section 3.5.2"
  }
};
var DEFAULT_WARNING_CONFIG = {
  enabled: true,
  minSeverity: "info",
  suppressCategories: [],
  suppressCodes: [],
  handler: () => {
  },
  logToConsole: false,
  maxWarnings: 100,
  emitOnce: true
};
var SEVERITY_LEVELS = {
  info: 0,
  warning: 1,
  deprecation: 2
};
var WarningCollector = class {
  constructor(config) {
    this.warnings = [];
    this.emittedCodes = /* @__PURE__ */ new Set();
    this.config = __spreadValues(__spreadValues({}, DEFAULT_WARNING_CONFIG), config);
  }
  /**
   * Emit a warning by code
   */
  emit(code, context, expression) {
    if (!this.config.enabled) return;
    const metadata = WARNING_CODES[code];
    if (!metadata) {
      this.addWarning({
        code,
        message: `Unknown warning: ${code}`,
        severity: "warning",
        category: "compatibility",
        context,
        expression
      });
      return;
    }
    if (this.config.suppressCodes.includes(code)) return;
    if (this.config.suppressCategories.includes(metadata.category)) return;
    if (SEVERITY_LEVELS[metadata.severity] < SEVERITY_LEVELS[this.config.minSeverity]) {
      return;
    }
    if (this.config.emitOnce && this.emittedCodes.has(code)) return;
    if (this.warnings.length >= this.config.maxWarnings) return;
    const warning = {
      code: metadata.code,
      message: metadata.description,
      severity: metadata.severity,
      category: metadata.category,
      context,
      expression
    };
    this.addWarning(warning);
    this.emittedCodes.add(code);
  }
  /**
   * Emit a custom warning
   */
  emitCustom(warning) {
    if (!this.config.enabled) return;
    if (this.warnings.length >= this.config.maxWarnings) return;
    if (this.config.emitOnce && this.emittedCodes.has(warning.code)) return;
    this.addWarning(warning);
    this.emittedCodes.add(warning.code);
  }
  addWarning(warning) {
    this.warnings.push(warning);
    if (this.config.handler) {
      this.config.handler(warning);
    }
    if (this.config.logToConsole) {
      const prefix = warning.severity === "deprecation" ? "[DEPRECATED]" : warning.severity === "warning" ? "[WARNING]" : "[INFO]";
      console.warn(`${prefix} ${warning.code}: ${warning.message}`);
    }
  }
  /**
   * Get all collected warnings
   */
  getWarnings() {
    return this.warnings;
  }
  /**
   * Get warnings filtered by severity
   */
  getWarningsBySeverity(severity) {
    return this.warnings.filter((w) => w.severity === severity);
  }
  /**
   * Get warnings filtered by category
   */
  getWarningsByCategory(category) {
    return this.warnings.filter((w) => w.category === category);
  }
  /**
   * Check if any warnings were collected
   */
  hasWarnings() {
    return this.warnings.length > 0;
  }
  /**
   * Get count of warnings
   */
  count() {
    return this.warnings.length;
  }
  /**
   * Clear all collected warnings
   */
  clear() {
    this.warnings = [];
    this.emittedCodes.clear();
  }
  /**
   * Format warnings as a report string
   */
  formatReport() {
    if (this.warnings.length === 0) {
      return "No warnings.";
    }
    const lines = [];
    lines.push(
      `XPath Warnings Report (${this.warnings.length} warning${this.warnings.length === 1 ? "" : "s"}):`
    );
    lines.push("");
    const byCategory = {};
    for (const warning of this.warnings) {
      const category = warning.category;
      if (!byCategory[category]) {
        byCategory[category] = [];
      }
      byCategory[category].push(warning);
    }
    for (const category of Object.keys(byCategory)) {
      const warnings = byCategory[category];
      lines.push(`## ${formatCategoryName(category)}`);
      for (const warning of warnings) {
        const metadata = WARNING_CODES[warning.code];
        lines.push(`  ${warning.code}: ${(metadata == null ? void 0 : metadata.title) || warning.message}`);
        if (warning.context) {
          lines.push(`    Context: ${warning.context}`);
        }
        if (metadata == null ? void 0 : metadata.migration) {
          lines.push(`    Migration: ${metadata.migration}`);
        }
      }
      lines.push("");
    }
    return lines.join("\n");
  }
};
function formatCategoryName(category) {
  switch (category) {
    case "deprecation":
      return "Deprecated Features";
    case "compatibility":
      return "Compatibility Issues";
    case "performance":
      return "Performance Considerations";
    case "type-coercion":
      return "Type Coercion";
    case "behavior-change":
      return "Behavior Changes";
    default:
      return category;
  }
}
function createWarningCollector(config) {
  return new WarningCollector(config);
}

// src/xpath/lib/src/parser/base-parser.ts
var XPathBaseParser = class {
  /**
   * Create a new XPath parser.
   *
   * @param options Optional parser configuration including XSLT extensions
   */
  constructor(options) {
    this.tokens = [];
    this.current = 0;
    var _a, _b, _c, _d;
    this.options = {
      strict: (_a = options == null ? void 0 : options.strict) != null ? _a : true,
      version: options == null ? void 0 : options.version,
      cache: options == null ? void 0 : options.cache,
      extensions: options == null ? void 0 : options.extensions,
      enableNamespaceAxis: (_b = options == null ? void 0 : options.enableNamespaceAxis) != null ? _b : false,
      staticContext: (_c = options == null ? void 0 : options.staticContext) != null ? _c : createStaticContext(),
      xpath10CompatibilityMode: (_d = options == null ? void 0 : options.xpath10CompatibilityMode) != null ? _d : false,
      warningConfig: options == null ? void 0 : options.warningConfig,
      warningCollector: options == null ? void 0 : options.warningCollector
    };
    this.staticContext = this.options.staticContext;
    if (this.options.warningCollector) {
      this.warningCollector = this.options.warningCollector;
    } else if (this.options.warningConfig) {
      this.warningCollector = createWarningCollector(this.options.warningConfig);
    } else {
      this.warningCollector = createWarningCollector({ logToConsole: false });
    }
    if (this.options.extensions) {
      const errors = validateExtensions(this.options.extensions);
      if (errors.length > 0) {
        throw new Error(`Invalid XSLT extensions: ${errors.join(", ")}`);
      }
      this.extensions = this.options.extensions;
    }
  }
  /**
   * Get the warning collector for this parser.
   * Useful for retrieving warnings after parsing.
   */
  getWarningCollector() {
    return this.warningCollector;
  }
  /**
   * Enforce the supported XPath versions for a concrete parser.
   */
  ensureVersionSupport(supportedVersions, defaultVersion) {
    var _a;
    const resolvedVersion = (_a = this.options.version) != null ? _a : defaultVersion;
    this.options.version = resolvedVersion;
    if (this.options.strict !== false && !supportedVersions.includes(resolvedVersion)) {
      throw new Error(
        `XPath version ${resolvedVersion} is not supported by ${this.constructor.name}. Supported versions: ${supportedVersions.join(", ")}`
      );
    }
  }
  /**
   * Get the parser options.
   */
  getOptions() {
    return this.options;
  }
  parse(tokens) {
    this.tokens = tokens;
    this.current = 0;
    if (this.options.xpath10CompatibilityMode && this.options.version && this.options.version !== "1.0") {
      this.warningCollector.emit(
        "XPWC0001",
        `XPath ${this.options.version} with compatibility mode`,
        tokens.map((t) => t.lexeme).join("")
      );
    }
    if (tokens.length === 0) {
      throw grammarViolation("Empty expression");
    }
    const expr = this.parseExpr();
    if (!this.isAtEnd()) {
      throw grammarViolation(`Unexpected token: ${this.peek().lexeme}`);
    }
    return expr;
  }
  // ==================== Token Management ====================
  peek() {
    return this.tokens[this.current];
  }
  peekNext() {
    return this.tokens[this.current + 1];
  }
  previous() {
    return this.tokens[this.current - 1];
  }
  isAtEnd() {
    return this.current >= this.tokens.length;
  }
  advance() {
    if (!this.isAtEnd()) this.current++;
    return this.previous();
  }
  check(type) {
    if (this.isAtEnd()) return false;
    return this.peek().type === type;
  }
  checkLexeme(lexeme) {
    if (this.isAtEnd()) return false;
    return this.peek().lexeme === lexeme;
  }
  match(...types) {
    for (const type of types) {
      if (this.check(type)) {
        this.advance();
        return true;
      }
    }
    return false;
  }
  consume(type, message) {
    var _a, _b;
    if (this.check(type)) return this.advance();
    throw grammarViolation(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  // ==================== Expression Parsing ====================
  parseExpr() {
    return this.parseOrExpr();
  }
  parseOrExpr() {
    let left = this.parseAndExpr();
    while (this.check("OPERATOR") && this.peek().lexeme === "or") {
      this.advance();
      const right = this.parseAndExpr();
      left = new XPathLogicalExpression(left, right, "or");
    }
    return left;
  }
  parseAndExpr() {
    let left = this.parseEqualityExpr();
    while (this.check("OPERATOR") && this.peek().lexeme === "and") {
      this.advance();
      const right = this.parseEqualityExpr();
      left = new XPathLogicalExpression(left, right, "and");
    }
    return left;
  }
  parseEqualityExpr() {
    let left = this.parseRelationalExpr();
    while (this.match("EQUALS", "NOT_EQUALS")) {
      const operator = this.previous().lexeme;
      const right = this.parseRelationalExpr();
      left = new XPathBinaryExpression(left, right, operator);
    }
    return left;
  }
  parseRelationalExpr() {
    let left = this.parseAdditiveExpr();
    while (this.match("LESS_THAN", "GREATER_THAN", "LESS_THAN_OR_EQUAL", "GREATER_THAN_OR_EQUAL")) {
      const operator = this.previous().lexeme;
      const right = this.parseAdditiveExpr();
      left = new XPathBinaryExpression(left, right, operator);
    }
    return left;
  }
  parseAdditiveExpr() {
    let left = this.parseMultiplicativeExpr();
    while (this.match("PLUS", "MINUS")) {
      const operator = this.previous().lexeme;
      const right = this.parseMultiplicativeExpr();
      left = new XPathArithmeticExpression(left, right, operator);
    }
    return left;
  }
  parseMultiplicativeExpr() {
    let left = this.parseUnaryExpr();
    while (true) {
      if (this.match("ASTERISK")) {
        const right = this.parseUnaryExpr();
        left = new XPathArithmeticExpression(left, right, "*");
      } else if (this.check("OPERATOR") && (this.peek().lexeme === "div" || this.peek().lexeme === "mod")) {
        const operator = this.advance().lexeme;
        const right = this.parseUnaryExpr();
        left = new XPathArithmeticExpression(left, right, operator);
      } else {
        break;
      }
    }
    return left;
  }
  parseUnaryExpr() {
    if (this.match("MINUS")) {
      const operand = this.parseUnaryExpr();
      return new XPathUnaryExpression("-", operand);
    }
    return this.parseUnionExpr();
  }
  parseUnionExpr() {
    let left = this.parsePathExpr();
    while (this.match("PIPE")) {
      const right = this.parsePathExpr();
      left = new XPathUnionExpression(left, right);
    }
    return left;
  }
  // ==================== Path Expression Parsing ====================
  parsePathExpr() {
    if (this.check("SLASH") || this.check("DOUBLE_SLASH")) {
      return this.parseLocationPath();
    }
    if (this.isStepStart()) {
      return this.parseLocationPath();
    }
    let expr = this.parseFilterExpr();
    if (this.match("SLASH", "DOUBLE_SLASH")) {
      const isDescendant = this.previous().type === "DOUBLE_SLASH";
      const steps = this.parseRelativeLocationPath();
      if (isDescendant) {
        steps.unshift(
          new XPathStep("descendant-or-self", { type: "node-type", nodeType: "node" })
        );
      }
      const locationPath = new XPathLocationPath(steps, false);
      return new FilteredPathExpression(expr, locationPath);
    }
    return expr;
  }
  isStepStart() {
    if (this.isAtEnd()) return false;
    const token = this.peek();
    const next = this.peekNext();
    const nodeTestNames = [
      "element",
      "attribute",
      "schema-element",
      "schema-attribute",
      "document-node",
      "node",
      "text",
      "comment",
      "processing-instruction"
    ];
    if ((token.type === "IDENTIFIER" || token.type === "NODE_TYPE") && (next == null ? void 0 : next.type) === "OPEN_PAREN") {
      if (nodeTestNames.includes(token.lexeme.toLowerCase())) {
        return true;
      }
    }
    if (this.isFunctionCallStart()) return false;
    if (token.type === "DOT" || token.type === "DOT_DOT") return true;
    if (token.type === "AT") return true;
    if (token.type === "LOCATION") return true;
    if (token.type === "NODE_TYPE") return true;
    if (token.type === "ASTERISK") return true;
    if (token.type === "IDENTIFIER" || token.type === "OPERATOR" || token.type === "FUNCTION") {
      const next2 = this.peekNext();
      return !next2 || next2.type !== "OPEN_PAREN";
    }
    return false;
  }
  parseLocationPath() {
    let absolute = false;
    const steps = [];
    if (this.match("SLASH")) {
      absolute = true;
      if (!this.isAtEnd() && this.isStepStart()) {
        steps.push(...this.parseRelativeLocationPath());
      }
    } else if (this.match("DOUBLE_SLASH")) {
      absolute = true;
      steps.push(
        new XPathStep("descendant-or-self", { type: "node-type", nodeType: "node" })
      );
      steps.push(...this.parseRelativeLocationPath());
    } else {
      steps.push(...this.parseRelativeLocationPath());
    }
    return new XPathLocationPath(steps, absolute);
  }
  parseRelativeLocationPath() {
    const steps = [];
    steps.push(this.parseStep());
    while (this.match("SLASH", "DOUBLE_SLASH")) {
      const isDescendant = this.previous().type === "DOUBLE_SLASH";
      if (isDescendant) {
        steps.push(
          new XPathStep("descendant-or-self", { type: "node-type", nodeType: "node" })
        );
      }
      steps.push(this.parseStep());
    }
    return steps;
  }
  parseStep() {
    if (this.match("DOT")) {
      return new XPathStep("self", { type: "node-type", nodeType: "node" });
    }
    if (this.match("DOT_DOT")) {
      return new XPathStep("parent", { type: "node-type", nodeType: "node" });
    }
    let axis = "child";
    if (this.match("AT")) {
      axis = "attribute";
    } else if (this.check("LOCATION")) {
      const next = this.peekNext();
      if (next && next.type === "COLON_COLON") {
        axis = this.advance().lexeme;
        this.advance();
      }
    }
    if (axis === "namespace") {
      if (!this.options.enableNamespaceAxis) {
        throw unsupportedAxis("namespace");
      }
      this.warnNamespaceAxis();
    }
    const nodeTest = this.parseNodeTest();
    const predicates = this.parsePredicates();
    return new XPathStep(axis, nodeTest, predicates);
  }
  parseNodeTest() {
    var _a, _b;
    if (this.match("ASTERISK")) {
      return { type: "wildcard" };
    }
    if (this.check("NODE_TYPE") || this.check("IDENTIFIER") || this.check("LOCATION") || this.check("FUNCTION") || this.check("OPERATOR")) {
      const next = this.peekNext();
      if (next && next.type === "OPEN_PAREN") {
        const testName = this.advance().lexeme.toLowerCase();
        this.advance();
        if (testName === "element") {
          return this.parseElementTest();
        }
        if (testName === "attribute") {
          return this.parseAttributeTest();
        }
        if (testName === "document-node") {
          return this.parseDocumentNodeTest();
        }
        if (testName === "schema-element") {
          const name = this.parseNameOrWildcard();
          this.consume("CLOSE_PAREN", "Expected ')' after schema-element name");
          return { type: "schema-element", name };
        }
        if (testName === "schema-attribute") {
          const name = this.parseNameOrWildcard();
          this.consume("CLOSE_PAREN", "Expected ')' after schema-attribute name");
          return { type: "schema-attribute", name };
        }
        if (testName === "node" || testName === "text" || testName === "comment" || testName === "processing-instruction") {
          if (testName === "processing-instruction" && this.check("STRING")) {
            const target = this.advance().lexeme;
            this.consume(
              "CLOSE_PAREN",
              "Expected ')' after processing-instruction target"
            );
            return { type: "processing-instruction", target };
          }
          this.consume("CLOSE_PAREN", "Expected ')' after node type");
          return {
            type: "node-type",
            nodeType: testName
          };
        }
      }
    }
    if (this.check("IDENTIFIER") || this.check("LOCATION") || this.check("FUNCTION") || this.check("NODE_TYPE") || this.check("OPERATOR")) {
      const name = this.advance().lexeme;
      if (this.match("COLON")) {
        if (this.match("ASTERISK")) {
          return { type: "wildcard", name: `${name}:*` };
        }
        if (this.check("IDENTIFIER") || this.check("LOCATION") || this.check("FUNCTION") || this.check("NODE_TYPE") || this.check("OPERATOR")) {
          const localName = this.advance().lexeme;
          return { type: "name", name: `${name}:${localName}` };
        }
        throw new Error("Expected local name after namespace prefix");
      }
      return { type: "name", name };
    }
    throw grammarViolation(`Expected node test, got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  parsePredicates() {
    const predicates = [];
    while (this.match("OPEN_SQUARE_BRACKET")) {
      const expr = this.parseExpr();
      this.consume("CLOSE_SQUARE_BRACKET", "Expected ']' after predicate");
      predicates.push(new XPathPredicate(expr));
    }
    return predicates;
  }
  // ==================== Filter Expression Parsing ====================
  parseFilterExpr() {
    let expr = this.parsePrimaryExpr();
    const predicates = [];
    while (this.check("OPEN_SQUARE_BRACKET")) {
      predicates.push(...this.parsePredicates());
    }
    if (predicates.length > 0) {
      return new XPathFilterExpression(expr, predicates);
    }
    return expr;
  }
  parsePrimaryExpr() {
    var _a, _b;
    if (this.match("DOLLAR")) {
      const name = this.consume("IDENTIFIER", "Expected variable name after $").lexeme;
      return new XPathVariableReference(name);
    }
    if (this.match("OPEN_PAREN")) {
      if (this.check("CLOSE_PAREN")) {
        this.advance();
        return new EmptySequenceExpression();
      }
      const expr = this.parseExpr();
      this.consume("CLOSE_PAREN", "Expected ')' after expression");
      return expr;
    }
    if (this.check("STRING")) {
      const value = this.advance().lexeme;
      return new XPathStringLiteral(value);
    }
    if (this.check("NUMBER")) {
      const value = parseFloat(this.advance().lexeme);
      return new XPathNumberLiteral(value);
    }
    if (this.isFunctionCallStart()) {
      return this.parseFunctionCall();
    }
    throw grammarViolation(
      `Unexpected token in primary expression: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`
    );
  }
  parseFunctionCall() {
    let name = this.advance().lexeme;
    if (name.startsWith("Q{")) {
      this.consume("OPEN_PAREN", "Expected '(' after function name");
    } else if (this.match("COLON")) {
      const local = this.advance();
      if (!this.isNcNameToken(local.type)) {
        throw grammarViolation("Expected local name after namespace prefix");
      }
      name = `${name}:${local.lexeme}`;
    }
    if (!name.startsWith("Q{")) {
      this.consume("OPEN_PAREN", "Expected '(' after function name");
    }
    const args = [];
    if (!this.check("CLOSE_PAREN")) {
      do {
        args.push(this.parseExpr());
      } while (this.match("COMMA"));
    }
    this.consume("CLOSE_PAREN", "Expected ')' after function arguments");
    return new XPathFunctionCall(name, args);
  }
  isFunctionCallStart() {
    var _a, _b, _c;
    if (this.isAtEnd()) return false;
    const first = this.peek();
    const second = this.peekNext();
    const nodeTestNames = [
      "element",
      "attribute",
      "schema-element",
      "schema-attribute",
      "document-node",
      "node",
      "text",
      "comment",
      "processing-instruction"
    ];
    const isNodeTestName = nodeTestNames.includes((_c = (_b = (_a = first.lexeme) == null ? void 0 : _a.toLowerCase) == null ? void 0 : _b.call(_a)) != null ? _c : "");
    if (first.type === "EQNAME" && (second == null ? void 0 : second.type) === "OPEN_PAREN") {
      return true;
    }
    if (this.isFunctionNameToken(first.type) && (second == null ? void 0 : second.type) === "OPEN_PAREN") {
      if (isNodeTestName) return false;
      return true;
    }
    if (this.isFunctionNameToken(first.type) && (second == null ? void 0 : second.type) === "COLON") {
      const local = this.tokens[this.current + 2];
      const afterLocal = this.tokens[this.current + 3];
      if (local && this.isFunctionNameToken(local.type) && (afterLocal == null ? void 0 : afterLocal.type) === "OPEN_PAREN") {
        return true;
      }
    }
    return false;
  }
  /**
   * Emit deprecation warning for namespace axis usage.
   */
  warnNamespaceAxis() {
    this.warningCollector.emit(
      "XPWD0001",
      "namespace:: axis",
      this.tokens.map((t) => t.lexeme).join("")
    );
  }
  isFunctionNameToken(type) {
    return type === "IDENTIFIER" || type === "FUNCTION" || type === "OPERATOR" || type === "LOCATION" || type === "EQNAME";
  }
  isNcNameToken(type) {
    return type === "IDENTIFIER" || type === "FUNCTION" || type === "OPERATOR" || type === "LOCATION" || type === "NODE_TYPE";
  }
  parseNameOrWildcard() {
    let name = "";
    if (this.match("ASTERISK")) {
      return "*";
    }
    if (this.check("EQNAME")) {
      return this.advance().lexeme;
    }
    if (this.check("IDENTIFIER") || this.check("NODE_TYPE") || this.check("FUNCTION") || this.check("LOCATION") || this.check("OPERATOR")) {
      name = this.advance().lexeme;
      if (this.match("COLON")) {
        if (this.match("ASTERISK")) {
          return `${name}:*`;
        }
        if (this.check("IDENTIFIER") || this.check("NODE_TYPE") || this.check("FUNCTION") || this.check("LOCATION") || this.check("OPERATOR")) {
          name += ":" + this.advance().lexeme;
        }
      }
    }
    return name;
  }
  parseElementTest() {
    if (this.check("CLOSE_PAREN")) {
      this.advance();
      return { type: "element" };
    }
    const name = this.parseNameOrWildcard();
    let elementType;
    if (this.match("COMMA")) {
      if (this.check("IDENTIFIER") || this.check("NODE_TYPE") || this.check("FUNCTION") || this.check("LOCATION")) {
        elementType = this.parseNameOrWildcard();
      }
    }
    this.consume("CLOSE_PAREN", "Expected ')' after element test");
    return {
      type: "element",
      name: name === "*" ? void 0 : name,
      elementType,
      isWildcardName: name === "*"
    };
  }
  parseAttributeTest() {
    if (this.check("CLOSE_PAREN")) {
      this.advance();
      return { type: "attribute" };
    }
    const name = this.parseNameOrWildcard();
    let elementType;
    if (this.match("COMMA")) {
      if (this.check("IDENTIFIER") || this.check("NODE_TYPE") || this.check("FUNCTION") || this.check("LOCATION")) {
        elementType = this.parseNameOrWildcard();
      }
    }
    this.consume("CLOSE_PAREN", "Expected ')' after attribute test");
    return {
      type: "attribute",
      name: name === "*" ? void 0 : name,
      elementType,
      isWildcardName: name === "*"
    };
  }
  parseDocumentNodeTest() {
    if (this.check("CLOSE_PAREN")) {
      this.advance();
      return { type: "document-node" };
    }
    const elementTest = this.parseNodeTest();
    this.consume("CLOSE_PAREN", "Expected ')' after document-node test");
    return {
      type: "document-node",
      elementTest
    };
  }
};

// src/xpath/lib/src/parser/parser-10.ts
var XPath10Parser = class extends XPathBaseParser {
  constructor(options) {
    super(options);
    this.ensureVersionSupport(["1.0"], "1.0");
  }
};

// src/xpath/lib/src/parser/parser-20.ts
init_expressions();
init_types();
var XPath20Parser = class extends XPathBaseParser {
  constructor(options) {
    super(options);
    this.ensureVersionSupport(["2.0", "3.0", "3.1"], "2.0");
  }
  parseExpr() {
    if (this.checkReservedWord("for")) {
      return this.parseForExpr();
    }
    if (this.checkReservedWord("some") || this.checkReservedWord("every")) {
      return this.parseQuantifiedExpr();
    }
    return super.parseExpr();
  }
  parseUnionExpr() {
    let left = this.parseInstanceOfExpr();
    while (this.match("PIPE")) {
      const right = this.parseInstanceOfExpr();
      left = new XPathUnionExpression(left, right);
    }
    return left;
  }
  parsePrimaryExpr() {
    var _a, _b;
    if (this.check("RESERVED_WORD") && this.peek().lexeme === "if") {
      return this.parseIfExpr();
    }
    if (this.check("DOLLAR")) {
      this.advance();
      if (!this.isNameToken()) {
        throw new Error(`Expected variable name after $. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
      }
      const name = this.advance().lexeme;
      return new XPathVariableReference(name);
    }
    return super.parsePrimaryExpr();
  }
  parseInstanceOfExpr() {
    let expr = this.parseTreatExpr();
    if (this.checkReservedWord("instance")) {
      this.advance();
      this.consumeReservedWord("of", "Expected 'of' after 'instance'");
      const sequenceType = this.parseSequenceType();
      expr = new XPathInstanceOfExpression(expr, sequenceType);
    }
    return expr;
  }
  parseTreatExpr() {
    let expr = this.parseCastableExpr();
    if (this.checkReservedWord("treat")) {
      this.advance();
      this.consumeReservedWord("as", "Expected 'as' after 'treat'");
      const sequenceType = this.parseSequenceType();
      expr = new XPathTreatExpression(expr, sequenceType);
    }
    return expr;
  }
  parseCastableExpr() {
    let expr = this.parsePathExpr();
    if (this.checkReservedWord("castable")) {
      this.advance();
      this.consumeReservedWord("as", "Expected 'as' after 'castable'");
      const sequenceType = this.parseSequenceType();
      expr = new XPathCastableExpression(expr, sequenceType);
    }
    return expr;
  }
  parseIfExpr() {
    this.advance();
    this.consume("OPEN_PAREN", "Expected '(' after 'if'");
    const testExpr = this.parseExpr();
    this.consume("CLOSE_PAREN", "Expected ')' after if test expression");
    if (!(this.check("RESERVED_WORD") && this.peek().lexeme === "then")) {
      throw new Error("Expected 'then' in conditional expression");
    }
    this.advance();
    const thenExpr = this.parseExpr();
    if (!(this.check("RESERVED_WORD") && this.peek().lexeme === "else")) {
      throw new Error("Expected 'else' in conditional expression");
    }
    this.advance();
    const elseExpr = this.parseExpr();
    return new XPathConditionalExpression(testExpr, thenExpr, elseExpr);
  }
  parseQuantifiedExpr() {
    const quantifier = this.consumeReservedWordOneOf(
      ["some", "every"],
      "Expected 'some' or 'every' at start of quantified expression"
    );
    const bindings = [];
    do {
      bindings.push(this.parseForBinding());
    } while (this.match("COMMA"));
    this.consumeReservedWord(
      "satisfies",
      "Expected 'satisfies' after quantified expression bindings"
    );
    const satisfiesExpr = this.parseExpr();
    return new XPathQuantifiedExpression(quantifier, bindings, satisfiesExpr);
  }
  parseForExpr() {
    this.consumeReservedWord("for", "Expected 'for' at start of for expression");
    const bindings = [];
    do {
      bindings.push(this.parseForBinding());
    } while (this.match("COMMA"));
    this.consumeReservedWord("return", "Expected 'return' in for expression");
    const returnExpr = this.parseExpr();
    return new XPathForExpression(bindings, returnExpr);
  }
  parseForBinding() {
    this.consume("DOLLAR", "Expected '$' after 'for'");
    const name = this.consume("IDENTIFIER", "Expected variable name in for binding").lexeme;
    this.consumeReservedWord("in", "Expected 'in' after variable name in for clause");
    const expression = this.parseExpr();
    return { variable: name, expression };
  }
  parseSequenceType() {
    if (this.checkName("empty-sequence")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after empty-sequence");
      this.consume("CLOSE_PAREN", "Expected ')' after empty-sequence");
      return createEmptySequenceType();
    }
    if (this.checkName("item")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after item");
      this.consume("CLOSE_PAREN", "Expected ')' after item()");
      const occurrence2 = this.parseOccurrenceIndicator();
      return createItemSequenceType(ITEM_TYPE, occurrence2);
    }
    if (this.checkName("map")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after map");
      let keyType = null;
      let valueType = null;
      if (this.match("ASTERISK")) {
        this.consume("CLOSE_PAREN", "Expected ')' after map(*)");
      } else {
        keyType = this.parseSequenceType();
        this.consume("COMMA", "Expected ',' after key type in map()");
        valueType = this.parseSequenceType();
        this.consume("CLOSE_PAREN", "Expected ')' after map type");
      }
      const occurrence2 = this.parseOccurrenceIndicator();
      const { createTypedMapTest: createTypedMapTest2 } = (init_typed_collection_types(), __toCommonJS(typed_collection_types_exports));
      const mapItemType = createTypedMapTest2(keyType, valueType);
      return createItemSequenceType(mapItemType, occurrence2);
    }
    if (this.checkName("array")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after array");
      let memberType = null;
      if (this.match("ASTERISK")) {
        this.consume("CLOSE_PAREN", "Expected ')' after array(*)");
      } else {
        memberType = this.parseSequenceType();
        this.consume("CLOSE_PAREN", "Expected ')' after array type");
      }
      const occurrence2 = this.parseOccurrenceIndicator();
      const { createTypedArrayTest: createTypedArrayTest2 } = (init_typed_collection_types(), __toCommonJS(typed_collection_types_exports));
      const arrayItemType = createTypedArrayTest2(memberType);
      return createItemSequenceType(arrayItemType, occurrence2);
    }
    const qname = this.parseQName();
    const occurrence = this.parseOccurrenceIndicator();
    const localName = this.stripPrefix(qname);
    const atomicType = getAtomicType(localName);
    if (!atomicType) {
      throw new Error(`Unknown atomic type: ${qname}`);
    }
    return createAtomicSequenceType(atomicType, occurrence);
  }
  /**
   * Override parseAdditiveExpr to insert range expression (to) parsing.
   * Precedence: AdditiveExpr -> RangeExpr -> MultiplicativeExpr
   */
  parseAdditiveExpr() {
    let left = this.parseRangeExpr();
    while (this.match("PLUS", "MINUS")) {
      const operator = this.previous().lexeme;
      const right = this.parseRangeExpr();
      left = new (init_expressions(), __toCommonJS(expressions_exports)).XPathArithmeticExpression(left, right, operator);
    }
    return left;
  }
  /**
   * Parse range expression (to).
   * Syntax: expr to expr
   * Returns a sequence of consecutive integers from start to end.
   */
  parseRangeExpr() {
    let left = this.parseMultiplicativeExpr();
    if (this.checkReservedWord("to")) {
      this.advance();
      const right = this.parseMultiplicativeExpr();
      left = new RangeExpression(left, right);
    }
    return left;
  }
  parseOccurrenceIndicator() {
    if (this.match("QUESTION")) return "?" /* ZERO_OR_ONE */;
    if (this.match("ASTERISK")) return "*" /* ZERO_OR_MORE */;
    if (this.match("PLUS")) return "+" /* ONE_OR_MORE */;
    return "ONE" /* EXACTLY_ONE */;
  }
  parseQName() {
    const first = this.consumeNameToken("Expected type name in SequenceType");
    if (this.match("COLON")) {
      const local = this.consumeNameToken(
        "Expected local name after : in SequenceType"
      ).lexeme;
      return `${first.lexeme}:${local}`;
    }
    return first.lexeme;
  }
  stripPrefix(qname) {
    const parts = qname.split(":");
    return parts.length === 2 ? parts[1] : parts[0];
  }
  consumeNameToken(message) {
    var _a, _b;
    if (this.isNameToken()) {
      return this.advance();
    }
    throw new Error(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  isNameToken() {
    if (this.isAtEnd()) return false;
    const type = this.peek().type;
    return type === "IDENTIFIER" || type === "FUNCTION" || type === "NODE_TYPE" || type === "OPERATOR" || type === "LOCATION" || type === "RESERVED_WORD";
  }
  checkName(name) {
    return this.isNameToken() && this.peek().lexeme === name;
  }
  checkReservedWord(word) {
    return this.check("RESERVED_WORD") && this.peek().lexeme === word;
  }
  consumeReservedWord(word, message) {
    var _a, _b;
    if (this.checkReservedWord(word)) {
      this.advance();
      return;
    }
    throw new Error(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  consumeReservedWordOneOf(words, message) {
    var _a, _b;
    for (const word of words) {
      if (this.checkReservedWord(word)) {
        this.advance();
        return word;
      }
    }
    throw new Error(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
};

// src/xpath/lib/src/parser/parser-30.ts
init_expressions();
init_let_expression();
init_simple_map_expression();
init_string_concat_expression();
init_string_template_expression();
init_arrow_expression();
init_named_function_ref_expression();
init_inline_function_expression();
init_dynamic_function_call_expression();
init_types();
init_errors();
var XPath30Parser = class extends XPath20Parser {
  constructor(options) {
    const opts = options ? __spreadValues({}, options) : {};
    if (!opts.version) {
      opts.version = "3.0";
    }
    super(opts);
    this.ensureVersionSupport(["3.0", "3.1"], "3.0");
  }
  /**
   * Override parseExpr to handle:
   * 1. Let expressions: let $x := expr return expr
   * 2. Sequence construction: expr, expr, expr (comma operator)
   */
  parseExpr() {
    if (this.checkReservedWordInternal("let")) {
      return this.parseLetExpr();
    }
    const first = this.parseExprSingle();
    if (this.check("COMMA")) {
      const operands = [first];
      while (this.match("COMMA")) {
        operands.push(this.parseExprSingle());
      }
      return new CommaExpression(operands);
    }
    return first;
  }
  /**
   * Parse a single expression (not comma-separated).
   */
  parseExprSingle() {
    if (this.checkReservedWordInternal("let")) {
      return this.parseLetExpr();
    }
    return super.parseExpr();
  }
  /**
   * Override parseAdditiveExpr to insert string concatenation (||) parsing.
   * Precedence: || is between comparison and additive
   */
  parseAdditiveExpr() {
    let left = this.parseStringConcatExpr();
    while (this.match("PLUS", "MINUS")) {
      const operator = this.previous().lexeme;
      const right = this.parseStringConcatExpr();
      left = new (init_expressions(), __toCommonJS(expressions_exports)).XPathArithmeticExpression(left, right, operator);
    }
    return left;
  }
  /**
   * Parse string concatenation expression (||).
   * Syntax: expr || expr
   */
  parseStringConcatExpr() {
    let left = this.parseRangeExpr();
    while (this.match("CONCAT")) {
      const right = this.parseRangeExpr();
      left = new XPathStringConcatExpression(left, right);
    }
    return left;
  }
  /**
   * Override parseUnionExpr to insert simple map operator (!) parsing.
   * Precedence: ! is just above union (|)
   */
  parseUnionExpr() {
    let left = this.parseSimpleMapExpr();
    while (this.match("PIPE")) {
      const right = this.parseSimpleMapExpr();
      left = new (init_expressions(), __toCommonJS(expressions_exports)).XPathUnionExpression(left, right);
    }
    return left;
  }
  /**
   * Parse simple map expression (!).
   * Syntax: expr ! expr
   * Evaluates left expression, then for each item evaluates right with that item as context.
   */
  parseSimpleMapExpr() {
    let left = this.parseInstanceOfExprInternal();
    while (this.match("SIMPLE_MAP")) {
      const right = this.parseInstanceOfExprInternal();
      left = new XPathSimpleMapExpression(left, right);
    }
    return left;
  }
  /**
   * Internal method to parse instance-of expression level.
   * This replaces the protected method from XPath20Parser for our precedence chain.
   */
  parseInstanceOfExprInternal() {
    let expr = this.parseTreatExprInternal();
    if (this.checkReservedWordInternal("instance")) {
      this.advance();
      this.consumeReservedWordInternal("of", "Expected 'of' after 'instance'");
      const sequenceType = this.parseSequenceTypeInternal();
      expr = new (init_expressions(), __toCommonJS(expressions_exports)).XPathInstanceOfExpression(expr, sequenceType);
    }
    return expr;
  }
  /**
   * Internal method to parse treat expression level.
   */
  parseTreatExprInternal() {
    let expr = this.parseCastableExprInternal();
    if (this.checkReservedWordInternal("treat")) {
      this.advance();
      this.consumeReservedWordInternal("as", "Expected 'as' after 'treat'");
      const sequenceType = this.parseSequenceTypeInternal();
      expr = new (init_expressions(), __toCommonJS(expressions_exports)).XPathTreatExpression(expr, sequenceType);
    }
    return expr;
  }
  /**
   * Internal method to parse castable expression level.
   */
  parseCastableExprInternal() {
    let expr = this.parseArrowExpr();
    if (this.checkReservedWordInternal("castable")) {
      this.advance();
      this.consumeReservedWordInternal("as", "Expected 'as' after 'castable'");
      const sequenceType = this.parseSequenceTypeInternal();
      expr = new (init_expressions(), __toCommonJS(expressions_exports)).XPathCastableExpression(expr, sequenceType);
    }
    return expr;
  }
  /**
   * Parse arrow expression (=>).
   * Syntax: expr => func(args) => func2(args)
   * $x => f($y) is equivalent to f($x, $y)
   */
  parseArrowExpr() {
    let left = this.parsePathExpr();
    while (this.match("FAT_ARROW")) {
      let funcExpr;
      let args = [];
      if (this.check("DOLLAR")) {
        this.advance();
        const varName = this.consume("IDENTIFIER", "Expected variable name after $").lexeme;
        funcExpr = new XPathVariableReference(varName);
        this.consume(
          "OPEN_PAREN",
          "Expected '(' after function variable in arrow expression"
        );
        if (!this.check("CLOSE_PAREN")) {
          do {
            args.push(this.parseExprSingle());
          } while (this.match("COMMA"));
        }
        this.consume("CLOSE_PAREN", "Expected ')' after arrow expression arguments");
        left = new XPathDynamicFunctionCall(funcExpr, [left, ...args]);
      } else {
        let name = this.advance().lexeme;
        if (this.match("COLON")) {
          const local = this.advance();
          name = `${name}:${local.lexeme}`;
        }
        this.consume("OPEN_PAREN", "Expected '(' after function name in arrow expression");
        if (!this.check("CLOSE_PAREN")) {
          do {
            args.push(this.parseExprSingle());
          } while (this.match("COMMA"));
        }
        this.consume("CLOSE_PAREN", "Expected ')' after arrow expression arguments");
        left = new XPathArrowExpression(left, name, args);
      }
    }
    return left;
  }
  /**
   * Override parseFunctionCall to use parseExprSingle for arguments.
   *
   * In XPath 3.0, function arguments are ExprSingle, not Expr.
   * This means commas in arguments don't create sequences at the function level.
   * For example: concat("Hello ", $name) should parse as two arguments,
   * not one argument that is a sequence of two items.
   */
  parseFunctionCall() {
    let name = this.advance().lexeme;
    if (this.match("COLON")) {
      const local = this.advance();
      name = `${name}:${local.lexeme}`;
    }
    this.consume("OPEN_PAREN", "Expected '(' after function name");
    const args = [];
    if (!this.check("CLOSE_PAREN")) {
      do {
        args.push(this.parseExprSingle());
      } while (this.match("COMMA"));
    }
    this.consume("CLOSE_PAREN", "Expected ')' after function arguments");
    return new XPathFunctionCall(name, args);
  }
  /**
   * Override parsePrimaryExpr to handle:
   * - Variable references with any name (including function names like 'name')
   * - Named function references (fn:name#arity)
   * - Inline functions (function($x) { expr })
   * - String templates (`Hello {$name}!`)
   */
  parsePrimaryExpr() {
    if (this.check("STRING_TEMPLATE")) {
      const template = this.advance().lexeme;
      return this.parseStringTemplateFromLexeme(template);
    }
    if (this.match("DOLLAR")) {
      const nameToken = this.consumeNameTokenInternal("Expected variable name after $");
      return new XPathVariableReference(nameToken.lexeme);
    }
    if (this.checkReservedWordInternal("function")) {
      return this.parseInlineFunction();
    }
    if (this.isFunctionRefStart()) {
      return this.parseNamedFunctionRef();
    }
    return super.parsePrimaryExpr();
  }
  /**
   * Override isStepStart to exclude function references.
   * In XPath 3.0, name#arity is a function reference, not a location step.
   */
  isStepStart() {
    if (this.isFunctionRefStart()) {
      return false;
    }
    return super.isStepStart();
  }
  /**
   * Override parseFilterExpr to handle dynamic function calls.
   * In XPath 3.0, any primary expression followed by '(' is a dynamic function call.
   * Syntax: $func(args), (inline-function)(args), etc.
   */
  parseFilterExpr() {
    let expr = this.parsePrimaryExpr();
    if (this.check("OPEN_PAREN")) {
      this.advance();
      const args = [];
      if (!this.check("CLOSE_PAREN")) {
        do {
          args.push(this.parseExprSingle());
        } while (this.match("COMMA"));
      }
      this.consume("CLOSE_PAREN", "Expected ')' after function arguments");
      expr = new XPathDynamicFunctionCall(expr, args);
    }
    const predicates = [];
    while (this.check("OPEN_SQUARE_BRACKET")) {
      predicates.push(...this.parsePredicates());
    }
    if (predicates.length > 0) {
      const XPathFilterExpression2 = (init_expressions(), __toCommonJS(expressions_exports)).XPathFilterExpression;
      return new XPathFilterExpression2(expr, predicates);
    }
    return expr;
  }
  /**
   * Check if this looks like a function reference (name#arity).
   * Handles names with hyphens like upper-case#1 or prefix:upper-case#1
   * Also handles EQNames like Q{uri}name#1
   */
  isFunctionRefStart() {
    if (this.isAtEnd()) return false;
    const token = this.peek();
    if (token.type === "EQNAME") {
      const next = this.peekNext();
      return (next == null ? void 0 : next.type) === "HASH";
    }
    if (token.type === "IDENTIFIER" || token.type === "FUNCTION" || token.type === "OPERATOR" || token.type === "LOCATION") {
      let lookAhead = 1;
      let foundHash = false;
      while (lookAhead < this.tokens.length - this.current) {
        const tok = this.tokens[this.current + lookAhead];
        if (!tok) break;
        if (tok.type === "HASH") {
          foundHash = true;
          break;
        }
        const isValidQNameChar = tok.type === "MINUS" || tok.type === "COLON" || tok.type === "IDENTIFIER" || tok.type === "FUNCTION" || tok.type === "OPERATOR" || tok.type === "LOCATION" || tok.type === "NODE_TYPE";
        if (isValidQNameChar) {
          lookAhead++;
        } else {
          break;
        }
      }
      return foundHash;
    }
    return false;
  }
  /**
   * Parse named function reference: fn:name#arity or upper-case#arity
   * Handles hyphenated names and QNames.
   */
  parseNamedFunctionRef() {
    let name = this.advance().lexeme;
    while (!this.isAtEnd() && !this.check("HASH")) {
      if (this.match("MINUS") || this.match("COLON")) {
        const op = this.previous().lexeme;
        const nextToken = this.peek();
        if (nextToken && (nextToken.type === "IDENTIFIER" || nextToken.type === "FUNCTION" || nextToken.type === "OPERATOR" || nextToken.type === "LOCATION" || nextToken.type === "NODE_TYPE")) {
          this.advance();
          name = `${name}${op}${nextToken.lexeme}`;
        } else {
          throw grammarViolation(`Expected name after '${op}' in function reference`);
        }
      } else {
        break;
      }
    }
    this.consume("HASH", "Expected '#' in function reference");
    const arityToken = this.consume("NUMBER", "Expected arity number after '#'");
    const arity = parseInt(arityToken.lexeme, 10);
    if (isNaN(arity) || arity < 0) {
      throw grammarViolation(`Invalid function arity: ${arityToken.lexeme}`);
    }
    return new XPathNamedFunctionRef(name, arity);
  }
  /**
   * Parse inline function: function($x as xs:integer, $y) as xs:integer { $x + $y }
   */
  parseInlineFunction() {
    this.advance();
    this.consume("OPEN_PAREN", "Expected '(' after 'function'");
    const params = [];
    if (!this.check("CLOSE_PAREN")) {
      do {
        this.consume("DOLLAR", "Expected '$' before parameter name");
        const paramName = this.consume("IDENTIFIER", "Expected parameter name").lexeme;
        let paramType;
        if (this.checkReservedWordInternal("as")) {
          this.advance();
          paramType = this.parseSequenceTypeInternal();
        }
        params.push({ name: paramName, type: paramType });
      } while (this.match("COMMA"));
    }
    this.consume("CLOSE_PAREN", "Expected ')' after function parameters");
    let returnType;
    if (this.checkReservedWordInternal("as")) {
      this.advance();
      returnType = this.parseSequenceTypeInternal();
    }
    this.consume("OPEN_CURLY_BRACKET", "Expected '{' before function body");
    const body = this.parseExpr();
    this.consume("CLOSE_CURLY_BRACKET", "Expected '}' after function body");
    return new XPathInlineFunctionExpression(params, body, returnType);
  }
  /**
   * Parse let expression: let $x := expr, $y := expr return expr
   */
  parseLetExpr() {
    this.consumeReservedWordInternal("let", "Expected 'let'");
    const bindings = [];
    do {
      bindings.push(this.parseLetBinding());
    } while (this.match("COMMA"));
    this.consumeReservedWordInternal("return", "Expected 'return' in let expression");
    const returnExpr = this.parseExpr();
    return new XPathLetExpression(bindings, returnExpr);
  }
  /**
   * Parse a single let binding: $x := expr
   */
  parseLetBinding() {
    this.consume("DOLLAR", "Expected '$' before variable name in let binding");
    const nameToken = this.consumeNameTokenInternal("Expected variable name in let binding");
    const name = nameToken.lexeme;
    let type;
    if (this.checkReservedWordInternal("as")) {
      this.advance();
      type = this.parseSequenceTypeInternal();
    }
    this.consume("ASSIGNMENT", "Expected ':=' after variable name in let binding");
    const expression = this.parseExprSingle();
    return { variable: name, expression, type };
  }
  // Helper methods
  checkReservedWordInternal(word) {
    return this.check("RESERVED_WORD") && this.peek().lexeme === word;
  }
  consumeReservedWordInternal(word, message) {
    var _a, _b;
    if (this.checkReservedWordInternal(word)) {
      this.advance();
      return;
    }
    throw grammarViolation(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  /**
   * Parse sequence type for type annotations.
   */
  parseSequenceTypeInternal() {
    if (this.checkNameInternal("empty-sequence")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after empty-sequence");
      this.consume("CLOSE_PAREN", "Expected ')' after empty-sequence");
      return createEmptySequenceType();
    }
    if (this.checkNameInternal("item")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after item");
      this.consume("CLOSE_PAREN", "Expected ')' after item()");
      const occurrence2 = this.parseOccurrenceIndicatorInternal();
      return createItemSequenceType(ITEM_TYPE, occurrence2);
    }
    if (this.checkNameInternal("map")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after map");
      let keyType = null;
      let valueType = null;
      if (this.match("ASTERISK")) {
        this.consume("CLOSE_PAREN", "Expected ')' after map(*)");
      } else {
        keyType = this.parseSequenceTypeInternal();
        this.consume("COMMA", "Expected ',' after key type in map()");
        valueType = this.parseSequenceTypeInternal();
        this.consume("CLOSE_PAREN", "Expected ')' after map type");
      }
      const occurrence2 = this.parseOccurrenceIndicatorInternal();
      const { createTypedMapTest: createTypedMapTest2 } = (init_typed_collection_types(), __toCommonJS(typed_collection_types_exports));
      const mapItemType = createTypedMapTest2(keyType, valueType);
      return createItemSequenceType(mapItemType, occurrence2);
    }
    if (this.checkNameInternal("array")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after array");
      let memberType = null;
      if (this.match("ASTERISK")) {
        this.consume("CLOSE_PAREN", "Expected ')' after array(*)");
      } else {
        memberType = this.parseSequenceTypeInternal();
        this.consume("CLOSE_PAREN", "Expected ')' after array type");
      }
      const occurrence2 = this.parseOccurrenceIndicatorInternal();
      const { createTypedArrayTest: createTypedArrayTest2 } = (init_typed_collection_types(), __toCommonJS(typed_collection_types_exports));
      const arrayItemType = createTypedArrayTest2(memberType);
      return createItemSequenceType(arrayItemType, occurrence2);
    }
    if (this.checkReservedWordInternal("function")) {
      this.advance();
      this.consume("OPEN_PAREN", "Expected '(' after function");
      let parameterTypes = null;
      if (this.match("ASTERISK")) {
        this.consume("CLOSE_PAREN", "Expected ')' after function(*)");
      } else if (this.check("CLOSE_PAREN")) {
        parameterTypes = [];
        this.advance();
      } else {
        parameterTypes = [];
        do {
          parameterTypes.push(this.parseSequenceTypeInternal());
        } while (this.match("COMMA"));
        this.consume("CLOSE_PAREN", "Expected ')' after function parameter types");
      }
      let returnType = null;
      if (this.checkReservedWordInternal("as")) {
        this.advance();
        returnType = this.parseSequenceTypeInternal();
      }
      const occurrence2 = this.parseOccurrenceIndicatorInternal();
      const { createFunctionTest: createFunctionTest2 } = (init_function_type(), __toCommonJS(function_type_exports));
      const functionItemType = createFunctionTest2(parameterTypes, returnType, {
        isWildcard: parameterTypes === null && returnType === null
      });
      return createItemSequenceType(functionItemType, occurrence2);
    }
    const qname = this.parseQNameInternal();
    const occurrence = this.parseOccurrenceIndicatorInternal();
    const localName = this.stripPrefixInternal(qname);
    const atomicType = getAtomicType(localName);
    if (!atomicType) {
      throw grammarViolation(`Unknown atomic type: ${qname}`);
    }
    return createAtomicSequenceType(atomicType, occurrence);
  }
  parseOccurrenceIndicatorInternal() {
    if (this.match("QUESTION")) return "?" /* ZERO_OR_ONE */;
    if (this.match("ASTERISK")) return "*" /* ZERO_OR_MORE */;
    if (this.match("PLUS")) return "+" /* ONE_OR_MORE */;
    return "ONE" /* EXACTLY_ONE */;
  }
  parseQNameInternal() {
    const first = this.consumeNameTokenInternal("Expected type name");
    if (this.match("COLON")) {
      const local = this.consumeNameTokenInternal("Expected local name after :").lexeme;
      return `${first.lexeme}:${local}`;
    }
    return first.lexeme;
  }
  stripPrefixInternal(qname) {
    const parts = qname.split(":");
    return parts.length === 2 ? parts[1] : parts[0];
  }
  consumeNameTokenInternal(message) {
    var _a, _b;
    if (this.isNameTokenInternal()) {
      return this.advance();
    }
    throw grammarViolation(`${message}. Got: ${(_b = (_a = this.peek()) == null ? void 0 : _a.lexeme) != null ? _b : "EOF"}`);
  }
  isNameTokenInternal() {
    if (this.isAtEnd()) return false;
    const type = this.peek().type;
    return type === "IDENTIFIER" || type === "FUNCTION" || type === "NODE_TYPE" || type === "OPERATOR" || type === "LOCATION" || type === "RESERVED_WORD";
  }
  checkNameInternal(name) {
    return this.isNameTokenInternal() && this.peek().lexeme === name;
  }
  /**
   * Parse a string template from its lexeme and create a StringTemplateExpression.
   * The template string contains the raw content between backticks.
   */
  parseStringTemplateFromLexeme(template) {
    const rawParts = parseStringTemplate(template);
    const parts = [];
    for (const part of rawParts) {
      if (typeof part === "string") {
        parts.push(part);
      } else {
        const exprString = part.expressionString.trim();
        if (exprString.length === 0) {
          parts.push("");
        } else {
          const lexer = new XPathLexer({ version: "3.1" });
          const tokens = lexer.scan(part.expressionString);
          const ParserClass = this.constructor;
          const parser = new ParserClass();
          const expr = parser.parse(tokens);
          parts.push(expr);
        }
      }
    }
    return new StringTemplateExpression(parts);
  }
};

// src/xpath/lib/src/parser/parser-31.ts
init_map_constructor_expression();
init_array_constructor_expression();
init_lookup_expression();
var XPath31Parser = class extends XPath30Parser {
  constructor(options) {
    const opts = options ? __spreadValues({}, options) : {};
    if (!opts.version) {
      opts.version = "3.1";
    }
    super(opts);
    this.ensureVersionSupport(["3.1"], "3.1");
  }
  /**
   * Override parsePrimaryExpr to handle:
   * - Map constructors (map { key: value, ... })
   * - Array constructors ([item, ...] and array { expr })
   * - All XPath 3.0 features from parent class
   */
  parsePrimaryExpr() {
    var _a, _b, _c;
    if (this.check("RESERVED_WORD") && this.peek().lexeme === "map" && ((_a = this.peekNext()) == null ? void 0 : _a.type) === "OPEN_CURLY_BRACKET") {
      return this.parseMapConstructor();
    }
    if (this.check("RESERVED_WORD") && this.peek().lexeme === "array" && ((_b = this.peekNext()) == null ? void 0 : _b.type) === "OPEN_CURLY_BRACKET") {
      return this.parseCurlyArrayConstructor();
    }
    if (this.check("RESERVED_WORD") && (this.peek().lexeme === "map" || this.peek().lexeme === "array") && ((_c = this.peekNext()) == null ? void 0 : _c.type) === "COLON") {
      return this.parseNamespacedFunctionCall();
    }
    if (this.check("OPEN_SQUARE_BRACKET")) {
      return this.parseSquareBracketArrayConstructor();
    }
    if (this.check("QUESTION")) {
      return this.parseLookupExpr(null);
    }
    return super.parsePrimaryExpr();
  }
  /**
   * Parse a namespaced function call like map:size or array:get.
   * These start with a reserved word (map/array) followed by colon.
   */
  parseNamespacedFunctionCall() {
    const prefix = this.advance().lexeme;
    this.consume("COLON", `Expected ':' after '${prefix}'`);
    if (!this.check("IDENTIFIER") && !this.check("FUNCTION")) {
      throw new Error(`Expected function name after '${prefix}:'`);
    }
    const localName = this.advance().lexeme;
    const fullName = `${prefix}:${localName}`;
    this.consume("OPEN_PAREN", `Expected '(' after '${fullName}'`);
    const args = [];
    if (!this.check("CLOSE_PAREN")) {
      do {
        args.push(this.parseExprSingle());
      } while (this.match("COMMA"));
    }
    this.consume("CLOSE_PAREN", `Expected ')' after function arguments`);
    const { XPathFunctionCall: XPathFunctionCall2 } = (init_function_call_expression(), __toCommonJS(function_call_expression_exports));
    return new XPathFunctionCall2(fullName, args);
  }
  /**
   * Parse a map constructor expression (XPath 3.1).
   * Syntax: map { key1: value1, key2: value2, ... }
   * Syntax: map { } (empty map)
   *
   * Each entry is: ExprSingle : ExprSingle
   */
  parseMapConstructor() {
    this.advance();
    this.consume("OPEN_CURLY_BRACKET", "Expected '{' after 'map'");
    const entries = [];
    if (this.check("CLOSE_CURLY_BRACKET")) {
      this.advance();
      return new XPathMapConstructorExpression(entries);
    }
    do {
      const key = this.parseExprSingle();
      this.consume("COLON", "Expected ':' after map key");
      const value = this.parseExprSingle();
      entries.push({ key, value });
    } while (this.match("COMMA"));
    this.consume("CLOSE_CURLY_BRACKET", "Expected '}' after map entries");
    return new XPathMapConstructorExpression(entries);
  }
  /**
   * Parse a square bracket array constructor (XPath 3.1).
   * Syntax: [item1, item2, ...]
   * Syntax: [] (empty array)
   *
   * Each comma-separated expression becomes a separate array member.
   */
  parseSquareBracketArrayConstructor() {
    this.advance();
    const items = [];
    if (this.check("CLOSE_SQUARE_BRACKET")) {
      this.advance();
      return new XPathSquareBracketArrayConstructor(items);
    }
    do {
      const item = this.parseExprSingle();
      items.push(item);
    } while (this.match("COMMA"));
    this.consume("CLOSE_SQUARE_BRACKET", "Expected ']' after array items");
    return new XPathSquareBracketArrayConstructor(items);
  }
  /**
   * Parse a curly brace array constructor (XPath 3.1).
   * Syntax: array { expr }
   * Syntax: array { } (empty array)
   *
   * The expression result is evaluated and each item in the
   * resulting sequence becomes a separate array member.
   */
  parseCurlyArrayConstructor() {
    this.advance();
    this.consume("OPEN_CURLY_BRACKET", "Expected '{' after 'array'");
    if (this.check("CLOSE_CURLY_BRACKET")) {
      this.advance();
      return new XPathCurlyBraceArrayConstructor({
        evaluate: () => [],
        toString: () => "()"
      });
    }
    const expr = this.parseExpr();
    this.consume("CLOSE_CURLY_BRACKET", "Expected '}' after array expression");
    return new XPathCurlyBraceArrayConstructor(expr);
  }
  /**
   * Override parseFilterExpr to handle lookup operators after predicates.
   * Lookup operators have lower precedence than predicates.
   */
  parseFilterExpr() {
    let expr = super.parseFilterExpr();
    while (this.check("QUESTION")) {
      expr = this.parseLookupExpr(expr);
    }
    return expr;
  }
  /**
   * Parse a lookup expression: ?key, ?1, ?(expr), ?*
   */
  parseLookupExpr(baseExpr) {
    var _a, _b, _c, _d, _e;
    this.consume("QUESTION", "Expected ? for lookup operator");
    let keySpecifier;
    if (this.match("ASTERISK")) {
      keySpecifier = { type: "WILDCARD" /* WILDCARD */ };
    } else if (this.check("OPEN_PAREN")) {
      this.advance();
      const expr = this.parseExpr();
      this.consume("CLOSE_PAREN", "Expected ')' after lookup expression");
      keySpecifier = { type: "PARENTHESIZED_EXPR" /* PARENTHESIZED_EXPR */, value: expr };
    } else if (this.check("NUMBER")) {
      const numToken = this.advance();
      const position = parseInt(numToken.lexeme, 10);
      keySpecifier = { type: "INTEGER_LITERAL" /* INTEGER_LITERAL */, value: position };
    } else if (((_a = this.peek()) == null ? void 0 : _a.type) === "IDENTIFIER" || ((_b = this.peek()) == null ? void 0 : _b.type) === "FUNCTION" || ((_c = this.peek()) == null ? void 0 : _c.type) === "OPERATOR" || ((_d = this.peek()) == null ? void 0 : _d.type) === "LOCATION" || ((_e = this.peek()) == null ? void 0 : _e.type) === "NODE_TYPE") {
      const name = this.advance().lexeme;
      keySpecifier = { type: "NCNAME" /* NCNAME */, value: name };
    } else {
      throw new Error("Expected key specifier after ?");
    }
    return new XPathLookupExpression(baseExpr, keySpecifier);
  }
  /**
   * Override parseSequenceType to support union types (XPath 3.1 Extension)
   * Syntax: type1 | type2 | ... | typeN
   *
   * Examples:
   *   xs:string | xs:integer
   *   (xs:integer | xs:decimal) | xs:double
   */
  parseSequenceType() {
    let firstType = super.parseSequenceType();
    if (this.check("PIPE")) {
      const memberTypes = [firstType];
      while (this.match("PIPE")) {
        const nextType = super.parseSequenceType();
        memberTypes.push(nextType);
      }
      const { createUnionType: createUnionType2 } = (init_union_type(), __toCommonJS(union_type_exports));
      const { createItemSequenceType: createItemSequenceType2 } = (init_sequence_type(), __toCommonJS(sequence_type_exports));
      const itemTypes = memberTypes.map((st) => {
        if (st.getItemType && typeof st.getItemType === "function") {
          const itemType = st.getItemType();
          if (itemType === "empty") {
            throw new Error("empty-sequence() cannot be used in union types");
          }
          return itemType;
        }
        return st;
      });
      const occurrence = firstType.getOccurrence ? firstType.getOccurrence() : "ONE";
      const unionItemType = createUnionType2(...itemTypes);
      return createItemSequenceType2(unionItemType, occurrence);
    }
    return firstType;
  }
  /**
   * Override parseSequenceTypeInternal to support union types in type annotations
   * This is called from instance of, treat as, cast as, etc.
   */
  parseSequenceTypeInternal() {
    let firstType = super["parseSequenceTypeInternal"]();
    if (this.check("PIPE")) {
      const memberTypes = [firstType];
      while (this.match("PIPE")) {
        const nextType = super["parseSequenceTypeInternal"]();
        memberTypes.push(nextType);
      }
      const { createUnionType: createUnionType2 } = (init_union_type(), __toCommonJS(union_type_exports));
      const { createItemSequenceType: createItemSequenceType2 } = (init_sequence_type(), __toCommonJS(sequence_type_exports));
      const itemTypes = memberTypes.map((st) => {
        if (st.getItemType && typeof st.getItemType === "function") {
          const itemType = st.getItemType();
          if (itemType === "empty") {
            throw new Error("empty-sequence() cannot be used in union types");
          }
          return itemType;
        }
        return st;
      });
      const occurrence = firstType.getOccurrence ? firstType.getOccurrence() : "ONE";
      const unionItemType = createUnionType2(...itemTypes);
      return createItemSequenceType2(unionItemType, occurrence);
    }
    return firstType;
  }
};

// src/xpath/lib/src/xpath-version.ts
var DEFAULT_XPATH_VERSION = "1.0";

// src/xpath/lib/src/parser/index.ts
function createXPathParser(version = DEFAULT_XPATH_VERSION, options) {
  const fullOptions = __spreadProps(__spreadValues({}, options), { version });
  switch (version) {
    case "1.0":
      return new XPath10Parser(fullOptions);
    case "2.0":
      return new XPath20Parser(fullOptions);
    case "3.0":
      return new XPath30Parser(fullOptions);
    case "3.1":
      return new XPath31Parser(fullOptions);
    default:
      throw new Error(`Unsupported XPath version: ${version}`);
  }
}

// src/xpath/xpath.ts
init_expressions();

// src/dom/functions.ts
function domGetAttributeValue(node, name) {
  return node.getAttributeValue(name);
}
function domSetAttribute(node, name, value) {
  return node.setAttribute(name, value);
}
function domAppendChild(node, child) {
  return node.appendChild(child);
}
function domCreateTextNode(node, text) {
  return node.createTextNode(text);
}
function domCreateElement(doc, name) {
  return doc.createElement(name);
}
function domCreateCDATASection(doc, data2) {
  return doc.createCDATASection(data2);
}
function domCreateComment(doc, text) {
  return doc.createComment(text);
}
function domCreateDocumentFragment(doc) {
  return doc.createDocumentFragment();
}
function domCreateDTDSection(doc, data2) {
  return doc.createDTDSection(data2);
}
function domCreateProcessingInstruction(doc, target, data2) {
  return doc.createProcessingInstruction(target, data2);
}

// src/constants.ts
var DOM_ELEMENT_NODE = 1;
var DOM_ATTRIBUTE_NODE = 2;
var DOM_TEXT_NODE = 3;
var DOM_CDATA_SECTION_NODE = 4;
var DOM_PROCESSING_INSTRUCTION_NODE = 7;
var DOM_COMMENT_NODE = 8;
var DOM_DOCUMENT_NODE = 9;
var DOM_DOCUMENT_TYPE_NODE = 10;
var DOM_DOCUMENT_FRAGMENT_NODE = 11;

// src/dom/xnode.ts
var _XNode = class _XNode {
  constructor(type, name, opt_value, opt_owner, opt_namespace) {
    this.id = Math.random() * (Number.MAX_SAFE_INTEGER - 1) + 1;
    this.childNodes = [];
    this.visited = false;
    this.escape = true;
    this.fromXslText = false;
    this.siblingPosition = -1;
    this.init(type, name, opt_value, opt_owner, opt_namespace);
  }
  /**
   * Node initialization. Called by the constructor and `recycle` method.
   * @param type The node type.
   * @param name The node name.
   * @param value The node value.
   * @param owner The node owner.
   * @param namespaceUri The node namespace.
   */
  init(type, name, value, owner, namespaceUri) {
    this.nodeType = type - 0;
    this.nodeName = `${name}`;
    this.nodeValue = `${value}`;
    this.ownerDocument = owner;
    this.namespaceUri = namespaceUri || null;
    [this.prefix, this.localName] = this.qualifiedNameToParts(`${name}`);
    this.firstChild = null;
    this.lastChild = null;
    this.nextSibling = null;
    this.previousSibling = null;
    this.parentNode = null;
  }
  qualifiedNameToParts(name) {
    if (name.includes(":")) {
      return name.split(":");
    }
    return [null, name];
  }
  // Traverses the element nodes in the DOM section underneath the given
  // node and invokes the given callbacks as methods on every element
  // node encountered. Function opt_pre is invoked before a node's
  // children are traversed; opt_post is invoked after they are
  // traversed. Traversal will not be continued if a callback function
  // returns boolean false. NOTE(mesch): copied from
  // <//google3/maps/webmaps/javascript/dom.js>.
  domTraverseElements(node, opt_pre, opt_post) {
    let ret;
    if (opt_pre) {
      ret = opt_pre.call(null, node);
      if (typeof ret == "boolean" && !ret) {
        return false;
      }
    }
    for (let c = node.firstChild; c; c = c.nextSibling) {
      if (c.nodeType == DOM_ELEMENT_NODE) {
        ret = this.domTraverseElements.call(this, c, opt_pre, opt_post);
        if (typeof ret == "boolean" && !ret) {
          return false;
        }
      }
    }
    if (opt_post) {
      ret = opt_post.call(null, node);
      if (typeof ret == "boolean" && !ret) {
        return false;
      }
    }
  }
  // TODO: Do we still need this?
  static recycle(node) {
    if (!node) {
      return;
    }
    if (node.constructor.name === "XDocument") {
      this.recycle(node.documentElement);
      return;
    }
    if (node.constructor != this) {
      return;
    }
    this._unusedXNodes.push(node);
    for (let c = 0; c < node.childNodes.length; ++c) {
      this.recycle(node.childNodes[c]);
    }
    node.childNodes.length = 0;
    node.init.call(0, "", "", null);
  }
  static create(type, name, value, owner, namespace) {
    if (this._unusedXNodes.length > 0) {
      const node = this._unusedXNodes.pop();
      node.init(type, name, value, owner, namespace);
      return node;
    }
    return new _XNode(type, name, value, owner, namespace);
  }
  static clone(node, newOwner) {
    const newNode = new _XNode(node.nodeType, node.nodeName, node.nodeValue, newOwner, node.namespaceUri);
    newNode.id = node.id;
    for (let child of node.childNodes) {
      newNode.appendChild(_XNode.clone(child, newNode));
    }
    return newNode;
  }
  appendChild(node) {
    if (this.childNodes.length === 0) {
      this.firstChild = node;
    }
    node.previousSibling = this.lastChild;
    node.nextSibling = null;
    if (this.lastChild) {
      this.lastChild.nextSibling = node;
    }
    node.parentNode = this;
    this.lastChild = node;
    this.childNodes.push(node);
  }
  replaceChild(newNode, oldNode) {
    if (oldNode == newNode) {
      return;
    }
    for (let i = 0; i < this.childNodes.length; ++i) {
      if (this.childNodes[i] == oldNode) {
        this.childNodes[i] = newNode;
        let p = oldNode.parentNode;
        oldNode.parentNode = null;
        newNode.parentNode = p;
        p = oldNode.previousSibling;
        oldNode.previousSibling = null;
        newNode.previousSibling = p;
        if (newNode.previousSibling) {
          newNode.previousSibling.nextSibling = newNode;
        }
        p = oldNode.nextSibling;
        oldNode.nextSibling = null;
        newNode.nextSibling = p;
        if (newNode.nextSibling) {
          newNode.nextSibling.previousSibling = newNode;
        }
        if (this.firstChild == oldNode) {
          this.firstChild = newNode;
        }
        if (this.lastChild == oldNode) {
          this.lastChild = newNode;
        }
        break;
      }
    }
  }
  insertBefore(newNode, oldNode) {
    if (oldNode == newNode) {
      return;
    }
    if (oldNode.parentNode != this) {
      return;
    }
    if (newNode.parentNode) {
      newNode.parentNode.removeChild(newNode);
    }
    const newChildren = [];
    for (const c of this.childNodes) {
      if (c == oldNode) {
        newChildren.push(newNode);
        newNode.parentNode = this;
        newNode.previousSibling = oldNode.previousSibling;
        oldNode.previousSibling = newNode;
        if (newNode.previousSibling) {
          newNode.previousSibling.nextSibling = newNode;
        }
        newNode.nextSibling = oldNode;
        if (this.firstChild == oldNode) {
          this.firstChild = newNode;
        }
      }
      newChildren.push(c);
    }
    this.childNodes = newChildren;
  }
  removeChild(node) {
    const newChildren = [];
    for (const c of this.childNodes) {
      if (c != node) {
        newChildren.push(c);
      } else {
        if (c.previousSibling) {
          c.previousSibling.nextSibling = c.nextSibling;
        }
        if (c.nextSibling) {
          c.nextSibling.previousSibling = c.previousSibling;
        }
        if (this.firstChild == c) {
          this.firstChild = c.nextSibling;
        }
        if (this.lastChild == c) {
          this.lastChild = c.previousSibling;
        }
      }
    }
    this.childNodes = newChildren;
  }
  hasAttributes() {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    return attributes.length > 0;
  }
  setAttribute(name, value) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      if (attributes[i].nodeName == name) {
        attributes[i].nodeValue = `${value}`;
        return;
      }
    }
    const newAttribute = _XNode.create(DOM_ATTRIBUTE_NODE, name, value, this);
    newAttribute.parentNode = this;
    this.appendChild(newAttribute);
  }
  setAttributeNS(namespace, name, value) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.namespaceUri == namespace && attribute.localName == this.qualifiedNameToParts(`${name}`)[1]) {
        attribute.nodeValue = `${value}`;
        attribute.nodeName = `${name}`;
        attribute.prefix = this.qualifiedNameToParts(`${name}`)[0];
        return;
      }
    }
    const newAttribute = _XNode.create(DOM_ATTRIBUTE_NODE, name, value, this, namespace);
    newAttribute.parentNode = this;
    this.appendChild(newAttribute);
  }
  getAttributeValue(name) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      if (attributes[i].nodeName === name) {
        return attributes[i].nodeValue;
      }
    }
    return null;
  }
  getAttributeNS(namespace, localName) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.namespaceUri === namespace && attribute.localName === localName) {
        return attribute.nodeValue;
      }
    }
    return null;
  }
  hasAttribute(name) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      if (attributes[i].nodeName === name) {
        return true;
      }
    }
    return false;
  }
  hasAttributeNS(namespace, localName) {
    const attributes = this.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.namespaceUri === namespace && attribute.localName === localName) {
        return true;
      }
    }
    return false;
  }
  removeAttribute(name) {
    const newChildNodes = [];
    for (let i = 0; i < this.childNodes.length; ++i) {
      const childNode = this.childNodes[i];
      if (childNode.nodeType !== DOM_ATTRIBUTE_NODE) {
        newChildNodes.push(childNode);
        continue;
      }
      if (childNode.nodeName !== name) {
        newChildNodes.push(childNode);
      }
    }
    this.childNodes = newChildNodes;
  }
  removeAttributeNS(namespace, localName) {
    const newChildNodes = [];
    for (let i = 0; i < this.childNodes.length; ++i) {
      const childNode = this.childNodes[i];
      if (childNode.nodeType !== DOM_ATTRIBUTE_NODE) {
        newChildNodes.push(childNode);
        continue;
      }
      if (childNode.localName !== localName || childNode.namespaceUri !== namespace) {
        newChildNodes.push(childNode);
      }
    }
    this.childNodes = newChildNodes;
  }
  getElementsByTagName(name) {
    const ret = [];
    const self = this;
    if ("*" == name) {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          ret.push(node);
        },
        null
      );
    } else {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          if (node.nodeName == name) {
            ret.push(node);
          }
        },
        null
      );
    }
    return ret;
  }
  getElementsByTagNameNS(namespace, localName) {
    const ret = [];
    const self = this;
    if ("*" == namespace && "*" == localName) {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          ret.push(node);
        },
        null
      );
    } else if ("*" == namespace) {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          if (node.localName == localName) ret.push(node);
        },
        null
      );
    } else if ("*" == localName) {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          if (node.namespaceUri == namespace) ret.push(node);
        },
        null
      );
    } else {
      this.domTraverseElements(
        this,
        (node) => {
          if (self == node) return;
          if (node.localName == localName && node.namespaceUri == namespace) {
            ret.push(node);
          }
        },
        null
      );
    }
    return ret;
  }
  getElementById(id) {
    let ret = null;
    this.domTraverseElements(
      this,
      (node) => {
        if (node.getAttributeValue("id") == id) {
          ret = node;
          return false;
        }
      },
      null
    );
    return ret;
  }
  getAncestorByLocalName(localName) {
    if (this.parentNode === null || this.parentNode === void 0) {
      return void 0;
    }
    if (this.parentNode.localName === localName) {
      return this.parentNode;
    }
    return this.parentNode.getAncestorByLocalName(localName);
  }
  getAncestorById(id) {
    if (this.parentNode === null || this.parentNode === void 0) {
      return void 0;
    }
    if (this.parentNode.id === id) {
      return this.parentNode;
    }
    return this.parentNode.getAncestorById(id);
  }
  toString() {
    return `${this.nodeType}, ${this.nodeName}, ${this.nodeValue}`;
  }
};
_XNode._unusedXNodes = [];
var XNode = _XNode;

// src/dom/xdocument.ts
var XDocument = class extends XNode {
  constructor() {
    super(DOM_DOCUMENT_NODE, "#document", null, null);
    this.documentElement = null;
  }
  appendChild(node) {
    super.appendChild(node);
    this.documentElement = this.childNodes[0];
  }
  createElement(name) {
    return XNode.create(DOM_ELEMENT_NODE, name, null, this);
  }
  createElementNS(namespace, name) {
    return XNode.create(DOM_ELEMENT_NODE, name, null, this, namespace);
  }
  createDocumentFragment() {
    return XNode.create(DOM_DOCUMENT_FRAGMENT_NODE, "#document-fragment", null, this);
  }
  createTextNode(value) {
    return XNode.create(DOM_TEXT_NODE, "#text", value, this);
  }
  createAttribute(name) {
    return XNode.create(DOM_ATTRIBUTE_NODE, name, null, this);
  }
  createAttributeNS(namespace, name) {
    return XNode.create(DOM_ATTRIBUTE_NODE, name, null, this, namespace);
  }
  createComment(data2) {
    return XNode.create(DOM_COMMENT_NODE, "#comment", data2, this);
  }
  createCDATASection(data2) {
    return XNode.create(DOM_CDATA_SECTION_NODE, "#cdata-section", data2, this);
  }
  createDTDSection(data2) {
    return XNode.create(DOM_DOCUMENT_TYPE_NODE, "#dtd-section", data2, this);
  }
  createProcessingInstruction(target, data2) {
    return XNode.create(DOM_PROCESSING_INSTRUCTION_NODE, target, data2, this);
  }
};

// src/dom/html-entity-decoder.ts
var NAMED_ENTITIES = {
  "amp": "&",
  "lt": "<",
  "gt": ">",
  "quot": '"',
  "apos": "'",
  "nbsp": "\xA0",
  "copy": "\xA9",
  "reg": "\xAE",
  "times": "\xD7",
  "divide": "\xF7",
  "euro": "\u20AC",
  "pound": "\xA3",
  "yen": "\xA5",
  "cent": "\xA2",
  "sect": "\xA7",
  "para": "\xB6",
  "hellip": "\u2026",
  "middot": "\xB7",
  "deg": "\xB0"
};
function htmlEntityDecode(text) {
  if (!text) {
    return text;
  }
  let result = text.replace(/&([a-zA-Z]+);/g, (match, entity) => {
    const lower = entity.toLowerCase();
    return NAMED_ENTITIES[lower] || match;
  });
  result = result.replace(/&#(\d+);/g, (match, code) => {
    try {
      const num = parseInt(code, 10);
      return String.fromCharCode(num);
    } catch (e) {
      return match;
    }
  });
  result = result.replace(/&#[xX]([0-9a-fA-F]+);/g, (match, code) => {
    try {
      const num = parseInt(code, 16);
      return String.fromCharCode(num);
    } catch (e) {
      return match;
    }
  });
  return result;
}

// src/dom/xml-functions.ts
function xmlValue(node, disallowBrowserSpecificOptimization = false) {
  if (!node) {
    return "";
  }
  let ret = "";
  switch (node.nodeType) {
    case DOM_DOCUMENT_TYPE_NODE:
      return `<!DOCTYPE ${node.nodeValue}>`;
    case DOM_TEXT_NODE:
    case DOM_CDATA_SECTION_NODE:
    case DOM_ATTRIBUTE_NODE:
      return node.nodeValue;
    case DOM_ELEMENT_NODE:
    case DOM_DOCUMENT_NODE:
    case DOM_DOCUMENT_FRAGMENT_NODE:
      if (!disallowBrowserSpecificOptimization) {
        const browserNode = node;
        const innerText = browserNode.innerText;
        if (innerText !== void 0) {
          return innerText;
        }
        const textContent = browserNode.textContent;
        if (textContent !== void 0) {
          return textContent;
        }
      }
      const textNodes = node.childNodes.filter((n) => n.nodeType !== DOM_ATTRIBUTE_NODE);
      for (let i = 0; i < textNodes.length; ++i) {
        ret += xmlValue(textNodes[i]);
      }
      return ret;
  }
}
function xmlValueLegacyBehavior(node, disallowBrowserSpecificOptimization = false) {
  if (!node) {
    return "";
  }
  let returnedXmlString = "";
  switch (node.nodeType) {
    case DOM_ATTRIBUTE_NODE:
    case DOM_TEXT_NODE:
      returnedXmlString += node.nodeValue;
      break;
    case DOM_CDATA_SECTION_NODE:
      returnedXmlString += node.nodeValue;
      break;
    case DOM_DOCUMENT_NODE:
    case DOM_DOCUMENT_FRAGMENT_NODE:
    case DOM_ELEMENT_NODE:
      if (!disallowBrowserSpecificOptimization) {
        const browserNode = node;
        const innerText = browserNode.innerText;
        if (innerText !== void 0) {
          return innerText;
        }
        const textContent = browserNode.textContent;
        if (textContent !== void 0) {
          return textContent;
        }
      }
      const len = node.childNodes.length;
      for (let i = 0; i < len; ++i) {
        returnedXmlString += xmlValue(node.childNodes[i]);
      }
      break;
  }
  return returnedXmlString;
}
function xmlTransformedText(node, options = {
  cData: true,
  escape: true,
  selfClosingTags: true,
  outputMethod: "xml"
}) {
  const buffer = [];
  xmlTransformedTextRecursive(node, buffer, options);
  return buffer.join("");
}
function xmlTransformedTextRecursive(node, buffer, options) {
  if (node.visited) return;
  const nodeType = node.nodeType;
  const nodeValue = node.nodeValue;
  if (nodeType === DOM_TEXT_NODE) {
    const isFromXslText = node.fromXslText === true;
    if (node.nodeValue && (isFromXslText || node.nodeValue.trim() !== "")) {
      const finalText = node.escape && options.escape ? xmlEscapeText(node.nodeValue) : xmlUnescapeText(node.nodeValue);
      buffer.push(finalText);
    }
  } else if (nodeType === DOM_CDATA_SECTION_NODE) {
    if (options.outputMethod === "text") {
      buffer.push(nodeValue);
    } else if (options.cData) {
      buffer.push(xmlEscapeText(nodeValue));
    } else {
      buffer.push(`<![CDATA[${nodeValue}]]>`);
    }
  } else if (nodeType == DOM_COMMENT_NODE) {
    if (options.outputMethod !== "text") {
      buffer.push(`<!-- ${nodeValue} -->`);
    }
  } else if (nodeType === DOM_PROCESSING_INSTRUCTION_NODE) {
    if (options.outputMethod !== "text") {
      if (nodeValue && nodeValue.trim()) {
        buffer.push(`<?${node.nodeName} ${nodeValue}?>`);
      } else {
        buffer.push(`<?${node.nodeName}?>`);
      }
    }
  } else if (nodeType == DOM_ELEMENT_NODE) {
    if (options.outputMethod === "text") {
      xmlElementLogicTextOnly(node, buffer, options);
    } else {
      if (node.nodeName !== null && node.nodeName !== void 0) {
        xmlElementLogicTrivial(node, buffer, options);
      } else {
        xmlElementLogicMuted(node, buffer, options);
      }
    }
  } else if (nodeType === DOM_DOCUMENT_NODE || nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
    let childNodes = node.firstChild ? [] : node.childNodes;
    if (node.firstChild) {
      let child = node.firstChild;
      while (child) {
        childNodes.push(child);
        child = child.nextSibling;
      }
    }
    childNodes.sort((a, b) => a.siblingPosition - b.siblingPosition);
    for (let i = 0; i < childNodes.length; ++i) {
      xmlTransformedTextRecursive(childNodes[i], buffer, options);
    }
  }
  node.visited = true;
}
function xmlElementLogicTrivial(node, buffer, options) {
  buffer.push(`<${xmlFullNodeName(node)}`);
  let attributes = [];
  if (node.firstChild) {
    let child = node.firstChild;
    while (child) {
      if (child.nodeType === DOM_ATTRIBUTE_NODE) {
        attributes.push(child);
      }
      child = child.nextSibling;
    }
  }
  if (attributes.length === 0) {
    attributes = node.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
  }
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (!attribute) {
      continue;
    }
    if (attribute.nodeName && attribute.nodeValue !== null && attribute.nodeValue !== void 0) {
      buffer.push(` ${xmlFullNodeName(attribute)}="${xmlEscapeAttr(attribute.nodeValue)}"`);
    }
  }
  let childNodes = [];
  if (node.firstChild) {
    let child = node.firstChild;
    while (child) {
      if (child.nodeType !== DOM_ATTRIBUTE_NODE) {
        childNodes.push(child);
      }
      child = child.nextSibling;
    }
  }
  if (childNodes.length === 0) {
    childNodes = node.childNodes.filter((n) => n.nodeType !== DOM_ATTRIBUTE_NODE);
  }
  childNodes = childNodes.sort((a, b) => a.siblingPosition - b.siblingPosition);
  if (childNodes.length === 0) {
    if (options.outputMethod === "html" && ["hr", "link", "meta"].includes(node.nodeName)) {
      buffer.push(">");
    } else if (options.selfClosingTags) {
      buffer.push("/>");
    } else {
      buffer.push(`></${xmlFullNodeName(node)}>`);
    }
  } else {
    buffer.push(">");
    for (let i = 0; i < childNodes.length; ++i) {
      xmlTransformedTextRecursive(childNodes[i], buffer, options);
    }
    buffer.push(`</${xmlFullNodeName(node)}>`);
  }
}
function xmlElementLogicMuted(node, buffer, options) {
  let childNodes = [];
  if (node.firstChild) {
    let child = node.firstChild;
    while (child) {
      childNodes.push(child);
      child = child.nextSibling;
    }
  } else {
    childNodes = node.childNodes;
  }
  childNodes = childNodes.sort((a, b) => a.siblingPosition - b.siblingPosition);
  for (let i = 0; i < childNodes.length; ++i) {
    xmlTransformedTextRecursive(childNodes[i], buffer, options);
  }
}
function xmlElementLogicTextOnly(node, buffer, options) {
  let childNodes = [];
  if (node.firstChild) {
    let child = node.firstChild;
    while (child) {
      childNodes.push(child);
      child = child.nextSibling;
    }
  } else {
    childNodes = node.childNodes;
  }
  childNodes = childNodes.sort((a, b) => a.siblingPosition - b.siblingPosition);
  for (let i = 0; i < childNodes.length; ++i) {
    xmlTransformedTextRecursive(childNodes[i], buffer, options);
  }
}
function xmlFullNodeName(node) {
  const nodeName2 = node.nodeName;
  if (node.prefix && nodeName2.indexOf(`${node.prefix}:`) != 0) {
    return `${node.prefix}:${nodeName2}`;
  }
  return nodeName2;
}
function xmlUnescapeText(text) {
  return `${text}`.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
}
function xmlEscapeText(s) {
  return `${s}`.replace(/&/g, "&amp;").replace(/&amp;amp;/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function xmlEscapeAttr(s) {
  return xmlEscapeText(s).replace(/"/g, "&quot;");
}
function xmlGetAttribute(node, name) {
  const value = domGetAttributeValue(node, name);
  if (value) {
    return htmlEntityDecode(value);
  }
  return value;
}
function nodeToJsonObject(node) {
  if (!node) {
    return null;
  }
  const nodeType = node.nodeType;
  if (nodeType === DOM_TEXT_NODE || nodeType === DOM_CDATA_SECTION_NODE) {
    const text = node.nodeValue ? node.nodeValue.trim() : "";
    return text.length > 0 ? text : null;
  }
  if (nodeType === DOM_COMMENT_NODE) {
    return null;
  }
  if (nodeType === DOM_DOCUMENT_NODE || nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
    const children = node.childNodes || [];
    const childObjects = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const childObj = nodeToJsonObject(child);
      if (childObj !== null) {
        childObjects.push(childObj);
      }
    }
    if (childObjects.length === 0) {
      return null;
    } else if (childObjects.length === 1) {
      return childObjects[0];
    } else {
      return childObjects;
    }
  }
  if (nodeType === DOM_ELEMENT_NODE) {
    const obj = {};
    const element = node;
    const hasAttributes = element.attributes && element.attributes.length > 0;
    if (hasAttributes) {
      for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        obj["@" + attr.nodeName] = attr.nodeValue;
      }
    }
    const children = element.childNodes || [];
    let textContent = "";
    let hasElementChildren = false;
    const childElements = {};
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const childType = child.nodeType;
      if (childType === DOM_TEXT_NODE || childType === DOM_CDATA_SECTION_NODE) {
        const text = child.nodeValue ? child.nodeValue.trim() : "";
        if (text.length > 0) {
          textContent += text;
        }
      } else if (childType === DOM_ELEMENT_NODE) {
        hasElementChildren = true;
        const childElement = child;
        const childName = childElement.localName || childElement.nodeName;
        const childObj = nodeToJsonObject(child);
        if (childObj !== null) {
          if (childElements[childName]) {
            if (!Array.isArray(childElements[childName])) {
              childElements[childName] = [childElements[childName]];
            }
            childElements[childName].push(childObj);
          } else {
            childElements[childName] = childObj;
          }
        }
      }
    }
    Object.assign(obj, childElements);
    if (!hasElementChildren && textContent.length > 0) {
      if (!hasAttributes && Object.keys(childElements).length === 0) {
        return textContent;
      } else {
        obj["#text"] = textContent;
      }
    }
    if (Object.keys(obj).length === 0) {
      return null;
    }
    return obj;
  }
  return null;
}
function detectAdaptiveOutputFormat(node) {
  if (!node) {
    return "xml";
  }
  const nodeType = node.nodeType;
  if (nodeType === DOM_DOCUMENT_NODE || nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
    const children = node.childNodes || [];
    let elementCount = 0;
    let textCount = 0;
    let hasSignificantText = false;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.nodeType === DOM_ELEMENT_NODE) {
        elementCount++;
      } else if (child.nodeType === DOM_TEXT_NODE) {
        const text = child.nodeValue ? child.nodeValue.trim() : "";
        if (text.length > 0) {
          textCount++;
          hasSignificantText = true;
        }
      }
    }
    if (elementCount === 0 && hasSignificantText) {
      return "text";
    }
    return "xml";
  }
  if (nodeType === DOM_TEXT_NODE || nodeType === DOM_CDATA_SECTION_NODE) {
    const text = node.nodeValue ? node.nodeValue.trim() : "";
    if (text.length > 0) {
      return "text";
    }
  }
  return "xml";
}
function xmlToJson(node) {
  if (!node) {
    return "{}";
  }
  let rootElement = node;
  if (node.nodeType === DOM_DOCUMENT_NODE || node.nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
    const children = node.childNodes || [];
    for (let i = 0; i < children.length; i++) {
      if (children[i].nodeType === DOM_ELEMENT_NODE) {
        rootElement = children[i];
        break;
      }
    }
  }
  const element = rootElement;
  const rootName = element.localName || element.nodeName;
  const jsonObj = {};
  const elementContent = nodeToJsonObject(rootElement);
  if (elementContent === null) {
    jsonObj[rootName] = {};
  } else if (typeof elementContent === "object" && !Array.isArray(elementContent)) {
    jsonObj[rootName] = elementContent;
  } else {
    jsonObj[rootName] = elementContent;
  }
  try {
    const cleaned = JSON.parse(JSON.stringify(jsonObj));
    return JSON.stringify(cleaned);
  } catch (error) {
    return JSON.stringify(jsonObj);
  }
}

// src/dom/xmltoken.ts
var XML_S = "[ 	\r\n]+";
var XML_EQ = `(${XML_S})?=(${XML_S})?`;
var XML_CHAR_REF = "&#[0-9]+;|&#x[0-9a-fA-F]+;";
var XML10_VERSION_INFO = `${XML_S}version${XML_EQ}("1\\.0"|'1\\.0')`;
var XML10_BASE_CHAR = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0100-\u0131\u0134-\u013E\u0141-\u0148\u014A-\u017E\u0180-\u01C3\u01CD-\u01F0\u01F4-\u01F5\u01FA-\u0217\u0250-\u02A8\u02BB-\u02C1\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03CE\u03D0-\u03D6\u03DA\u03DC\u03DE\u03E0\u03E2-\u03F3\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E-\u0481\u0490-\u04C4\u04C7-\u04C8\u04CB-\u04CC\u04D0-\u04EB\u04EE-\u04F5\u04F8-\u04F9\u0531-\u0556\u0559\u0561-\u0586\u05D0-\u05EA\u05F0-\u05F2\u0621-\u063A\u0641-\u064A\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D3\u06D5\u06E5-\u06E6\u0905-\u0939\u093D\u0958-\u0961\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8B\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AE0\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B36-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB5\u0BB7-\u0BB9\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CDE\u0CE0-\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D60-\u0D61\u0E01-\u0E2E\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EAE\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0F40-\u0F47\u0F49-\u0F69\u10A0-\u10C5\u10D0-\u10F6\u1100\u1102-\u1103\u1105-\u1107\u1109\u110B-\u110C\u110E-\u1112\u113C\u113E\u1140\u114C\u114E\u1150\u1154-\u1155\u1159\u115F-\u1161\u1163\u1165\u1167\u1169\u116D-\u116E\u1172-\u1173\u1175\u119E\u11A8\u11AB\u11AE-\u11AF\u11B7-\u11B8\u11BA\u11BC-\u11C2\u11EB\u11F0\u11F9\u1E00-\u1E9B\u1EA0-\u1EF9\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A-\u212B\u212E\u2180-\u2182\u3041-\u3094\u30A1-\u30FA\u3105-\u312C\uAC00-\uD7A3";
var XML10_IDEOGRAPHIC = "\u4E00-\u9FA5\u3007\u3021-\u3029";
var XML10_COMBINING_CHAR = "\u0300-\u0345\u0360-\u0361\u0483-\u0486\u0591-\u05A1\u05A3-\u05B9\u05BB-\u05BD\u05BF\u05C1-\u05C2\u05C4\u064B-\u0652\u0670\u06D6-\u06DC\u06DD-\u06DF\u06E0-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0901-\u0903\u093C\u093E-\u094C\u094D\u0951-\u0954\u0962-\u0963\u0981-\u0983\u09BC\u09BE\u09BF\u09C0-\u09C4\u09C7-\u09C8\u09CB-\u09CD\u09D7\u09E2-\u09E3\u0A02\u0A3C\u0A3E\u0A3F\u0A40-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A70-\u0A71\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0B01-\u0B03\u0B3C\u0B3E-\u0B43\u0B47-\u0B48\u0B4B-\u0B4D\u0B56-\u0B57\u0B82-\u0B83\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C82-\u0C83\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D43\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86-\u0F8B\u0F90-\u0F95\u0F97\u0F99-\u0FAD\u0FB1-\u0FB7\u0FB9\u20D0-\u20DC\u20E1\u302A-\u302F\u3099\u309A";
var XML10_DIGIT = "0-9\u0660-\u0669\u06F0-\u06F9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE7-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29";
var XML10_EXTENDER = "\xB7\u02D0\u02D1\u0387\u0640\u0E46\u0EC6\u3005\u3031-\u3035\u309D-\u309E\u30FC-\u30FE";
var XML10_LETTER = XML10_BASE_CHAR + XML10_IDEOGRAPHIC;
var XML10_NAME_CHAR = `${XML10_LETTER + XML10_DIGIT}\\._:${XML10_COMBINING_CHAR}${XML10_EXTENDER}-`;
var XML10_NAME = `[${XML10_LETTER}_:][${XML10_NAME_CHAR}]*`;
var XML10_ENTITY_REF = `&${XML10_NAME};`;
var XML10_REFERENCE = `${XML10_ENTITY_REF}|${XML_CHAR_REF}`;
var XML10_ATT_VALUE = `"(([^<&"]|${XML10_REFERENCE})*)"|'(([^<&']|${XML10_REFERENCE})*)'`;
var XML10_ATTRIBUTE = `(${XML10_NAME})${XML_EQ}(${XML10_ATT_VALUE})`;
var XML11_VERSION_INFO = `${XML_S}version${XML_EQ}("1\\.1"|'1\\.1')`;
var XML11_NAME_START_CHAR = ":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var XML11_NAME_CHAR = XML11_NAME_START_CHAR + "\\.0-9\xB7\u0300-\u036F\u203F-\u2040-";
var XML11_NAME = `[${XML11_NAME_START_CHAR}][${XML11_NAME_CHAR}]*`;
var XML11_ENTITY_REF = `&${XML11_NAME};`;
var XML11_REFERENCE = `${XML11_ENTITY_REF}|${XML_CHAR_REF}`;
var XML11_ATT_VALUE = `"(([^<&"]|${XML11_REFERENCE})*)"|'(([^<&']|${XML11_REFERENCE})*)'`;
var XML11_ATTRIBUTE = `(${XML11_NAME})${XML_EQ}(${XML11_ATT_VALUE})`;
var XML_NC_NAME_CHAR = `${XML10_LETTER + XML10_DIGIT}\\._${XML10_COMBINING_CHAR}${XML10_EXTENDER}-`;
var XML_NC_NAME = `[${XML10_LETTER}_][${XML_NC_NAME_CHAR}]*`;

// src/dom/xml-parser.ts
var XmlParser = class {
  constructor() {
    this.regexEmpty = /\/$/;
    this.XML10_TAGNAME_REGEXP = new RegExp(`^(${XML10_NAME})`);
    this.XML10_ATTRIBUTE_REGEXP = new RegExp(XML10_ATTRIBUTE, "g");
    this.XML11_TAGNAME_REGEXP = new RegExp(`^(${XML11_NAME})`);
    this.XML11_ATTRIBUTE_REGEXP = new RegExp(XML11_ATTRIBUTE, "g");
    this.lenientHtmlTags = ["hr", "link", "meta"];
  }
  /**
   * The entry point for this parser.
   * It verifies whether the document seems to be HTML.
   * HTML is a special case if XML and it should be parsed differently.
   * @param xmlOrHtml The XML or HTML content to be parsed.
   * @returns A DOM document.
   */
  xmlParse(xmlOrHtml) {
    if (xmlOrHtml.toUpperCase().startsWith("<!DOCTYPE HTML")) {
      return this.htmlParse(xmlOrHtml);
    }
    return this.xmlStrictParse(xmlOrHtml);
  }
  /**
   * Given an XNode, returns an object mapping prefixes to their corresponding namespaces in its scope.
   * Default namespace is treated as if its prefix were the empty string.
   * @param node The Node.
   * @returns An object with prefixes and namespace URLs.
   */
  namespaceMapAt(node) {
    const map = {
      // reserved namespaces: https://www.w3.org/TR/REC-xml-names/#xmlReserved
      xmlns: "http://www.w3.org/2000/xmlns/",
      xml: "http://www.w3.org/XML/1998/namespace"
    };
    let n = node;
    while (n !== null) {
      for (let i = 0; i < n.childNodes.length; i++) {
        const childNode = n.childNodes[i];
        if (childNode.nodeType !== DOM_ATTRIBUTE_NODE) {
          continue;
        }
        if (childNode.nodeName.startsWith("xmlns:")) {
          const prefix = childNode.nodeName.split(":")[1];
          if (!(prefix in map)) map[prefix] = childNode.nodeValue;
        } else if (childNode.nodeName == "xmlns") {
          if (!("" in map)) map[""] = childNode.nodeValue || null;
        }
      }
      n = n.parentNode;
    }
    return map;
  }
  /**
   * HTML needs to be parsed differently because it's a special case of XML.
   * Sources:
   *
   * - https://blog.teamtreehouse.com/to-close-or-not-to-close-tags-in-html5
   * @param htmlText The HTML text
   * @returns A DOM document.
   */
  htmlParse(htmlText) {
    const xmlDocument = new XDocument();
    const root2 = xmlDocument;
    const stack = [];
    let parent = root2;
    stack.push(parent);
    let tag = false, quotes = false, doublequotes = false, start = 0;
    for (let i = 0; i < htmlText.length; ++i) {
      let char = htmlText.charAt(i);
      if (tag) {
        if (!doublequotes && char === "'") {
          quotes = !quotes;
        } else if (!quotes && char === '"') {
          doublequotes = !doublequotes;
        } else if (!quotes && !doublequotes && char === ">") {
          let text = htmlText.slice(start, i);
          if (text.charAt(0) === "/") {
            stack.pop();
            parent = stack[stack.length - 1];
          } else if (text.charAt(0) === "!") {
          } else {
            const empty = text.match(this.regexEmpty);
            const tagName = this.XML10_TAGNAME_REGEXP.exec(text)[1];
            let node = domCreateElement(xmlDocument, tagName);
            let attribute;
            while (attribute = this.XML10_ATTRIBUTE_REGEXP.exec(text)) {
              const val = htmlEntityDecode(attribute[5] || attribute[7] || "");
              domSetAttribute(node, attribute[1], val);
            }
            node.siblingPosition = parent.childNodes.length;
            domAppendChild(parent, node);
            if (!empty && !this.lenientHtmlTags.includes(tagName)) {
              parent = node;
              stack.push(node);
            }
          }
          start = i + 1;
          tag = false;
          quotes = false;
          doublequotes = false;
        }
      } else {
        if (char === "<") {
          let text = htmlText.slice(start, i);
          if (text && parent !== root2) {
            domAppendChild(parent, domCreateTextNode(xmlDocument, text));
          }
          if (htmlText.slice(i + 1, i + 4) === "!--") {
            let endTagIndex = htmlText.slice(i + 4).indexOf("-->");
            if (endTagIndex) {
              let node = domCreateComment(xmlDocument, htmlText.slice(i + 4, i + endTagIndex + 4));
              domAppendChild(parent, node);
              i += endTagIndex + 6;
            }
          } else if (htmlText.slice(i + 1, i + 9) === "!DOCTYPE") {
            let endTagIndex = htmlText.slice(i + 9).indexOf(">");
            if (endTagIndex) {
              const dtdValue = htmlText.slice(i + 9, i + endTagIndex + 9).trimStart();
              const node = domCreateDTDSection(xmlDocument, dtdValue);
              domAppendChild(parent, node);
              i += endTagIndex + dtdValue.length + 5;
            }
          } else {
            tag = true;
          }
          start = i + 1;
        }
      }
    }
    return xmlDocument;
  }
  /**
   * Parses the given XML string with our custom, JavaScript XML parser.
   * @param xml The XML String.
   * @returns A XDocument.
   * @author Steffen Meschkat <mesch@google.com>
   */
  xmlStrictParse(xml) {
    let regexTagname;
    let regexAttribute;
    if (xml.match(/^<\?xml/)) {
      if (xml.search(new RegExp(XML10_VERSION_INFO)) === 5) {
        regexTagname = this.XML10_TAGNAME_REGEXP;
        regexAttribute = this.XML10_ATTRIBUTE_REGEXP;
      } else if (xml.search(new RegExp(XML11_VERSION_INFO)) === 5) {
        regexTagname = this.XML11_TAGNAME_REGEXP;
        regexAttribute = this.XML11_ATTRIBUTE_REGEXP;
      } else {
        throw new Error("XML VersionInfo has an unknown version number.");
      }
    } else {
      regexTagname = this.XML10_TAGNAME_REGEXP;
      regexAttribute = this.XML10_ATTRIBUTE_REGEXP;
    }
    const xmlDocument = new XDocument();
    const root2 = xmlDocument;
    const stack = [];
    let parent = root2;
    stack.push(parent);
    let tag = false, quotes = false, doublequotes = false, start = 0;
    for (let i = 0; i < xml.length; ++i) {
      let char = xml.charAt(i);
      if (tag && !doublequotes && char === "'") {
        quotes = !quotes;
      } else if (tag && !quotes && char === '"') {
        doublequotes = !doublequotes;
      } else if (tag && char === ">" && !quotes && !doublequotes) {
        let text = xml.slice(start, i);
        if (text.charAt(0) === "/") {
          stack.pop();
          parent = stack[stack.length - 1];
        } else if (text.charAt(0) === "?") {
        } else if (text.charAt(0) === "!") {
        } else {
          const empty = text.match(this.regexEmpty);
          const tagname = regexTagname.exec(text)[1];
          let node = domCreateElement(xmlDocument, tagname);
          let attribute;
          while (attribute = regexAttribute.exec(text)) {
            const val = htmlEntityDecode(attribute[5] || attribute[7] || "");
            domSetAttribute(node, attribute[1], val);
          }
          node.siblingPosition = parent.childNodes.length;
          domAppendChild(parent, node);
          if (!empty) {
            parent = node;
            stack.push(node);
          }
          const namespaceMap = this.namespaceMapAt(node);
          if (node.prefix !== null) {
            if (node.prefix in namespaceMap) node.namespaceUri = namespaceMap[node.prefix];
          } else {
            if ("" in namespaceMap) node.namespaceUri = namespaceMap[""];
          }
          for (let i2 = 0; i2 < node.childNodes.length; ++i2) {
            const childNode = node.childNodes[i2];
            if (childNode.nodeType !== DOM_ATTRIBUTE_NODE) {
              continue;
            }
            if (childNode.prefix !== null && childNode.prefix in namespaceMap) {
              childNode.namespaceUri = namespaceMap[childNode.prefix];
            }
          }
        }
        start = i + 1;
        tag = false;
        quotes = false;
        doublequotes = false;
      } else if (!tag && char === "<") {
        let text = xml.slice(start, i);
        if (text && parent !== root2) {
          domAppendChild(parent, domCreateTextNode(xmlDocument, htmlEntityDecode(text)));
        }
        if (xml.slice(i + 1, i + 4) === "!--") {
          let endTagIndex = xml.slice(i + 4).indexOf("-->");
          if (endTagIndex) {
            let node = domCreateComment(xmlDocument, xml.slice(i + 4, i + endTagIndex + 4));
            domAppendChild(parent, node);
            i += endTagIndex + 6;
          }
        } else if (xml.slice(i + 1, i + 9) === "![CDATA[") {
          let endTagIndex = xml.slice(i + 9).indexOf("]]>");
          if (endTagIndex) {
            let node = domCreateCDATASection(xmlDocument, xml.slice(i + 9, i + endTagIndex + 9));
            domAppendChild(parent, node);
            i += endTagIndex + 11;
          }
        } else if (xml.slice(i + 1, i + 9) === "!DOCTYPE") {
          let endTagIndex = xml.slice(i + 9).indexOf(">");
          if (endTagIndex) {
            const dtdValue = xml.slice(i + 9, i + endTagIndex + 9).trimStart();
            const node = domCreateDTDSection(xmlDocument, dtdValue);
            domAppendChild(parent, node);
            i += endTagIndex + dtdValue.length + 5;
          }
        } else {
          tag = true;
        }
        start = i + 1;
      }
    }
    return root2;
  }
};

// src/xpath/lib/src/context.ts
function createContext(node, options) {
  return __spreadValues({
    node,
    position: 1,
    size: 1
  }, options);
}

// src/xpath/values/node-set-value.ts
var NodeSetValue = class {
  constructor(value) {
    this.value = value;
    this.type = "node-set";
  }
  stringValue() {
    if (this.value.length === 0) {
      return "";
    }
    return xmlValue(this.value[0]);
  }
  booleanValue() {
    return this.value.length > 0;
  }
  numberValue() {
    return parseInt(this.stringValue()) - 0;
  }
  nodeSetValue() {
    return this.value;
  }
};

// src/xpath/values/string-value.ts
var StringValue = class {
  constructor(value) {
    this.value = value;
    this.type = "string";
  }
  stringValue() {
    return String(this.value);
  }
  booleanValue() {
    return this.value.length > 0;
  }
  numberValue() {
    return this.value - 0;
  }
  nodeSetValue() {
    throw this;
  }
};

// src/xpath/values/number-value.ts
var NumberValue = class {
  constructor(value) {
    this.value = value;
    this.type = "number";
  }
  stringValue() {
    return `${this.value}`;
  }
  booleanValue() {
    return !!this.value;
  }
  numberValue() {
    return this.value - 0;
  }
  nodeSetValue() {
    throw this;
  }
};

// src/xpath/values/boolean-value.ts
var BooleanValue = class {
  constructor(value) {
    this.value = value;
    this.type = "boolean";
  }
  stringValue() {
    return `${this.value}`;
  }
  booleanValue() {
    return this.value;
  }
  numberValue() {
    return this.value ? 1 : 0;
  }
  nodeSetValue() {
    throw this;
  }
};

// src/xpath/values/map-value.ts
var MapValue = class {
  constructor(value) {
    this.value = value;
    this.type = "map";
  }
  stringValue() {
    const clean = {};
    for (const key in this.value) {
      if (key !== "__isMap") {
        clean[key] = this.value[key];
      }
    }
    return JSON.stringify(clean);
  }
  booleanValue() {
    return true;
  }
  numberValue() {
    return NaN;
  }
  nodeSetValue() {
    return [];
  }
};

// src/xpath/values/array-value.ts
var ArrayValue = class {
  constructor(value) {
    this.value = value;
    this.type = "array";
  }
  stringValue() {
    return JSON.stringify(this.value.members || []);
  }
  booleanValue() {
    return true;
  }
  numberValue() {
    return NaN;
  }
  nodeSetValue() {
    return [];
  }
};

// src/xpath/values/function-value.ts
var FunctionValue = class {
  constructor(value) {
    this.value = value;
    this.type = "function";
  }
  stringValue() {
    const name = this.value.name ? `${this.value.name}#${this.value.arity}` : `(anonymous)#${this.value.arity}`;
    return `function ${name}`;
  }
  booleanValue() {
    return true;
  }
  numberValue() {
    return NaN;
  }
  nodeSetValue() {
    return [];
  }
};

// src/xpath/expressions/node-converter.ts
init_json_to_xml_converter();
var NodeConverter = class {
  /**
   * Convert ExprContext to XPathContext for the new XPath implementation.
   * XNodes are used directly since they implement enough of the XPathNode interface.
   */
  exprContextToXPathContext(exprContext) {
    const currentNode = exprContext.nodeList[exprContext.position];
    const xpathNode = this.adaptXNode(currentNode);
    const nodeList = exprContext.nodeList.map((node) => this.adaptXNode(node));
    const extensions = {};
    let ctx = exprContext;
    while (ctx) {
      if (!extensions.regexGroups && ctx.regexGroups) {
        extensions.regexGroups = ctx.regexGroups;
      }
      if (!extensions.currentGroup && ctx.currentGroup) {
        extensions.currentGroup = ctx.currentGroup;
      }
      if (!extensions.currentGroupingKey && ctx.currentGroupingKey !== void 0) {
        extensions.currentGroupingKey = ctx.currentGroupingKey;
      }
      ctx = ctx.parent;
    }
    return createContext(xpathNode, {
      position: exprContext.position + 1,
      // XPath is 1-based
      size: exprContext.nodeList.length,
      nodeList,
      variables: this.convertVariables(exprContext),
      functions: this.createCustomFunctions(exprContext),
      namespaces: exprContext.knownNamespaces,
      xsltVersion: exprContext.xsltVersion,
      extensions: Object.keys(extensions).length > 0 ? extensions : void 0
    });
  }
  /**
   * Adapt XNode to be compatible with XPathNode interface.
   * We add missing properties but keep the original XNode reference.
   */
  adaptXNode(node) {
    if (!node) return null;
    const adapted = node;
    if (!("textContent" in adapted)) {
      Object.defineProperty(adapted, "textContent", {
        get() {
          return this._getTextContent();
        },
        enumerable: true,
        configurable: true
      });
    }
    if (!("_getTextContent" in adapted)) {
      adapted._getTextContent = function() {
        if (this.nodeType === 3 || this.nodeType === 2) {
          return this.nodeValue || "";
        }
        if (!this.childNodes) return "";
        let text = "";
        for (const child of this.childNodes) {
          if (child.nodeType === 3) {
            text += child.nodeValue || "";
          } else if (child.nodeType === 1) {
            text += this._getTextContent.call(child);
          }
        }
        return text;
      };
    }
    if (!("attributes" in adapted)) {
      Object.defineProperty(adapted, "attributes", {
        get() {
          return this.childNodes ? this.childNodes.filter((n) => n.nodeType === 2) : [];
        },
        enumerable: true,
        configurable: true
      });
    }
    if (!("getAttribute" in adapted)) {
      adapted.getAttribute = function(name) {
        return this.getAttributeValue ? this.getAttributeValue(name) : null;
      };
    }
    return adapted;
  }
  /**
   * Convert XPathNode result back to XNode.
   * Since we're now using XNodes directly, this is mostly a type cast.
   */
  xPathNodeToXNode(xpathNode) {
    if (!xpathNode) return null;
    if (xpathNode instanceof XNode) {
      return xpathNode;
    }
    return this.convertXPathNodeToXNode(xpathNode);
  }
  /**
   * Get text content from an XNode.
   */
  getTextContent(node) {
    if (node.nodeType === 3 || node.nodeType === 2) {
      return node.nodeValue || "";
    }
    if (!node.childNodes) return "";
    let text = "";
    for (const child of node.childNodes) {
      if (child.nodeType === 3) {
        text += child.nodeValue || "";
      } else if (child.nodeType === 1) {
        text += this.getTextContent(child);
      }
    }
    return text;
  }
  /**
   * Convert variables from ExprContext format to XPathContext format.
   */
  convertVariables(exprContext) {
    const variables = {};
    for (const [name, value] of Object.entries(exprContext.variables || {})) {
      if (value && typeof value === "object" && "stringValue" in value) {
        const nodeValue = value;
        if (nodeValue.type === "node-set") {
          variables[name] = value.nodeSetValue().map((n) => this.adaptXNode(n));
        } else if (nodeValue.type === "string") {
          variables[name] = value.stringValue();
        } else if (nodeValue.type === "number") {
          variables[name] = value.numberValue();
        } else if (nodeValue.type === "boolean") {
          variables[name] = value.booleanValue();
        } else if (nodeValue.type === "map") {
          variables[name] = nodeValue.value;
        } else if (nodeValue.type === "array") {
          variables[name] = nodeValue.value;
        } else if (nodeValue.type === "function") {
          variables[name] = nodeValue.value;
        } else {
          variables[name] = value.stringValue();
        }
      } else {
        variables[name] = value;
      }
    }
    return variables;
  }
  /**
   * Create custom functions for XPath context (like key(), document(), etc.).
   * Note: Custom functions receive the XPathContext as their first argument,
   * followed by the evaluated function arguments.
   */
  createCustomFunctions(exprContext) {
    const functions = {};
    functions["key"] = (_context, keyName, keyValue) => {
      var _a;
      const keyDef = (_a = exprContext.keys) == null ? void 0 : _a[keyName];
      if (keyDef && keyDef[keyValue]) {
        const nodeSetValue = keyDef[keyValue];
        return nodeSetValue.nodeSetValue().map((n) => this.adaptXNode(n));
      }
      return [];
    };
    functions["current"] = (_context) => {
      const currentNode = exprContext.nodeList[exprContext.position];
      return [this.adaptXNode(currentNode)];
    };
    functions["format-number"] = (_context, number, format, decimalFormatName) => {
      const settings = exprContext.decimalFormatSettings;
      return number.toLocaleString();
    };
    functions["xml-to-json"] = (_context, nodes) => {
      if (exprContext.xsltVersion !== "3.0") {
        throw new Error('xml-to-json() is only supported in XSLT 3.0. Use version="3.0" in your stylesheet.');
      }
      const node = Array.isArray(nodes) ? nodes[0] : nodes;
      if (!node) {
        return '""';
      }
      return this.xmlToJson(node);
    };
    functions["json-to-xml"] = (_context, jsonText) => {
      if (exprContext.xsltVersion !== "3.0") {
        throw new Error('json-to-xml() is only supported in XSLT 3.0. Use version="3.0" in your stylesheet.');
      }
      const jsonStr = Array.isArray(jsonText) ? jsonText[0] : jsonText;
      if (!jsonStr) {
        return [];
      }
      const converter = new JsonToXmlConverter();
      const xpathNode = converter.convert(String(jsonStr));
      if (!xpathNode) {
        return null;
      }
      const ownerDoc = exprContext.nodeList && exprContext.nodeList.length > 0 ? exprContext.nodeList[0].ownerDocument : null;
      const convertedNode = this.convertXPathNodeToXNode(xpathNode, ownerDoc);
      return convertedNode ? [convertedNode] : [];
    };
    functions["system-property"] = (_context, propertyName) => {
      const propName = String(propertyName);
      const systemProperties = {
        "xsl:version": exprContext.xsltVersion || "1.0",
        "xsl:vendor": "Design Liquido",
        "xsl:vendor-url": "https://github.com/DesignLiquido/xslt-processor"
      };
      if (exprContext.systemProperties && exprContext.systemProperties[propName]) {
        return exprContext.systemProperties[propName];
      }
      return systemProperties[propName] || "";
    };
    functions["element-available"] = (_context, elementName) => {
      const name = String(elementName);
      const xsltElements = [
        "xsl:apply-imports",
        "xsl:apply-templates",
        "xsl:attribute",
        "xsl:attribute-set",
        "xsl:call-template",
        "xsl:choose",
        "xsl:comment",
        "xsl:copy",
        "xsl:copy-of",
        "xsl:decimal-format",
        "xsl:element",
        "xsl:fallback",
        "xsl:for-each",
        "xsl:if",
        "xsl:import",
        "xsl:include",
        "xsl:key",
        "xsl:message",
        "xsl:namespace-alias",
        "xsl:number",
        "xsl:otherwise",
        "xsl:output",
        "xsl:param",
        "xsl:preserve-space",
        "xsl:processing-instruction",
        "xsl:sort",
        "xsl:strip-space",
        "xsl:stylesheet",
        "xsl:template",
        "xsl:text",
        "xsl:transform",
        "xsl:value-of",
        "xsl:variable",
        "xsl:when",
        "xsl:with-param"
      ];
      const normalizedName = name.startsWith("xsl:") ? name : `xsl:${name}`;
      return xsltElements.includes(normalizedName) || xsltElements.includes(name);
    };
    functions["function-available"] = (_context, functionName2) => {
      const name = String(functionName2);
      const xpathCoreFunctions = [
        "boolean",
        "ceiling",
        "concat",
        "contains",
        "count",
        "false",
        "floor",
        "id",
        "lang",
        "last",
        "local-name",
        "name",
        "namespace-uri",
        "normalize-space",
        "not",
        "number",
        "position",
        "round",
        "starts-with",
        "string",
        "string-length",
        "substring",
        "substring-after",
        "substring-before",
        "sum",
        "translate",
        "true"
      ];
      const xsltFunctions = [
        "current",
        "document",
        "element-available",
        "format-number",
        "function-available",
        "generate-id",
        "key",
        "system-property",
        "unparsed-entity-uri"
      ];
      const additionalFunctions = [
        "matches",
        "ends-with",
        "xml-to-json",
        "json-to-xml"
      ];
      const allFunctions = [...xpathCoreFunctions, ...xsltFunctions, ...additionalFunctions];
      return allFunctions.includes(name);
    };
    functions["document"] = (_context, uriOrNodeSet, _baseNode) => {
      var _a, _b;
      if (exprContext.documentLoader) {
        const uri = Array.isArray(uriOrNodeSet) ? ((_a = uriOrNodeSet[0]) == null ? void 0 : _a.textContent) || String(uriOrNodeSet[0] || "") : String(uriOrNodeSet || "");
        if (!uri) {
          return exprContext.root ? [this.adaptXNode(exprContext.root)] : [];
        }
        try {
          const doc = exprContext.documentLoader(uri);
          if (doc) {
            return [this.adaptXNode(doc)];
          }
        } catch (e) {
          const warn = (_b = exprContext.warningsCallback) != null ? _b : console.warn;
          warn(`document() failed to load: ${uri}`, e);
        }
      }
      return [];
    };
    functions["unparsed-entity-uri"] = (_context, entityName) => {
      const name = String(entityName);
      if (exprContext.unparsedEntities && exprContext.unparsedEntities[name]) {
        return exprContext.unparsedEntities[name];
      }
      return "";
    };
    let ctx = exprContext;
    while (ctx) {
      if (ctx.userDefinedFunctions) {
        ctx.userDefinedFunctions.forEach((funcInfo, funcName) => {
          if (!functions[funcName]) {
            functions[funcName] = (_context, ...args) => {
              return funcInfo.executor(exprContext, funcInfo.functionDef, args);
            };
          }
        });
        break;
      }
      ctx = ctx.parent;
    }
    return functions;
  }
  /**
   * Convert an XPathNode interface tree to actual XNode objects.
   * This is needed to convert json-to-xml() output to XSLT-compatible nodes.
   */
  convertXPathNodeToXNode(xpathNode, ownerDoc) {
    if (!xpathNode) {
      return null;
    }
    let node;
    if (xpathNode.nodeType === DOM_DOCUMENT_NODE) {
      if (xpathNode.childNodes && xpathNode.childNodes.length > 0) {
        const rootChild = xpathNode.childNodes[0];
        node = this.convertXPathNodeToXNode(rootChild, ownerDoc);
        return node;
      }
      return null;
    } else if (xpathNode.nodeType === DOM_TEXT_NODE) {
      const textContent = xpathNode.textContent || "";
      node = new XNode(
        DOM_TEXT_NODE,
        "#text",
        textContent,
        ownerDoc
      );
    } else {
      node = new XNode(
        DOM_ELEMENT_NODE,
        xpathNode.nodeName || "element",
        "",
        ownerDoc
      );
      if (xpathNode.namespaceUri) {
        node.namespaceUri = xpathNode.namespaceUri;
      }
      if (xpathNode.childNodes && xpathNode.childNodes.length > 0) {
        for (let i = 0; i < xpathNode.childNodes.length; i++) {
          const childXPathNode = xpathNode.childNodes[i];
          const childXNode = this.convertXPathNodeToXNode(childXPathNode, ownerDoc);
          if (childXNode) {
            childXNode.parentNode = node;
            node.childNodes.push(childXNode);
          }
        }
        if (node.childNodes.length > 0) {
          node.firstChild = node.childNodes[0];
          node.lastChild = node.childNodes[node.childNodes.length - 1];
        }
      }
    }
    return node;
  }
  /**
   * Convert an XML node to a JSON string representation.
   * This is a simplified implementation of XSLT 3.0's xml-to-json().
   */
  xmlToJson(node) {
    if (!node) {
      return '""';
    }
    const textContent = xmlValue(node, true);
    return JSON.stringify(textContent);
  }
  /**
   * Wrap XPath result in appropriate NodeValue type.
   */
  wrapResult(result, exprContext) {
    if (result === null || result === void 0) {
      return new NodeSetValue([]);
    }
    if (Array.isArray(result)) {
      const nodes = result.map((node) => this.xPathNodeToXNode(node)).filter((n) => n !== null);
      if (nodes.length > 0 || result.length === 0) {
        return new NodeSetValue(nodes);
      }
      return new StringValue(result.map((item) => String(item)).join(" "));
    }
    if (typeof result === "string") {
      return new StringValue(result);
    }
    if (typeof result === "number") {
      return new NumberValue(result);
    }
    if (typeof result === "boolean") {
      return new BooleanValue(result);
    }
    if (typeof result === "object") {
      if (result.__isMap) {
        return new MapValue(result);
      }
      if (result.__isArray) {
        return new ArrayValue(result);
      }
      if (result.__isFunctionItem) {
        return new FunctionValue(result);
      }
    }
    return new NodeSetValue([]);
  }
  /**
   * Clear any internal state if needed.
   */
  clearCache() {
  }
};

// src/xpath/expressions/expression.ts
init_expressions();
var Expression = class {
  constructor(xpathExpression, nodeConverter) {
    this.xpathExpression = xpathExpression;
    this.nodeConverter = nodeConverter;
    if (xpathExpression instanceof XPathLocationPath) {
      this.absolute = xpathExpression.absolute;
      this.steps = xpathExpression.steps.map((step, index) => ({
        axis: step.axis,
        nodeTest: step.nodeTest,
        predicates: step.predicates,
        // Add methods needed by old code
        hasPositionalPredicate: false,
        // TODO: implement proper detection
        predicate: step.predicates || [],
        evaluate: (ctx) => {
          const xpathCtx = this.nodeConverter.exprContextToXPathContext(ctx);
          const result = step.evaluate(xpathCtx);
          return this.nodeConverter.wrapResult(result, ctx);
        }
      }));
    }
  }
  /**
   * Evaluate the expression in the given context.
   */
  evaluate(context) {
    const xpathContext = this.nodeConverter.exprContextToXPathContext(context);
    const result = this.xpathExpression.evaluate(xpathContext);
    return this.nodeConverter.wrapResult(result, context);
  }
};

// src/xpath/expressions/location-expr.ts
var LocationExpr = class extends Expression {
  constructor(xpathExpression, nodeConverter) {
    super(xpathExpression, nodeConverter);
    this.absolute = xpathExpression.absolute;
    this.steps = xpathExpression.steps.map((step) => ({
      axis: step.axis,
      nodeTest: step.nodeTest,
      predicates: step.predicates || [],
      predicate: step.predicates || [],
      hasPositionalPredicate: this.hasPositionalPredicate(step.predicates || [])
    }));
  }
  hasPositionalPredicate(predicates) {
    return false;
  }
  appendStep(step) {
    this.steps.push(step);
  }
  prependStep(step) {
    this.steps.unshift(step);
  }
};

// src/xpath/expressions/union-expr.ts
var UnionExpr = class extends Expression {
  constructor(xpathExpression, nodeConverter, expr1, expr2) {
    super(xpathExpression, nodeConverter);
    this.expr1 = expr1;
    this.expr2 = expr2;
  }
};

// src/xpath/xpath.ts
var XPath = class {
  constructor() {
    this.lexers = /* @__PURE__ */ new Map();
    this.parsers = /* @__PURE__ */ new Map();
    this.parseCache = /* @__PURE__ */ new Map();
    this.nodeConverter = new NodeConverter();
  }
  getLexer(version) {
    const v = version || "1.0";
    if (!this.lexers.has(v)) {
      this.lexers.set(v, new XPathLexer({ version: v }));
    }
    return this.lexers.get(v);
  }
  getParser(version) {
    const v = version || "1.0";
    if (!this.parsers.has(v)) {
      this.parsers.set(v, createXPathParser(v));
    }
    return this.parsers.get(v);
  }
  /**
   * Parse an XPath expression and return an Expression object.
   * @param expression The XPath expression string.
   * @param axis Optional axis override for relative paths.
   * @param version Optional XPath version (defaults to 1.0).
   */
  xPathParse(expression, axis, version = "1.0") {
    const cacheKey = `${expression}:${axis || ""}:${version}`;
    if (this.parseCache.has(cacheKey)) {
      return this.parseCache.get(cacheKey);
    }
    const lexer = this.getLexer(version);
    const parser = this.getParser(version);
    const tokens = lexer.scan(expression);
    const xpathExpr = parser.parse(tokens);
    const wrappedExpr = this.wrapExpression(xpathExpr, axis);
    this.parseCache.set(cacheKey, wrappedExpr);
    return wrappedExpr;
  }
  /**
   * Parse and evaluate an XPath expression.
   * @param select The XPath expression string.
   * @param context The expression context.
   */
  xPathEval(select, context) {
    const version = context.xsltVersion || "1.0";
    const effectiveVersion = version === "3.0" ? "3.1" : version;
    const expression = this.xPathParse(select, void 0, effectiveVersion);
    return expression.evaluate(context);
  }
  /**
   * Sort nodes in context according to sort specifications.
   * @param context The expression context with nodes to sort.
   * @param sort Array of sort specifications.
   */
  xPathSort(context, sort2) {
    if (sort2.length === 0) {
      return;
    }
    const sortList = [];
    for (let i = 0; i < context.contextSize(); ++i) {
      const node = context.nodeList[i];
      const sortItem = {
        node,
        key: []
      };
      const clonedContext = context.clone([node], 0);
      for (const s of sort2) {
        const value = s.expr.evaluate(clonedContext);
        let evalue;
        if (s.type === "text") {
          evalue = value.stringValue();
        } else if (s.type === "number") {
          evalue = value.numberValue();
        }
        sortItem.key.push({
          value: evalue,
          order: s.order
        });
      }
      sortItem.key.push({
        value: i,
        order: "ascending"
      });
      sortList.push(sortItem);
    }
    sortList.sort(this.xPathSortByKey);
    const nodes = [];
    for (let i = 0; i < sortList.length; ++i) {
      const node = sortList[i].node;
      node.siblingPosition = i;
      nodes.push(node);
    }
    context.nodeList = nodes;
    context.setNode(0);
  }
  /**
   * Comparison function for sorting.
   */
  xPathSortByKey(v1, v2) {
    for (let i = 0; i < v1.key.length; ++i) {
      const o = v1.key[i].order === "descending" ? -1 : 1;
      if (v1.key[i].value > v2.key[i].value) {
        return 1 * o;
      }
      if (v1.key[i].value < v2.key[i].value) {
        return -1 * o;
      }
    }
    return 0;
  }
  /**
   * Wrap a new XPath expression in the backward-compatible Expression class.
   */
  wrapExpression(xpathExpr, axis) {
    if (xpathExpr instanceof XPathLocationPath) {
      if (axis && xpathExpr.steps.length > 0 && !xpathExpr.absolute) {
        xpathExpr.steps[0].axis = axis;
      }
      return new LocationExpr(xpathExpr, this.nodeConverter);
    }
    if (xpathExpr instanceof XPathUnionExpression) {
      const expr1 = this.wrapExpression(xpathExpr.left, axis);
      const expr2 = this.wrapExpression(xpathExpr.right, axis);
      return new UnionExpr(xpathExpr, this.nodeConverter, expr1, expr2);
    }
    return new Expression(xpathExpr, this.nodeConverter);
  }
  /**
   * Clear parse cache (useful for testing or memory management).
   */
  clearCache() {
    this.parseCache.clear();
    this.nodeConverter.clearCache();
  }
};

// src/xpath/tokens.ts
var TOK_NUMBER = {
  label: "[number]",
  prec: 35,
  re: new RegExp("^\\d+(\\.\\d*)?"),
  key: void 0
};

// src/xpath/expr-context.ts
var ExprContext = class _ExprContext {
  /**
   * Constructor -- gets the node, its position, the node set it
   * belongs to, and a parent context as arguments. The parent context
   * is used to implement scoping rules for variables: if a variable
   * is not found in the current context, it is looked for in the
   * parent context, recursively. Except for node, all arguments have
   * default values: default position is 0, default node set is the
   * set that contains only the node, and the default parent is null.
   *
   * Notice that position starts at 0 at the outside interface;
   * inside XPath expressions this shows up as position()=1.
   * @param nodeList TODO
   * @param opt_position TODO
   * @param opt_parent TODO
   * @param opt_caseInsensitive TODO
   * @param opt_ignoreAttributesWithoutValue TODO
   * @param opt_returnOnFirstMatch TODO
   * @param opt_ignoreNonElementNodesForNTA TODO
   */
  constructor(nodeList, xsltVersion = "1.0", opt_position, opt_decimalFormatSettings, opt_variables, opt_knownNamespaces, opt_parent, opt_caseInsensitive, opt_ignoreAttributesWithoutValue, opt_returnOnFirstMatch, opt_ignoreNonElementNodesForNTA, opt_warningsCallback) {
    this.nodeList = nodeList;
    this.xsltVersion = xsltVersion;
    this.position = opt_position || 0;
    this.variables = opt_variables || {};
    this.keys = (opt_parent == null ? void 0 : opt_parent.keys) || {};
    this.knownNamespaces = opt_knownNamespaces || {};
    this.parent = opt_parent || null;
    this.caseInsensitive = opt_caseInsensitive || false;
    this.ignoreAttributesWithoutValue = opt_ignoreAttributesWithoutValue || false;
    this.returnOnFirstMatch = opt_returnOnFirstMatch || false;
    this.ignoreNonElementNodesForNTA = opt_ignoreNonElementNodesForNTA || false;
    this.inApplyTemplates = false;
    this.baseTemplateMatched = false;
    this.warningsCallback = opt_warningsCallback != null ? opt_warningsCallback : opt_parent == null ? void 0 : opt_parent.warningsCallback;
    this.decimalFormatSettings = opt_decimalFormatSettings || {
      decimalSeparator: ".",
      groupingSeparator: ",",
      infinity: "Infinity",
      minusSign: "-",
      naN: "NaN",
      percent: "%",
      perMille: "\u2030",
      zeroDigit: "0",
      digit: "#",
      patternSeparator: ";"
    };
    if (opt_parent) {
      this.root = opt_parent.root;
    } else if (this.nodeList[this.position].nodeType == DOM_DOCUMENT_NODE) {
      this.root = this.nodeList[this.position];
    } else {
      this.root = this.nodeList[this.position].ownerDocument;
    }
  }
  /**
   * clone() -- creates a new context with the current context as
   * parent. If passed as argument to clone(), the new context has a
   * different node, position, or node set. What is not passed is
   * inherited from the cloned context.
   * @param opt_nodeList TODO
   * @param opt_position TODO
   * @returns TODO
   */
  clone(opt_nodeList, opt_position) {
    return new _ExprContext(
      opt_nodeList || this.nodeList,
      this.xsltVersion,
      typeof opt_position !== "undefined" ? opt_position : this.position,
      this.decimalFormatSettings,
      this.variables,
      this.knownNamespaces,
      this,
      this.caseInsensitive,
      this.ignoreAttributesWithoutValue,
      this.returnOnFirstMatch,
      this.ignoreNonElementNodesForNTA,
      this.warningsCallback
    );
  }
  setVariable(name, value) {
    if (value instanceof StringValue || value instanceof BooleanValue || value instanceof NumberValue || value instanceof NodeSetValue || value instanceof MapValue || value instanceof ArrayValue || value instanceof FunctionValue) {
      this.variables[name] = value;
      return;
    }
    if ("true" === value) {
      this.variables[name] = new BooleanValue(true);
    } else if ("false" === value) {
      this.variables[name] = new BooleanValue(false);
    } else if (TOK_NUMBER.re.test(String(value))) {
      this.variables[name] = new NumberValue(value);
    } else {
      this.variables[name] = new StringValue(value);
    }
  }
  getVariable(name) {
    if (typeof this.variables[name] != "undefined") {
      return this.variables[name];
    }
    if (this.parent) {
      return this.parent.getVariable(name);
    }
    return null;
  }
  /**
   * Gets a regex group from xsl:analyze-string context.
   * Searches up the parent chain for regexGroups.
   * @param index Group index (0 = full match, 1+ = captured groups)
   * @returns The group value or empty string if not found
   */
  getRegexGroup(index) {
    var _a;
    if (this.regexGroups && index >= 0 && index < this.regexGroups.length) {
      return (_a = this.regexGroups[index]) != null ? _a : "";
    }
    if (this.parent) {
      return this.parent.getRegexGroup(index);
    }
    return "";
  }
  setNode(position) {
    this.position = position;
  }
  contextSize() {
    return this.nodeList.length;
  }
  isCaseInsensitive() {
    return this.caseInsensitive;
  }
  setCaseInsensitive(caseInsensitive) {
    return this.caseInsensitive = caseInsensitive;
  }
  isIgnoreAttributesWithoutValue() {
    return this.ignoreAttributesWithoutValue;
  }
  setIgnoreAttributesWithoutValue(ignore) {
    return this.ignoreAttributesWithoutValue = ignore;
  }
  isReturnOnFirstMatch() {
    return this.returnOnFirstMatch;
  }
  setReturnOnFirstMatch(returnOnFirstMatch) {
    return this.returnOnFirstMatch = returnOnFirstMatch;
  }
  isIgnoreNonElementNodesForNTA() {
    return this.ignoreNonElementNodesForNTA;
  }
  setIgnoreNonElementNodesForNTA(ignoreNonElementNodesForNTA) {
    return this.ignoreNonElementNodesForNTA = ignoreNonElementNodesForNTA;
  }
};

// src/xpath/match-resolver.ts
var MatchResolver = class {
  /**
   * Entry point for expression matching.
   * @param expression The expression to be resolved.
   * @param context The Expression Context.
   * @returns An array of nodes.
   */
  expressionMatch(expression, context) {
    if (expression instanceof LocationExpr) {
      return this.locationExpressionMatch(expression, context);
    }
    if (expression instanceof UnionExpr) {
      return this.unionExpressionMatch(expression, context);
    }
    try {
      const result = expression.evaluate(context);
      return result.nodeSetValue();
    } catch (e) {
      return [];
    }
  }
  /**
   * Resolves a LocationExpr.
   * @param expression The Location Expression.
   * @param context The Expression Context.
   * @returns Either the results of a relative resolution, or the results of an
   *          absolute resolution.
   */
  locationExpressionMatch(expression, context) {
    if (!expression.steps || expression.steps.length <= 0) {
      if (expression.absolute) {
        const contextNode = context.nodeList[context.position];
        if (contextNode.nodeName === "#document") {
          return [contextNode];
        }
        return [];
      }
      return [context.nodeList[context.position]];
    }
    if (expression.absolute) {
      const firstStep = expression.steps[0];
      if (firstStep.axis === "self") {
        return this.absoluteXsltMatchByDocumentNode(expression, context);
      }
      return this.absoluteXsltMatch(expression, context);
    }
    return this.relativeXsltMatch(expression, context);
  }
  /**
   * Resolves a UnionExpr.
   * @param expression The Union Expression.
   * @param context The Expression Context.
   * @returns The concatenated result of evaluating both sides of the expression.
   */
  unionExpressionMatch(expression, context) {
    const expr1Nodes = this.expressionMatch(expression.expr1, context);
    return expr1Nodes.concat(this.expressionMatch(expression.expr2, context));
  }
  /**
   * Finds all the nodes through absolute XPath search, starting on
   * the #document parent node.
   * @param expression The Expression.
   * @param context The Expression Context.
   * @returns The list of found nodes.
   */
  absoluteXsltMatchByDocumentNode(expression, context) {
    const clonedContext = context.clone([context.root], 0);
    const matchedNodes = expression.evaluate(clonedContext).nodeSetValue();
    const finalList = [];
    for (const element of matchedNodes) {
      if (element.id === context.nodeList[context.position].id) {
        finalList.push(element);
      }
    }
    return finalList;
  }
  /**
   * Finds all the nodes through absolute XPath search, starting with the
   * first child of the #document node.
   * @param expression The Expression.
   * @param context The Expression Context.
   * @returns The list of found nodes.
   */
  absoluteXsltMatch(expression, context) {
    var _a;
    const firstChildOfRoot = context.root.childNodes.find((c) => c.nodeName !== "#dtd-section");
    if (!firstChildOfRoot) return [];
    const clonedContext = context.clone([firstChildOfRoot], 0);
    const matchedNodes = expression.evaluate(clonedContext).nodeSetValue();
    const finalList = [];
    let nodeList;
    if (context.nodeList.length === 1 && context.nodeList[0].nodeName === "#document") {
      nodeList = [context.nodeList[0].childNodes.find((c) => c.nodeName !== "#dtd-section")];
    } else {
      nodeList = context.nodeList;
    }
    for (const element of matchedNodes) {
      if (element.id === ((_a = nodeList[context.position]) == null ? void 0 : _a.id)) {
        finalList.push(element);
      }
    }
    return finalList;
  }
  /**
   * Tries to find relative nodes from the actual context position.
   * If found nodes are already in the context, or if they are children of
   * nodes in the context, they are returned.
   * @param expression The expression used.
   * @param context The Expression Context.
   * @returns The list of found nodes.
   */
  relativeXsltMatch(expression, context) {
    const clonedContext = context.clone();
    const nodes = expression.evaluate(clonedContext).nodeSetValue();
    if (nodes.length === 1 && nodes[0].nodeName === "#document") {
      return [nodes[0].childNodes[0]];
    }
    return nodes;
  }
};

// src/xpath/node-tests/node-test-any.ts
var NodeTestAny = class {
  constructor() {
    this.value = new BooleanValue(true);
  }
  evaluate() {
    return this.value;
  }
};

// src/xpath/node-tests/node-test-comment.ts
var NodeTestComment = class {
  evaluate(ctx) {
    return new BooleanValue(ctx.nodeList[ctx.position].nodeType == DOM_COMMENT_NODE);
  }
};

// src/xpath/node-tests/node-test-element-or-attribute.ts
var NodeTestElementOrAttribute = class {
  evaluate(context) {
    const node = context.nodeList[context.position];
    return new BooleanValue(node.nodeType == DOM_ELEMENT_NODE || node.nodeType == DOM_ATTRIBUTE_NODE);
  }
};

// src/xpath/node-tests/node-test-name.ts
var NodeTestName = class {
  constructor(name) {
    this.name = name;
    if (name.indexOf(":") > 0) {
      const nameAndNamespacePrefix = name.split(":");
      this.namespacePrefix = nameAndNamespacePrefix[0];
      this.name = nameAndNamespacePrefix[1];
    }
    this.re = new RegExp(`^${name}$`, "i");
  }
  evaluate(context) {
    const node = context.nodeList[context.position];
    if (this.namespacePrefix !== void 0) {
      const namespaceValue = context.knownNamespaces[this.namespacePrefix];
      if (namespaceValue !== node.namespaceUri) {
        return new BooleanValue(false);
      }
      if (context.caseInsensitive) {
        if (node.localName.length !== this.name.length) return new BooleanValue(false);
        return new BooleanValue(this.re.test(node.localName));
      }
      return new BooleanValue(node.localName === this.name);
    }
    if (context.caseInsensitive) {
      if (node.nodeName.length !== this.name.length) return new BooleanValue(false);
      return new BooleanValue(this.re.test(node.nodeName));
    }
    return new BooleanValue(node.nodeName === this.name);
  }
};

// src/xpath/node-tests/node-test-nc.ts
var NodeTestNC = class {
  constructor(nsprefix) {
    this.regex = new RegExp(`^${nsprefix}:`);
    this.nsprefix = nsprefix;
  }
  evaluate(ctx) {
    const n = ctx.nodeList[ctx.position];
    return new BooleanValue(n.nodeName.match(this.regex));
  }
};

// src/xpath/node-tests/node-test-pi.ts
var NodeTestPI = class {
  constructor(target) {
    this.target = target;
  }
  evaluate(context) {
    const node = context.nodeList[context.position];
    return new BooleanValue(
      node.nodeType == DOM_PROCESSING_INSTRUCTION_NODE && (!this.target || node.nodeName == this.target)
    );
  }
};

// src/xpath/node-tests/node-test-text.ts
var NodeTestText = class {
  evaluate(ctx) {
    return new BooleanValue(ctx.nodeList[ctx.position].nodeType == DOM_TEXT_NODE);
  }
};

// src/xslt/package-system/functions.ts
function makeComponentKey(component) {
  switch (component.type) {
    case "function":
    case "variable":
    case "attribute-set":
      return `${component.type}:${component.name || ""}`;
    case "template":
      if (component.name) {
        return `template:name:${component.name}`;
      } else if (component.match) {
        const mode = component.mode || "#default";
        return `template:match:${mode}:${component.match}`;
      }
      return "template:unknown";
    case "mode":
      return `mode:${component.name || "#default"}`;
    default:
      return `unknown:${component.type}`;
  }
}
function isComponentVisible(component, fromPackage) {
  if (component.visibility === "private") {
    return fromPackage;
  }
  return true;
}
function canOverrideComponent(component) {
  if (component.visibility === "final") {
    return false;
  }
  return component.overridable;
}

// src/xslt/package-system/package-registry.ts
var PackageRegistry = class {
  constructor() {
    this.packages = /* @__PURE__ */ new Map();
    this.loading = /* @__PURE__ */ new Set();
  }
  /**
   * Register a package in the registry.
   */
  register(pkg) {
    const key = this.makePackageKey(pkg.name, pkg.version);
    this.packages.set(key, pkg);
  }
  /**
   * Retrieve a package from the registry.
   * Supports version constraints: exact, wildcards (1.*), ranges (>=1.0), and combined (>=1.0,<2.0).
   */
  get(name, version) {
    if (!version) {
      return this.packages.get(name);
    }
    const exactKey = this.makePackageKey(name, version);
    const exactMatch = this.packages.get(exactKey);
    if (exactMatch) {
      return exactMatch;
    }
    const hasConstraint = /[*<>=,]/.test(version);
    if (!hasConstraint) {
      return void 0;
    }
    const matchingPackages = [];
    this.packages.forEach((pkg, key) => {
      if (pkg.name === name && pkg.version && this.satisfiesVersion(pkg.version, version)) {
        matchingPackages.push(pkg);
      }
    });
    if (matchingPackages.length === 0) {
      return void 0;
    }
    matchingPackages.sort((a, b) => this.compareVersions(b.version, a.version));
    return matchingPackages[0];
  }
  /**
   * Check if a package version satisfies a version constraint.
   */
  satisfiesVersion(packageVersion, constraint) {
    if (constraint.includes(",")) {
      const constraints = constraint.split(",").map((c) => c.trim());
      return constraints.every((c) => this.satisfiesSingleConstraint(packageVersion, c));
    }
    return this.satisfiesSingleConstraint(packageVersion, constraint);
  }
  /**
   * Evaluate a single version constraint.
   */
  satisfiesSingleConstraint(packageVersion, constraint) {
    if (constraint.includes("*")) {
      const prefix = constraint.replace(/\*$/, "").replace(/\.$/, "");
      if (!prefix) {
        return true;
      }
      const pkgParts = packageVersion.split(".");
      const prefixParts = prefix.split(".");
      for (let i = 0; i < prefixParts.length; i++) {
        if (pkgParts[i] !== prefixParts[i]) {
          return false;
        }
      }
      return true;
    }
    const operatorMatch = constraint.match(/^(>=|<=|>|<|=)?(.+)$/);
    if (!operatorMatch) {
      return false;
    }
    const operator = operatorMatch[1] || "=";
    const targetVersion = operatorMatch[2].trim();
    const comparison = this.compareVersions(packageVersion, targetVersion);
    switch (operator) {
      case ">=":
        return comparison >= 0;
      case ">":
        return comparison > 0;
      case "<=":
        return comparison <= 0;
      case "<":
        return comparison < 0;
      case "=":
      default:
        return comparison === 0;
    }
  }
  /**
   * Compare two semantic versions.
   * @returns -1 if a < b, 0 if a === b, 1 if a > b
   */
  compareVersions(a, b) {
    const aParts = a.split(".").map((p) => parseInt(p, 10) || 0);
    const bParts = b.split(".").map((p) => parseInt(p, 10) || 0);
    const maxLength = Math.max(aParts.length, bParts.length);
    for (let i = 0; i < maxLength; i++) {
      const aPart = aParts[i] || 0;
      const bPart = bParts[i] || 0;
      if (aPart < bPart) return -1;
      if (aPart > bPart) return 1;
    }
    return 0;
  }
  /**
   * Check if a package exists in the registry.
   */
  has(name, version) {
    const key = this.makePackageKey(name, version);
    return this.packages.has(key);
  }
  /**
   * Mark a package as currently being loaded.
   * Used to detect circular dependencies.
   * @returns true if the package can be loaded, false if it's already being loaded (circular dependency)
   */
  beginLoading(packageKey) {
    if (this.loading.has(packageKey)) {
      return false;
    }
    this.loading.add(packageKey);
    return true;
  }
  /**
   * Mark a package as finished loading.
   */
  endLoading(packageKey) {
    this.loading.delete(packageKey);
  }
  /**
   * Check if a package is currently being loaded.
   * Used to detect circular dependencies when a package tries to use another package that is still loading.
   */
  isLoading(packageKey) {
    return this.loading.has(packageKey);
  }
  /**
   * Create a unique key for a package based on name and version.
   */
  makePackageKey(name, version) {
    return version ? `${name}@${version}` : name;
  }
  /**
   * Clear all registered packages.
   */
  clear() {
    this.packages.clear();
    this.loading.clear();
  }
};

// src/xslt/streaming/streamable-pattern-validator.ts
var StreamablePatternValidator = class {
  /**
   * Validate that a pattern is streamable.
   * Streamable patterns have restrictions:
   * - No backward axes
   * - No ancestor selection
   * - Limited predicate support
   */
  static validatePattern(pattern) {
    const issues = [];
    if (pattern.includes("ancestor::") || pattern.includes("ancestor-or-self::")) {
      issues.push("Ancestor axes are not permitted in streamable patterns");
    }
    if (pattern.includes("parent::")) {
      issues.push("Parent axis is not permitted in streamable patterns");
    }
    if (pattern.includes("preceding::") || pattern.includes("preceding-sibling::")) {
      issues.push("Preceding axes are not permitted in streamable patterns");
    }
    const predicateMatches = pattern.match(/\[.*\]/g);
    if (predicateMatches) {
      for (const predicate of predicateMatches) {
        if (predicate.includes("[") && predicate.includes("]")) {
          if (predicate.includes("[[")) {
            issues.push("Nested predicates are not permitted in streamable patterns");
          }
        }
      }
    }
    return {
      isStreamable: issues.length === 0,
      issues
    };
  }
  /**
   * Convert a pattern to streamable form if possible.
   */
  static toStreamablePath(pattern) {
    const parts = pattern.split("/").filter((p) => p.length > 0);
    if (parts.length === 0) {
      return null;
    }
    return {
      path: parts.map((p) => p.split("[")[0]),
      // Remove predicates for now
      fromRoot: pattern.startsWith("/"),
      hasPredicates: pattern.includes("["),
      hasForwardAxis: pattern.includes("::"),
      isDeterministic: true
      // Simplified check
    };
  }
};

// src/xslt/streaming/streaming-context.ts
var StreamingContext = class {
  constructor() {
    /** Stack of open elements during streaming */
    this.elementStack = [];
    /** Current depth in document */
    this.depth = 0;
    /** Copy operations in progress */
    this.activeCopies = /* @__PURE__ */ new Map();
    /** Merge sources being processed */
    this.mergeSources = [];
    /** Whether streaming is in progress */
    this.isStreaming = false;
    /** Buffer for lookahead when needed */
    this.lookaheadBuffer = [];
  }
  /**
   * Start streaming processing.
   */
  startStreaming() {
    this.elementStack = [];
    this.depth = 0;
    this.activeCopies.clear();
    this.isStreaming = true;
  }
  /**
   * End streaming processing.
   */
  endStreaming() {
    this.isStreaming = false;
    this.activeCopies.clear();
    this.lookaheadBuffer = [];
  }
  /**
   * Register a copy operation.
   */
  registerCopy(copy) {
    this.activeCopies.set(copy.id, copy);
  }
  /**
   * Unregister a copy operation.
   */
  unregisterCopy(copyId) {
    this.activeCopies.delete(copyId);
  }
  /**
   * Get all active copies.
   */
  getActiveCopies() {
    return Array.from(this.activeCopies.values()).filter((c) => c.isActive);
  }
  /**
   * Push element onto stack when entering.
   */
  enterElement(name) {
    this.elementStack.push(name);
    this.depth++;
  }
  /**
   * Pop element from stack when exiting.
   */
  exitElement() {
    this.depth--;
    return this.elementStack.pop();
  }
  /**
   * Get current element path.
   */
  getCurrentPath() {
    return [...this.elementStack];
  }
  /**
   * Get current depth.
   */
  getDepth() {
    return this.depth;
  }
  /**
   * Check if streaming is active.
   */
  isStreamingActive() {
    return this.isStreaming;
  }
  /**
   * Buffer event for lookahead.
   */
  bufferEvent(event) {
    this.lookaheadBuffer.push(event);
  }
  /**
   * Get buffered events.
   */
  getBufferedEvents() {
    return this.lookaheadBuffer;
  }
  /**
   * Clear buffer.
   */
  clearBuffer() {
    this.lookaheadBuffer = [];
  }
};

// src/xslt/streaming/streaming-copy-manager.ts
var StreamingCopyManager = class {
  constructor() {
    this.copies = /* @__PURE__ */ new Map();
    this.copyIdCounter = 0;
  }
  /**
   * Create a new copy operation.
   */
  createCopy(handler) {
    const id = `copy-${++this.copyIdCounter}`;
    const copy = {
      id,
      handler,
      isActive: true,
      eventQueue: [],
      currentDepth: 0
    };
    this.copies.set(id, copy);
    return copy;
  }
  /**
   * Distribute an event to all active copies.
   */
  distributeEvent(event) {
    return __async(this, null, function* () {
      for (const copy of Array.from(this.copies.values())) {
        if (copy.isActive) {
          copy.eventQueue.push(event);
        }
      }
    });
  }
  /**
   * Close a copy operation.
   */
  closeCopy(copyId) {
    const copy = this.copies.get(copyId);
    if (copy) {
      copy.isActive = false;
    }
  }
  /**
   * Get copy by ID.
   */
  getCopy(copyId) {
    return this.copies.get(copyId);
  }
  /**
   * Clear all copies.
   */
  clear() {
    this.copies.clear();
    this.copyIdCounter = 0;
  }
};

// src/xslt/streaming/streaming-merge-coordinator.ts
var StreamingMergeCoordinator = class {
  constructor() {
    this.sources = [];
  }
  /**
   * Add a merge source.
   */
  addSource(source) {
    this.sources.push(source);
  }
  /**
   * Get next item(s) for merging.
   * Returns the item(s) with the smallest merge key value.
   */
  getNextMergeGroup() {
    if (this.sources.every((s) => s.isExhausted)) {
      return [];
    }
    let minSource = null;
    let minKey = null;
    for (const source of this.sources) {
      if (!source.isExhausted && source.buffer.length > 0) {
        if (minSource === null) {
          minSource = source;
          minKey = source.buffer[0];
        }
      }
    }
    if (minSource === null) {
      return [];
    }
    const result = [];
    while (minSource.buffer.length > 0 && result.length < 1) {
      result.push(minSource.buffer.shift());
    }
    return result;
  }
  /**
   * Check if merge is complete.
   */
  isComplete() {
    return this.sources.every((s) => s.isExhausted && s.buffer.length === 0);
  }
  /**
   * Clear merge state.
   */
  clear() {
    this.sources = [];
  }
};

// src/xslt/streaming/streaming-mode-detector.ts
var StreamingModeDetector = class {
  /**
   * Determine streaming mode for a template.
   */
  static detectMode(templateNode) {
    var _a;
    const streamableAttr = (_a = templateNode.getAttributeValue) == null ? void 0 : _a.call(templateNode, "streamable");
    if (streamableAttr === "yes") {
      return "streamed";
    }
    if (streamableAttr === "no") {
      return "non-consuming";
    }
    return "non-consuming";
  }
  /**
   * Check if template body is streamable.
   */
  static isTemplateBodyStreamable(templateNode) {
    const nonStreamableInstructions = [
      "xsl:variable",
      // Variables consume input
      "xsl:result-document",
      // Can't produce multiple documents in streaming
      "xsl:for-each"
      // Can't iterate over sequences in streaming
    ];
    return true;
  }
};

// src/xslt/streaming/streaming-parser-base.ts
var StreamingParserBase = class {
  /**
   * Convert a DOM document to streaming events.
   * This is a fallback for when a true streaming parser isn't available.
   */
  parse(source, handler) {
    return __async(this, null, function* () {
      const parser = new XmlParser();
      const document = parser.xmlParse(source);
      yield handler({
        type: "document-start",
        depth: 0
      });
      for (const child of document.childNodes) {
        yield this.emitNode(child, handler, 0);
      }
      yield handler({
        type: "document-end",
        depth: 0
      });
    });
  }
  /**
   * Check if document can be streamed.
   */
  canStream(source) {
    return __async(this, null, function* () {
      return true;
    });
  }
  emitNode(node, handler, depth) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      switch (node.nodeType) {
        case DOM_DOCUMENT_NODE: {
          for (const child of node.childNodes) {
            yield this.emitNode(child, handler, depth);
          }
          return;
        }
        case DOM_ELEMENT_NODE: {
          const attributeNodes = node.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
          const attributes = attributeNodes.length > 0 ? /* @__PURE__ */ new Map() : void 0;
          if (attributes) {
            for (const attribute of attributeNodes) {
              attributes.set(attribute.nodeName, `${(_a = attribute.nodeValue) != null ? _a : ""}`);
              yield handler({
                type: "attribute",
                name: attribute.nodeName,
                namespaceUri: attribute.namespaceUri || void 0,
                content: `${(_b = attribute.nodeValue) != null ? _b : ""}`,
                depth: depth + 1
              });
            }
          }
          const nonAttributeChildren = node.childNodes.filter((n) => n.nodeType !== DOM_ATTRIBUTE_NODE);
          yield handler({
            type: "start-element",
            name: node.nodeName,
            namespaceUri: node.namespaceUri || void 0,
            attributes,
            selfClosing: nonAttributeChildren.length === 0,
            depth: depth + 1
          });
          for (const child of nonAttributeChildren) {
            yield this.emitNode(child, handler, depth + 1);
          }
          yield handler({
            type: "end-element",
            name: node.nodeName,
            namespaceUri: node.namespaceUri || void 0,
            depth: depth + 1
          });
          return;
        }
        case DOM_TEXT_NODE:
        case DOM_CDATA_SECTION_NODE: {
          const text = `${(_c = node.nodeValue) != null ? _c : ""}`;
          if (text.length > 0) {
            yield handler({
              type: "text",
              content: text,
              depth: depth + 1
            });
          }
          return;
        }
        case DOM_COMMENT_NODE: {
          yield handler({
            type: "comment",
            content: `${(_d = node.nodeValue) != null ? _d : ""}`,
            depth: depth + 1
          });
          return;
        }
        case DOM_PROCESSING_INSTRUCTION_NODE: {
          yield handler({
            type: "processing-instruction",
            name: node.nodeName,
            content: `${(_e = node.nodeValue) != null ? _e : ""}`,
            depth: depth + 1
          });
          return;
        }
        default:
          return;
      }
    });
  }
};

// src/xslt/streaming/streaming-processor.ts
var StreamingProcessor = class {
  constructor(options) {
    /** Streaming context for tracking state during streaming */
    this.context = new StreamingContext();
    /** Copy manager for xsl:fork operations */
    this.copyManager = new StreamingCopyManager();
    /** Merge coordinator for xsl:merge operations */
    this.mergeCoordinator = new StreamingMergeCoordinator();
    /** Whether streaming is currently enabled */
    this.enabled = false;
    /** Streaming parser implementation */
    this.parser = new StreamingParserBase();
    this.xPath = options.xPath;
    this.version = options.version;
  }
  /**
   * Update the version (called when version is determined from stylesheet).
   */
  setVersion(version) {
    this.version = version;
  }
  /**
   * Check if streaming is currently enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Get the streaming context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Get the copy manager.
   */
  getCopyManager() {
    return this.copyManager;
  }
  /**
   * Get the merge coordinator.
   */
  getMergeCoordinator() {
    return this.mergeCoordinator;
  }
  /**
   * Set a custom streaming parser implementation.
   */
  setParser(parser) {
    this.parser = parser;
  }
  /**
   * Validate that a pattern is streamable.
   */
  validatePattern(pattern) {
    return StreamablePatternValidator.validatePattern(pattern);
  }
  /**
   * Detect the streaming mode for a template.
   */
  detectMode(templateNode) {
    return StreamingModeDetector.detectMode(templateNode);
  }
  /**
   * Implements `<xsl:stream>` (XSLT 3.0 Section 16).
   * Enables streaming processing of large documents.
   * 
   * @param exprContext The Expression Context.
   * @param template The xsl:stream element.
   * @param output The output node.
   * @param childProcessor Callback for processing child nodes.
   */
  processStream(exprContext, template, output, childProcessor) {
    return __async(this, null, function* () {
      if (!this.version || parseFloat(this.version) < 3) {
        throw new Error("<xsl:stream> is only supported in XSLT 3.0 or later.");
      }
      const select = xmlGetAttribute(template, "select");
      if (!select) {
        throw new Error('<xsl:stream> requires a "select" attribute specifying the input document.');
      }
      const previouslyEnabled = this.enabled;
      this.enabled = true;
      this.context.startStreaming();
      try {
        const contextClone = exprContext.clone();
        const selectedValue = this.xPath.xPathEval(select, contextClone);
        let nodes = [];
        if (selectedValue.type === "node-set") {
          nodes = selectedValue.nodeSetValue();
        } else if (selectedValue.type === "node") {
          nodes = [selectedValue];
        }
        for (const node of nodes) {
          yield childProcessor.processChildren(exprContext, template, output);
        }
      } finally {
        this.enabled = previouslyEnabled;
        this.context.endStreaming();
        this.copyManager.clear();
      }
    });
  }
  /**
   * Implements `<xsl:fork>` (XSLT 3.0 Section 17).
   * Creates multiple independent output branches from the input stream.
   * 
   * @param exprContext The Expression Context.
   * @param template The xsl:fork element.
   * @param output The output node.
   * @param childProcessor Callback for processing child nodes.
   */
  processFork(exprContext, template, output, childProcessor) {
    return __async(this, null, function* () {
      if (!this.enabled) {
        throw new Error("<xsl:fork> can only be used within <xsl:stream>.");
      }
      for (const child of template.childNodes) {
        if (childProcessor.isXsltElement(child, "fork-sequence")) {
          const copy = this.copyManager.createCopy((event) => __async(this, null, function* () {
            yield childProcessor.processChildren(exprContext, child, output);
          }));
          this.context.registerCopy(copy);
        }
      }
    });
  }
  /**
   * Implements `<xsl:merge>` (XSLT 3.0 Section 15).
   * Merges multiple sorted input sequences.
   * 
   * @param exprContext The Expression Context.
   * @param template The xsl:merge element.
   * @param output The output node.
   * @param childProcessor Callback for processing child nodes.
   */
  processMerge(exprContext, template, output, childProcessor) {
    return __async(this, null, function* () {
      if (!this.version || parseFloat(this.version) < 3) {
        throw new Error("<xsl:merge> is only supported in XSLT 3.0 or later.");
      }
      const sources = [];
      for (const child of template.childNodes) {
        if (childProcessor.isXsltElement(child, "merge-source")) {
          const selectAttr = xmlGetAttribute(child, "select");
          if (!selectAttr) {
            throw new Error('<xsl:merge-source> requires a "select" attribute.');
          }
          const source = {
            select: selectAttr,
            mergeKeys: [],
            position: 0,
            isExhausted: false,
            buffer: []
          };
          for (const keyChild of child.childNodes) {
            if (childProcessor.isXsltElement(keyChild, "merge-key")) {
              const keySelect = xmlGetAttribute(keyChild, "select");
              const order = xmlGetAttribute(keyChild, "order") || "ascending";
              source.mergeKeys.push({
                select: keySelect || ".",
                order
              });
            }
          }
          const result = this.xPath.xPathEval(selectAttr, exprContext);
          const nodes = result.nodeSetValue ? result.nodeSetValue() : [];
          source.buffer = Array.isArray(nodes) ? nodes.slice() : nodes ? [nodes] : [];
          source.isExhausted = source.buffer.length === 0;
          sources.push(source);
        }
      }
      if (sources.length === 0) {
        throw new Error("<xsl:merge> requires at least one <xsl:merge-source> child element.");
      }
      for (const source of sources) {
        this.mergeCoordinator.addSource(source);
      }
      try {
        let hasData = sources.some((s) => s.buffer.length > 0);
        if (hasData) {
          for (const source of sources) {
            while (source.buffer.length > 0) {
              const item = source.buffer.shift();
              const mergeContext = exprContext.clone([item], 0);
              for (const child of template.childNodes) {
                if (childProcessor.isXsltElement(child, "merge-action")) {
                  yield childProcessor.processChildren(mergeContext, child, output);
                }
              }
            }
            source.isExhausted = true;
          }
        }
      } finally {
        this.mergeCoordinator.clear();
      }
    });
  }
  /**
   * Clear all streaming state.
   */
  reset() {
    this.enabled = false;
    this.context.endStreaming();
    this.copyManager.clear();
    this.mergeCoordinator.clear();
  }
};

// src/xslt/functions.ts
function calculateStepPriority(step) {
  const nodeTest = step.nodeTest;
  const hasPredicates = step.predicate && step.predicate.length > 0 || step.predicates && step.predicates.length > 0;
  if (hasPredicates) {
    return 0.5;
  }
  if (nodeTest && typeof nodeTest === "object" && "type" in nodeTest) {
    switch (nodeTest.type) {
      case "wildcard":
        if (nodeTest.name && nodeTest.name.endsWith(":*")) {
          return -0.25;
        }
        return -0.5;
      case "node-type":
        if (nodeTest.nodeType === "processing-instruction" && nodeTest.name) {
          return 0;
        }
        return -0.5;
      case "processing-instruction":
        return nodeTest.target || nodeTest.name ? 0 : -0.5;
      case "name":
        return 0;
      default:
        return 0;
    }
  }
  if (nodeTest instanceof NodeTestAny) {
    return -0.5;
  }
  if (nodeTest instanceof NodeTestElementOrAttribute) {
    return -0.5;
  }
  if (nodeTest instanceof NodeTestText) {
    return -0.5;
  }
  if (nodeTest instanceof NodeTestComment) {
    return -0.5;
  }
  if (nodeTest instanceof NodeTestPI) {
    return nodeTest.target ? 0 : -0.5;
  }
  if (nodeTest instanceof NodeTestNC) {
    return -0.25;
  }
  if (nodeTest instanceof NodeTestName) {
    return 0;
  }
  return 0;
}
function calculateLocationPathPriority(expr) {
  if (!expr.steps || expr.steps.length === 0) {
    if (expr.absolute) {
      return -0.5;
    }
    return 0;
  }
  if (expr.steps.length > 1) {
    return 0.5;
  }
  const step = expr.steps[0];
  const axis = step.axis;
  if (axis && axis !== "child" && axis !== "attribute" && axis !== "self-and-siblings") {
    return 0.5;
  }
  return calculateStepPriority(step);
}
function matchesMode(template, mode) {
  const templateMode = template.getAttributeValue("mode");
  if (!mode) {
    return !templateMode || templateMode === "#default";
  }
  if (mode === "#all") {
    return true;
  }
  if (templateMode === "#all") {
    return true;
  }
  return templateMode === mode;
}
function isTemplate(node) {
  if (node.nodeType !== DOM_ELEMENT_NODE) {
    return false;
  }
  if (node.namespaceUri === "http://www.w3.org/1999/XSL/Transform") {
    return node.localName === "template";
  }
  return node.prefix === "xsl" && node.localName === "template";
}
function calculateSinglePatternPriority(pattern, xPath) {
  try {
    const expr = xPath.xPathParse(pattern);
    if (expr instanceof LocationExpr) {
      return calculateLocationPathPriority(expr);
    }
    return 0.5;
  } catch (e) {
    return 0;
  }
}
function collectAndExpandTemplates(stylesheetElement, mode, xPath, templateSourceMap) {
  var _a;
  const templates = [];
  let docOrder = 0;
  for (const child of stylesheetElement.childNodes) {
    if (!isTemplate(child)) {
      continue;
    }
    if (!matchesMode(child, mode)) {
      continue;
    }
    const match = child.getAttributeValue("match");
    if (!match) {
      continue;
    }
    const priorityAttr = child.getAttributeValue("priority");
    const explicitPriority = priorityAttr ? parseFloat(priorityAttr) : null;
    const metadata = templateSourceMap == null ? void 0 : templateSourceMap.get(child);
    let importPrecedence = 0;
    if (metadata) {
      const DEPTH_WEIGHT = Number.MAX_SAFE_INTEGER / 2;
      const depthComponent = -metadata.importDepth * DEPTH_WEIGHT;
      const orderComponent = (_a = metadata.order) != null ? _a : 0;
      importPrecedence = depthComponent + orderComponent;
    }
    const alternatives = splitUnionPattern(match);
    for (const alternative of alternatives) {
      const defaultPriority = calculateSinglePatternPriority(alternative, xPath);
      const effectivePriority = explicitPriority !== null && !isNaN(explicitPriority) ? explicitPriority : defaultPriority;
      templates.push({
        template: child,
        explicitPriority: explicitPriority !== null && !isNaN(explicitPriority) ? explicitPriority : null,
        defaultPriority,
        effectivePriority,
        importPrecedence,
        documentOrder: docOrder++,
        matchPattern: alternative
        // Use the individual alternative, not the full union
      });
    }
  }
  return templates;
}
function splitUnionPattern(pattern) {
  const alternatives = [];
  let current = "";
  let depth = 0;
  let inSingleQuote = false;
  let inDoubleQuote = false;
  for (let i = 0; i < pattern.length; i++) {
    const char = pattern[i];
    if (char === "'" && !inDoubleQuote) {
      inSingleQuote = !inSingleQuote;
      current += char;
    } else if (char === '"' && !inSingleQuote) {
      inDoubleQuote = !inDoubleQuote;
      current += char;
    } else if (!inSingleQuote && !inDoubleQuote) {
      if (char === "[" || char === "(") {
        depth++;
        current += char;
      } else if (char === "]" || char === ")") {
        depth--;
        current += char;
      } else if (char === "|" && depth === 0) {
        alternatives.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    } else {
      current += char;
    }
  }
  if (current.trim()) {
    alternatives.push(current.trim());
  }
  return alternatives;
}
function nodeMatchesSinglePattern(node, pattern, context, matchResolver, xPath) {
  if (pattern === "/") {
    return node.nodeName === "#document";
  }
  if (pattern.startsWith("@")) {
    if (node.nodeType !== 2) {
      return false;
    }
    const attrPattern = pattern.substring(1);
    if (attrPattern === "*") {
      return true;
    }
    const attrName = node.localName || node.nodeName;
    const patternLocalName = attrPattern.includes(":") ? attrPattern.substring(attrPattern.indexOf(":") + 1) : attrPattern;
    return attrName === patternLocalName || node.nodeName === attrPattern;
  }
  if (pattern === "*" && node.nodeType === DOM_ELEMENT_NODE) {
    return true;
  }
  if (!pattern.includes("/") && !pattern.includes("[") && !pattern.startsWith("@")) {
    if (pattern === node.nodeName || pattern === node.localName) {
      return true;
    }
  }
  if (pattern.includes("/") || pattern.includes("[")) {
    try {
      const evaluationPattern = pattern.startsWith("/") ? pattern : "//" + pattern;
      const rootContext = context.clone([context.root], 0);
      const evalResult = xPath.xPathEval(evaluationPattern, rootContext);
      const nodes = evalResult.nodeSetValue();
      if (nodes.some((n) => n.id === node.id)) {
        return true;
      }
    } catch (e) {
    }
  }
  if (!pattern.includes("/") && !pattern.includes("[") && !pattern.startsWith("@")) {
    try {
      const nodeContext = context.clone([node], 0);
      const expr = xPath.xPathParse(pattern, "self-and-siblings");
      const nodes = matchResolver.expressionMatch(expr, nodeContext);
      if (nodes.some((n) => n.id === node.id)) {
        return true;
      }
    } catch (e) {
    }
  }
  return false;
}
function nodeMatchesPattern(node, pattern, context, matchResolver, xPath) {
  const alternatives = splitUnionPattern(pattern);
  for (const alt of alternatives) {
    if (nodeMatchesSinglePattern(node, alt, context, matchResolver, xPath)) {
      return true;
    }
  }
  return false;
}
function selectBestTemplate(templates, context, matchResolver, xPath, warningsCallback) {
  const warn = warningsCallback != null ? warningsCallback : console.warn;
  const matching = [];
  const currentNode = context.nodeList[context.position];
  for (const t of templates) {
    try {
      if (nodeMatchesPattern(currentNode, t.matchPattern, context, matchResolver, xPath)) {
        matching.push(t);
      }
    } catch (e) {
      warn(`Failed to match pattern "${t.matchPattern}":`, e);
    }
  }
  if (matching.length === 0) {
    return {
      selectedTemplate: null,
      hasConflict: false,
      conflictingTemplates: []
    };
  }
  matching.sort((a, b) => {
    if (a.importPrecedence !== b.importPrecedence) {
      return b.importPrecedence - a.importPrecedence;
    }
    if (a.effectivePriority !== b.effectivePriority) {
      return b.effectivePriority - a.effectivePriority;
    }
    return b.documentOrder - a.documentOrder;
  });
  const winner = matching[0];
  const conflicts = matching.filter(
    (t) => t.importPrecedence === winner.importPrecedence && t.effectivePriority === winner.effectivePriority
  );
  return {
    selectedTemplate: winner.template,
    hasConflict: conflicts.length > 1,
    conflictingTemplates: conflicts.length > 1 ? conflicts : [],
    originalComponent: winner.originalComponent
  };
}
function emitConflictWarning(result, node, warningsCallback) {
  if (!result.hasConflict || result.conflictingTemplates.length < 2) {
    return;
  }
  const patterns = result.conflictingTemplates.map((t) => `"${t.matchPattern}" (priority: ${t.effectivePriority})`).join(", ");
  const warn = warningsCallback != null ? warningsCallback : console.warn;
  warn(
    `XSLT Warning: Ambiguous template match for node <${node.nodeName}>. Multiple templates match with equal priority: ${patterns}. Using the last one in document order.`
  );
}

// src/xslt/xslt-accumulator.ts
var AccumulatorRegistry = class {
  constructor() {
    this.accumulators = /* @__PURE__ */ new Map();
    this.accumulatorStates = /* @__PURE__ */ new Map();
  }
  /**
   * Register an accumulator definition
   */
  registerAccumulator(definition) {
    this.accumulators.set(definition.name, definition);
    this.accumulatorStates.set(definition.name, {
      currentValue: null,
      valueStack: []
    });
  }
  /**
   * Get an accumulator definition by name
   */
  getAccumulator(name) {
    return this.accumulators.get(name);
  }
  /**
   * Get all registered accumulators
   */
  getAllAccumulators() {
    return Array.from(this.accumulators.values());
  }
  /**
   * Get current state of an accumulator
   */
  getAccumulatorState(name) {
    return this.accumulatorStates.get(name);
  }
  /**
   * Update accumulator state
   */
  setAccumulatorState(name, state) {
    this.accumulatorStates.set(name, state);
  }
  /**
   * Clear all accumulators
   */
  clear() {
    this.accumulators.clear();
    this.accumulatorStates.clear();
  }
};

// src/xslt/xslt.ts
var Xslt = class {
  constructor(options = {
    cData: true,
    escape: true,
    selfClosingTags: true,
    parameters: []
  }) {
    /**
     * Stack of stylesheet metadata for tracking import hierarchy.
     * Used by apply-imports to find templates from imported stylesheets.
     */
    this.styleSheetStack = [];
    /**
     * Map of imported stylesheet HREFs to their parsed XNodes.
     * Prevents duplicate imports and allows precedence tracking.
     */
    this.importedStylesheets = /* @__PURE__ */ new Map();
    /**
     * Map templates to the stylesheet they came from.
     * Enables apply-imports to find templates by import precedence.
     */
    this.templateSourceMap = /* @__PURE__ */ new Map();
    /**
     * Stack of currently executing templates with their metadata.
     * Used by apply-imports to determine which template called it.
     */
    this.currentTemplateStack = [];
    /**
     * Package registry for XSLT 3.0 package system.
     * Manages loaded packages and their components.
     */
    this.packageRegistry = new PackageRegistry();
    /**
     * Current package being processed (for XSLT 3.0).
     * null if processing a non-package stylesheet.
     */
    this.currentPackage = null;
    /**
     * Current override context (for XSLT 3.0 xsl:original).
     * Tracks the original component when executing an override.
     */
    this.currentOverrideContext = null;
    /**
     * Accumulator registry for XSLT 3.0 accumulators.
     * Stores accumulator definitions and current state during processing.
     */
    this.accumulatorRegistry = new AccumulatorRegistry();
    this.xPath = new XPath();
    this.xmlParser = new XmlParser();
    this.matchResolver = new MatchResolver();
    this.options = {
      cData: options.cData === true,
      escape: options.escape === true,
      selfClosingTags: options.selfClosingTags === true,
      outputMethod: options.outputMethod,
      parameters: options.parameters || []
    };
    this.outputMethod = options.outputMethod || "xml";
    this.outputOmitXmlDeclaration = "no";
    this.outputVersion = "";
    this.itemSeparator = "";
    this.stripSpacePatterns = [];
    this.preserveSpacePatterns = [];
    this.namespaceAliases = /* @__PURE__ */ new Map();
    this.supportedExtensions = /* @__PURE__ */ new Set(["http://www.w3.org/1999/XSL/Transform"]);
    this.attributeSets = /* @__PURE__ */ new Map();
    this.userDefinedFunctions = /* @__PURE__ */ new Map();
    this.resultDocuments = /* @__PURE__ */ new Map();
    this.decimalFormatSettings = {
      decimalSeparator: ".",
      groupingSeparator: ",",
      infinity: "Infinity",
      minusSign: "-",
      naN: "NaN",
      percent: "%",
      perMille: "\u2030",
      zeroDigit: "0",
      digit: "#",
      patternSeparator: ";"
    };
    this.firstTemplateRan = false;
    this.forwardsCompatible = false;
    this.warningsCallback = console.warn.bind(console);
    this.streamingProcessor = new StreamingProcessor({
      xPath: this.xPath,
      version: ""
    });
  }
  /**
   * The exported entry point of the XSL-T processor.
   * @param xmlDoc The input document root, as DOM node.
   * @param stylesheet The stylesheet document root, as DOM node.
   * @returns the processed document, as XML text in a string, JSON string if outputMethod is 'json', or text if outputMethod is 'text' or 'adaptive' (with text content).
   */
  xsltProcess(xmlDoc, stylesheet) {
    return __async(this, null, function* () {
      const outputDocument = new XDocument();
      this.outputDocument = outputDocument;
      const expressionContext = new ExprContext([xmlDoc]);
      expressionContext.warningsCallback = this.warningsCallback;
      if (this.options.parameters.length > 0) {
        for (const parameter of this.options.parameters) {
          expressionContext.setVariable(parameter.name, new StringValue(parameter.value));
        }
      }
      yield this.xsltProcessContext(expressionContext, stylesheet, this.outputDocument);
      if (this.outputMethod === "json") {
        return xmlToJson(outputDocument);
      }
      let outputMethod = this.outputMethod;
      if (this.outputMethod === "adaptive") {
        outputMethod = detectAdaptiveOutputFormat(outputDocument);
      }
      let serializationMethod = outputMethod;
      if (outputMethod === "html" && this.outputVersion === "5.0") {
        serializationMethod = "html";
      }
      const transformedOutputXml = xmlTransformedText(outputDocument, {
        cData: this.options.cData,
        escape: this.options.escape,
        selfClosingTags: this.options.selfClosingTags,
        outputMethod: serializationMethod,
        outputVersion: this.outputVersion,
        itemSeparator: this.itemSeparator
      });
      return transformedOutputXml;
    });
  }
  /**
   * The main entry point of the XSL-T processor, as explained on the top of the file.
   * @param context The input document root, as XPath `ExprContext`.
   * @param template The stylesheet document root, as DOM node.
   * @param output If set, the output where the transformation should occur.
   */
  xsltProcessContext(context, template, output) {
    return __async(this, null, function* () {
      if (!context.warningsCallback) {
        context.warningsCallback = this.warningsCallback;
      }
      if (!this.isXsltElement(template)) {
        if (template.nodeType === DOM_ELEMENT_NODE && !this.isExtensionElementSupported(template)) {
          yield this.xsltExtensionElement(context, template, output);
        } else {
          yield this.xsltPassThrough(context, template, output);
        }
      } else {
        let node, select, value, nodes;
        switch (template.localName) {
          case "apply-imports":
            yield this.xsltApplyImports(context, template, output);
            break;
          case "apply-templates":
            yield this.xsltApplyTemplates(context, template, output);
            break;
          case "analyze-string":
            yield this.xsltAnalyzeString(context, template, output);
            break;
          case "attribute":
            yield this.xsltAttribute(context, template, output);
            break;
          case "attribute-set":
            break;
          case "call-template":
            yield this.xsltCallTemplate(context, template, output);
            break;
          case "choose":
            yield this.xsltChoose(context, template, output);
            break;
          case "comment":
            yield this.xsltComment(context, template, output);
            break;
          case "copy":
            node = this.xsltCopy(output || this.outputDocument, context.nodeList[context.position]);
            if (node) {
              yield this.xsltChildNodes(context, template, node);
            }
            break;
          case "copy-of":
            select = xmlGetAttribute(template, "select");
            value = this.xPath.xPathEval(select, context);
            const destinationNode = output || this.outputDocument;
            if (value.type === "node-set") {
              nodes = value.nodeSetValue();
              for (let i = 0; i < nodes.length; ++i) {
                this.xsltCopyOf(destinationNode, nodes[i]);
              }
            } else {
              let node2 = domCreateTextNode(this.outputDocument, value.stringValue());
              node2.siblingPosition = destinationNode.childNodes.length;
              domAppendChild(destinationNode, node2);
            }
            break;
          case "accumulator":
            this.xsltAccumulator(context, template);
            break;
          case "accumulator-rule":
            throw new Error(`<xsl:accumulator-rule> must be a child of <xsl:accumulator>.`);
          case "decimal-format":
            this.xsltDecimalFormat(context, template);
            break;
          case "evaluate":
            yield this.xsltEvaluate(context, template, output);
            break;
          case "element":
            yield this.xsltElement(context, template, output);
            break;
          case "fallback":
            const parent = template.parentNode;
            const isExtensionParent = parent && parent.nodeType === DOM_ELEMENT_NODE && !this.isExtensionElementSupported(parent);
            if (!isExtensionParent) {
              throw new Error(
                "<xsl:fallback> must be a direct child of an extension element"
              );
            }
            yield this.xsltChildNodes(context, template, output);
            break;
          case "for-each":
            yield this.xsltForEach(context, template, output);
            break;
          case "for-each-group":
            yield this.xsltForEachGroup(context, template, output);
            break;
          case "function":
            this.xsltFunction(context, template);
            break;
          case "iterate":
            yield this.xsltIterate(context, template, output);
            break;
          case "try":
            yield this.xsltTry(context, template, output);
            break;
          case "if":
            yield this.xsltIf(context, template, output);
            break;
          case "import":
            yield this.xsltImport(context, template, output);
            break;
          case "include":
            yield this.xsltInclude(context, template, output);
            break;
          case "key":
            this.xsltKey(context, template);
            break;
          case "matching-substring":
            throw new Error(`<xsl:matching-substring> must be a child of <xsl:analyze-string>.`);
          case "message":
            yield this.xsltMessage(context, template);
            break;
          case "namespace":
            yield this.xsltNamespace(context, template, output);
            break;
          case "namespace-alias":
            this.xsltNamespaceAlias(template);
            break;
          case "non-matching-substring":
            throw new Error(`<xsl:non-matching-substring> must be a child of <xsl:analyze-string>.`);
          case "on-empty":
            throw new Error(`<xsl:on-empty> must be a child of a sequence-generating instruction like <xsl:for-each>, <xsl:for-each-group>, or <xsl:apply-templates>.`);
          case "on-non-empty":
            throw new Error(`<xsl:on-non-empty> must be a child of a sequence-generating instruction like <xsl:for-each>, <xsl:for-each-group>, or <xsl:apply-templates>.`);
          case "number":
            this.xsltNumber(context, template, output);
            break;
          case "otherwise":
            throw new Error(`<xsl:otherwise> must be a child of <xsl:choose>.`);
          case "output":
            this.outputMethod = xmlGetAttribute(template, "method");
            this.outputOmitXmlDeclaration = xmlGetAttribute(template, "omit-xml-declaration");
            this.outputVersion = xmlGetAttribute(template, "version") || "";
            this.itemSeparator = xmlGetAttribute(template, "item-separator") || "";
            break;
          case "package":
            yield this.xsltPackage(context, template, output);
            break;
          case "use-package":
            yield this.xsltUsePackage(context, template, output);
            break;
          case "expose":
            this.xsltExpose(context, template);
            break;
          case "accept":
            this.xsltAccept(context, template);
            break;
          case "override":
            yield this.xsltOverride(context, template, output);
            break;
          case "original":
            yield this.xsltOriginal(context, template, output);
            break;
          case "param":
            yield this.xsltVariable(context, template, false);
            break;
          case "preserve-space":
            this.xsltPreserveSpace(template);
            break;
          case "perform-sort":
            yield this.xsltPerformSort(context, template, output);
            break;
          case "processing-instruction":
            yield this.xsltProcessingInstruction(context, template, output);
            break;
          case "result-document":
            yield this.xsltResultDocument(context, template);
            break;
          case "sequence":
            yield this.xsltSequence(context, template, output);
            break;
          case "sort":
            this.xsltSort(context, template);
            break;
          case "strip-space":
            this.xsltStripSpace(template);
            break;
          case "stylesheet":
          case "transform":
            yield this.xsltTransformOrStylesheet(context, template, output);
            break;
          case "stream":
            yield this.xsltStream(context, template, output);
            break;
          case "fork":
            yield this.xsltFork(context, template, output);
            break;
          case "merge":
            yield this.xsltMerge(context, template, output);
            break;
          case "mode":
            if (this.currentPackage) {
              this.xsltMode(context, template);
            }
            break;
          case "template":
            yield this.xsltTemplate(context, template, output);
            break;
          case "text":
            this.xsltText(context, template, output);
            break;
          case "value-of":
            this.xsltValueOf(context, template, output);
            break;
          case "variable":
            yield this.xsltVariable(context, template, true);
            break;
          case "when":
            throw new Error(`<xsl:when> must be a child of <xsl:choose>.`);
          case "with-param":
            throw new Error(`<xsl:with-param> must be a child of <xsl:call-template> or <xsl:apply-templates>.`);
          default:
            yield this.xsltUnknownInstruction(context, template, output);
        }
      }
    });
  }
  /**
   * Handle unknown XSLT instructions per XSLT 1.0 Section 2.5 (Forwards-Compatible Processing).
   *
   * In forwards-compatible mode (version > 1.0):
   * - If the instruction has an xsl:fallback child, execute the fallback
   * - Otherwise, the instruction is silently ignored
   *
   * In strict mode (version = 1.0):
   * - Unknown instructions are an error
   *
   * @param context The Expression Context
   * @param template The unknown XSLT instruction element
   * @param output The output node
   */
  xsltUnknownInstruction(context, template, output) {
    return __async(this, null, function* () {
      const elementName = `xsl:${template.localName}`;
      if (this.forwardsCompatible) {
        const fallback = this.getFallbackElement(template);
        if (fallback) {
          yield this.xsltChildNodes(context, fallback, output);
        }
        return;
      }
      throw new Error(
        `Unknown XSLT instruction: <${elementName}>. This element is not supported in XSLT 1.0. If this is a future XSLT version feature, use version="2.0" or higher to enable forwards-compatible processing mode.`
      );
    });
  }
  /**
   * Implements `xsl:apply-templates`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output. Only used if there's no corresponding output node already defined.
   * @protected
   */
  xsltApplyTemplates(context, template, output) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const select = xmlGetAttribute(template, "select");
      let nodes = [];
      if (select) {
        nodes = this.xPath.xPathEval(select, context).nodeSetValue();
      } else {
        nodes = context.nodeList[context.position].childNodes;
      }
      const onEmpty = this.findConditionalChild(template, "on-empty");
      const onNonEmpty = this.findConditionalChild(template, "on-non-empty");
      if (nodes.length === 0) {
        if (onEmpty) {
          yield this.xsltChildNodes(context.clone(), onEmpty, output);
        }
        return;
      }
      if (onNonEmpty) {
        yield this.xsltChildNodes(context.clone(), onNonEmpty, output);
        return;
      }
      const mode = xmlGetAttribute(template, "mode");
      const effectiveMode = mode || null;
      const top = template.ownerDocument.documentElement;
      let expandedTemplates = collectAndExpandTemplates(top, effectiveMode, this.xPath, this.templateSourceMap);
      expandedTemplates = expandedTemplates.concat(this.collectAcceptedTemplates(effectiveMode));
      const paramContext = context.clone();
      yield this.xsltWithParam(paramContext, template);
      const modifiedContext = paramContext.clone(nodes);
      for (let j = 0; j < modifiedContext.contextSize(); ++j) {
        const currentNode = modifiedContext.nodeList[j];
        if (currentNode.nodeType === DOM_TEXT_NODE) {
          if (!this.xsltPassText(currentNode)) {
            continue;
          }
          const textNodeContext = paramContext.clone([currentNode], 0);
          textNodeContext.inApplyTemplates = true;
          const textSelection = selectBestTemplate(
            expandedTemplates,
            textNodeContext,
            this.matchResolver,
            this.xPath,
            this.warningsCallback
          );
          if (textSelection.selectedTemplate) {
            const metadata = this.templateSourceMap.get(textSelection.selectedTemplate);
            const matchPattern = xmlGetAttribute(textSelection.selectedTemplate, "match");
            const modeAttr = xmlGetAttribute(textSelection.selectedTemplate, "mode");
            this.currentTemplateStack.push({
              template: textSelection.selectedTemplate,
              stylesheetDepth: (_a = metadata == null ? void 0 : metadata.importDepth) != null ? _a : 0,
              mode: modeAttr || effectiveMode,
              match: matchPattern
            });
            const previousOverrideContext = this.currentOverrideContext;
            const overrideContext = textSelection.originalComponent || textSelection.selectedTemplate.__originalComponent;
            if (overrideContext) {
              this.currentOverrideContext = overrideContext;
            }
            try {
              yield this.xsltChildNodes(textNodeContext, textSelection.selectedTemplate, output);
            } finally {
              this.currentTemplateStack.pop();
              this.currentOverrideContext = previousOverrideContext;
            }
          } else {
            const oldTextNodeContext = context.clone([currentNode], 0);
            this.commonLogicTextNode(oldTextNodeContext, currentNode, output);
          }
        } else {
          const clonedContext = modifiedContext.clone(
            [currentNode],
            0
          );
          clonedContext.inApplyTemplates = true;
          const selection = selectBestTemplate(
            expandedTemplates,
            clonedContext,
            this.matchResolver,
            this.xPath,
            this.warningsCallback
          );
          if (selection.hasConflict) {
            emitConflictWarning(selection, currentNode, this.warningsCallback);
          }
          if (selection.selectedTemplate) {
            const metadata = this.templateSourceMap.get(selection.selectedTemplate);
            const matchPattern = xmlGetAttribute(selection.selectedTemplate, "match");
            const modeAttr = xmlGetAttribute(selection.selectedTemplate, "mode");
            this.currentTemplateStack.push({
              template: selection.selectedTemplate,
              stylesheetDepth: (_b = metadata == null ? void 0 : metadata.importDepth) != null ? _b : 0,
              mode: modeAttr || effectiveMode,
              match: matchPattern
            });
            const previousOverrideContext = this.currentOverrideContext;
            const overrideContext = selection.originalComponent || selection.selectedTemplate.__originalComponent;
            if (overrideContext) {
              this.currentOverrideContext = overrideContext;
            }
            try {
              yield this.xsltChildNodes(clonedContext, selection.selectedTemplate, output);
            } finally {
              this.currentTemplateStack.pop();
              this.currentOverrideContext = previousOverrideContext;
            }
          } else {
            if (currentNode.nodeType === DOM_ELEMENT_NODE && currentNode.childNodes && currentNode.childNodes.length > 0) {
              const childNodes = currentNode.childNodes.filter(
                (n) => n.nodeType !== DOM_ATTRIBUTE_NODE
              );
              for (let k = 0; k < childNodes.length; ++k) {
                const childNode = childNodes[k];
                if (childNode.nodeType === DOM_TEXT_NODE) {
                  const textContext = paramContext.clone([childNode], 0);
                  textContext.inApplyTemplates = true;
                  const textSelection = selectBestTemplate(
                    expandedTemplates,
                    textContext,
                    this.matchResolver,
                    this.xPath,
                    this.warningsCallback
                  );
                  if (textSelection.selectedTemplate) {
                    yield this.xsltChildNodes(textContext, textSelection.selectedTemplate, output);
                  } else {
                    this.commonLogicTextNode(textContext, childNode, output);
                  }
                } else {
                  const childContext = paramContext.clone([childNode], 0);
                  childContext.inApplyTemplates = true;
                  const childSelection = selectBestTemplate(
                    expandedTemplates,
                    childContext,
                    this.matchResolver,
                    this.xPath,
                    this.warningsCallback
                  );
                  if (childSelection.selectedTemplate) {
                    const childMetadata = this.templateSourceMap.get(childSelection.selectedTemplate);
                    const childMatchPattern = xmlGetAttribute(childSelection.selectedTemplate, "match");
                    const childModeAttr = xmlGetAttribute(childSelection.selectedTemplate, "mode");
                    this.currentTemplateStack.push({
                      template: childSelection.selectedTemplate,
                      stylesheetDepth: (_c = childMetadata == null ? void 0 : childMetadata.importDepth) != null ? _c : 0,
                      mode: childModeAttr || effectiveMode,
                      match: childMatchPattern
                    });
                    try {
                      yield this.xsltChildNodes(childContext, childSelection.selectedTemplate, output);
                    } finally {
                      this.currentTemplateStack.pop();
                    }
                  } else if (childNode.nodeType === DOM_ELEMENT_NODE) {
                    yield this.applyBuiltInTemplate(childNode, expandedTemplates, effectiveMode, paramContext, output);
                  }
                }
              }
            } else if (currentNode.nodeType === DOM_TEXT_NODE) {
              this.commonLogicTextNode(clonedContext, currentNode, output);
            }
          }
        }
      }
    });
  }
  /**
   * Helper method to apply the built-in template for elements.
   * The built-in template recursively applies templates to children.
   */
  applyBuiltInTemplate(node, expandedTemplates, mode, paramContext, output) {
    return __async(this, null, function* () {
      var _a;
      if (!node.childNodes || node.childNodes.length === 0) {
        return;
      }
      const childNodes = node.childNodes.filter(
        (n) => n.nodeType !== DOM_ATTRIBUTE_NODE
      );
      for (const childNode of childNodes) {
        if (childNode.nodeType === DOM_TEXT_NODE) {
          const textContext = paramContext.clone([childNode], 0);
          textContext.inApplyTemplates = true;
          const textSelection = selectBestTemplate(
            expandedTemplates,
            textContext,
            this.matchResolver,
            this.xPath,
            this.warningsCallback
          );
          if (textSelection.selectedTemplate) {
            const previousOverrideContext = this.currentOverrideContext;
            const overrideContext = textSelection.originalComponent || textSelection.selectedTemplate.__originalComponent;
            if (overrideContext) {
              this.currentOverrideContext = overrideContext;
            }
            try {
              yield this.xsltChildNodes(textContext, textSelection.selectedTemplate, output);
            } finally {
              this.currentOverrideContext = previousOverrideContext;
            }
          } else {
            this.commonLogicTextNode(textContext, childNode, output);
          }
        } else {
          const childContext = paramContext.clone([childNode], 0);
          childContext.inApplyTemplates = true;
          const childSelection = selectBestTemplate(
            expandedTemplates,
            childContext,
            this.matchResolver,
            this.xPath,
            this.warningsCallback
          );
          if (childSelection.selectedTemplate) {
            const childMetadata = this.templateSourceMap.get(childSelection.selectedTemplate);
            const childMatchPattern = xmlGetAttribute(childSelection.selectedTemplate, "match");
            const childModeAttr = xmlGetAttribute(childSelection.selectedTemplate, "mode");
            this.currentTemplateStack.push({
              template: childSelection.selectedTemplate,
              stylesheetDepth: (_a = childMetadata == null ? void 0 : childMetadata.importDepth) != null ? _a : 0,
              mode: childModeAttr || mode,
              match: childMatchPattern
            });
            const previousOverrideContext = this.currentOverrideContext;
            const overrideContext = childSelection.originalComponent || childSelection.selectedTemplate.__originalComponent;
            if (overrideContext) {
              this.currentOverrideContext = overrideContext;
            }
            try {
              yield this.xsltChildNodes(childContext, childSelection.selectedTemplate, output);
            } finally {
              this.currentTemplateStack.pop();
              this.currentOverrideContext = previousOverrideContext;
            }
          } else if (childNode.nodeType === DOM_ELEMENT_NODE) {
            yield this.applyBuiltInTemplate(childNode, expandedTemplates, mode, paramContext, output);
          }
        }
      }
    });
  }
  /**
   * Implements `xsl:apply-imports`.
   * Applies templates from imported stylesheets with the same match pattern and mode.
   * This enables template overriding where a template in an importing stylesheet
   * can call the overridden template from the imported stylesheet.
   * @param context The Expression Context.
   * @param template The apply-imports template node.
   * @param output The output node.
   */
  xsltApplyImports(context, template, output) {
    return __async(this, null, function* () {
      if (this.currentTemplateStack.length === 0) {
        throw new Error("<xsl:apply-imports> can only be used within a template");
      }
      const currentTemplateContext = this.currentTemplateStack[this.currentTemplateStack.length - 1];
      const {
        stylesheetDepth: currentDepth,
        mode: currentMode
      } = currentTemplateContext;
      const currentNode = context.nodeList[context.position];
      const top = template.ownerDocument.documentElement;
      const allTemplates = collectAndExpandTemplates(top, currentMode, this.xPath, this.templateSourceMap);
      const importedTemplates = allTemplates.filter((t) => {
        const metadata2 = this.templateSourceMap.get(t.template);
        return metadata2 && metadata2.importDepth > currentDepth;
      });
      if (importedTemplates.length === 0) {
        return;
      }
      const nodeContext = context.clone([currentNode], 0);
      const selection = selectBestTemplate(
        importedTemplates,
        nodeContext,
        this.matchResolver,
        this.xPath,
        this.warningsCallback
      );
      if (!selection.selectedTemplate) {
        return;
      }
      const importedContext = context.clone();
      yield this.xsltWithParam(importedContext, template);
      const metadata = this.templateSourceMap.get(selection.selectedTemplate);
      if (metadata) {
        const matchPattern = xmlGetAttribute(selection.selectedTemplate, "match");
        const modeAttr = xmlGetAttribute(selection.selectedTemplate, "mode");
        this.currentTemplateStack.push({
          template: selection.selectedTemplate,
          stylesheetDepth: metadata.importDepth,
          mode: modeAttr || currentMode,
          match: matchPattern
        });
        const previousOverrideContext = this.currentOverrideContext;
        const overrideContext = selection.originalComponent || selection.selectedTemplate.__originalComponent;
        if (overrideContext) {
          this.currentOverrideContext = overrideContext;
        }
        try {
          yield this.xsltChildNodes(importedContext, selection.selectedTemplate, output);
        } finally {
          this.currentTemplateStack.pop();
          this.currentOverrideContext = previousOverrideContext;
        }
      }
    });
  }
  /**
   * Implements `xsl:attribute`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output. Only used if there's no corresponding output node already defined.
   * @protected
   */
  xsltAttribute(context, template, output) {
    return __async(this, null, function* () {
      const nameExpr = xmlGetAttribute(template, "name");
      const name = this.xsltAttributeValue(nameExpr, context);
      const documentFragment = domCreateDocumentFragment(this.outputDocument);
      yield this.xsltChildNodes(context, template, documentFragment);
      const value = xmlValueLegacyBehavior(documentFragment);
      if (output) {
        domSetAttribute(output, name, value);
      }
    });
  }
  /**
   * Implements `xsl:call-template`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output, used when a fragment is passed by a previous step.
   */
  xsltCallTemplate(context, template, output) {
    return __async(this, null, function* () {
      const name = xmlGetAttribute(template, "name");
      const top = template.ownerDocument.documentElement;
      const paramContext = context.clone();
      yield this.xsltWithParam(paramContext, template);
      let foundTemplate = null;
      if (this.currentPackage) {
        this.currentPackage.usedPackages.forEach((usedPkg) => {
          usedPkg.acceptedComponents.forEach((component) => {
            if (component.type === "template" && component.name === name && component.isAccepted) {
              const effectiveComponent = this.getEffectiveComponent(component);
              foundTemplate = effectiveComponent.node;
            }
          });
        });
      }
      if (foundTemplate) {
        yield this.xsltChildNodes(paramContext, foundTemplate, output);
        return;
      }
      for (let i = 0; i < top.childNodes.length; ++i) {
        let childNode = top.childNodes[i];
        if (childNode.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(childNode, "template") && domGetAttributeValue(childNode, "name") === name) {
          yield this.xsltChildNodes(paramContext, childNode, output);
          break;
        }
      }
    });
  }
  /**
   * Implements `xsl:choose`, its child nodes `xsl:when`, and
   * `xsl:otherwise`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output. Only used if there's no corresponding output node already defined.
   */
  xsltChoose(context, template, output) {
    return __async(this, null, function* () {
      for (const childNode of template.childNodes) {
        if (childNode.nodeType !== DOM_ELEMENT_NODE) {
          continue;
        }
        if (this.isXsltElement(childNode, "when")) {
          const test = xmlGetAttribute(childNode, "test");
          if (this.xPath.xPathEval(test, context).booleanValue()) {
            yield this.xsltChildNodes(context, childNode, output);
            break;
          }
        } else if (this.isXsltElement(childNode, "otherwise")) {
          yield this.xsltChildNodes(context, childNode, output);
          break;
        }
      }
    });
  }
  /**
   * Implements `xsl:copy` for all node types.
   * @param {XNode} destination the node being copied to, part of output document.
   * @param {XNode} source the node being copied, part in input document.
   * @returns {XNode|null} If an element node was created, the element node. Otherwise, null.
   */
  xsltCopy(destination, source) {
    if (source.nodeType == DOM_ELEMENT_NODE) {
      let node = domCreateElement(this.outputDocument, source.nodeName);
      if (source.namespaceUri !== null && source.namespaceUri !== void 0) {
        domSetAttribute(node, "xmlns", source.namespaceUri);
      }
      node.siblingPosition = destination.childNodes.length;
      domAppendChild(destination, node);
      return node;
    }
    if (source.nodeType == DOM_TEXT_NODE) {
      if (this.shouldStripWhitespaceNode(source)) {
        return null;
      }
      let node = domCreateTextNode(this.outputDocument, source.nodeValue);
      node.siblingPosition = destination.childNodes.length;
      domAppendChild(destination, node);
    } else if (source.nodeType == DOM_CDATA_SECTION_NODE) {
      let node = domCreateCDATASection(this.outputDocument, source.nodeValue);
      node.siblingPosition = destination.childNodes.length;
      domAppendChild(destination, node);
    } else if (source.nodeType == DOM_COMMENT_NODE) {
      let node = domCreateComment(this.outputDocument, source.nodeValue);
      node.siblingPosition = destination.childNodes.length;
      domAppendChild(destination, node);
    } else if (source.nodeType == DOM_ATTRIBUTE_NODE) {
      domSetAttribute(destination, source.nodeName, source.nodeValue);
    }
    return null;
  }
  /**
   * Implements `xsl:comment`. 
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output. Only used if there's no corresponding output node already defined. 
   */
  xsltComment(context, template, output) {
    return __async(this, null, function* () {
      const node = domCreateDocumentFragment(this.outputDocument);
      yield this.xsltChildNodes(context, template, node);
      const commentData = xmlValue(node);
      const commentNode = domCreateComment(this.outputDocument, commentData);
      const resolvedOutput = output || this.outputDocument;
      resolvedOutput.appendChild(commentNode);
    });
  }
  /**
   * Implements `xsl:processing-instruction`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output. Only used if there's no corresponding output node already defined.
   */
  xsltProcessingInstruction(context, template, output) {
    return __async(this, null, function* () {
      const nameExpr = xmlGetAttribute(template, "name");
      if (!nameExpr) {
        throw new Error('<xsl:processing-instruction> requires a "name" attribute');
      }
      const target = this.xsltAttributeValue(nameExpr, context);
      if (!target) {
        throw new Error("<xsl:processing-instruction> target name cannot be empty");
      }
      if (target.toLowerCase() === "xml") {
        throw new Error('Processing instruction target cannot be "xml"');
      }
      if (!/^[a-zA-Z_][a-zA-Z0-9_:.-]*$/.test(target)) {
        throw new Error(`Invalid processing instruction target: "${target}"`);
      }
      const documentFragment = domCreateDocumentFragment(this.outputDocument);
      yield this.xsltChildNodes(context, template, documentFragment);
      const data2 = xmlValue(documentFragment);
      const pi2 = domCreateProcessingInstruction(this.outputDocument, target, data2);
      const resolvedOutput = output || this.outputDocument;
      domAppendChild(resolvedOutput, pi2);
    });
  }
  /**
   * Implements `xsl:copy-of` for node-set values of the select
   * expression. Recurses down the source node tree, which is part of
   * the input document.
   * @param {XNode} destination the node being copied to, part of output document.
   * @param {XNode} source the node being copied, part in input document.
   */
  xsltCopyOf(destination, source) {
    if (source.nodeType == DOM_DOCUMENT_FRAGMENT_NODE || source.nodeType == DOM_DOCUMENT_NODE) {
      for (let i = 0; i < source.childNodes.length; ++i) {
        this.xsltCopyOf(destination, source.childNodes[i]);
      }
    } else {
      const node = this.xsltCopy(destination, source);
      if (node) {
        for (let i = 0; i < source.childNodes.length; ++i) {
          this.xsltCopyOf(node, source.childNodes[i]);
        }
      }
    }
  }
  /**
   * Implements `xsl:decimal-format`, registering the settings in this instance
   * and the current context. 
   * @param context The Expression Context.
   * @param template The template.
   */
  xsltDecimalFormat(context, template) {
    const name = xmlGetAttribute(template, "name");
    const decimalSeparator = xmlGetAttribute(template, "decimal-separator");
    const groupingSeparator = xmlGetAttribute(template, "grouping-separator");
    const infinity = xmlGetAttribute(template, "infinity");
    const minusSign = xmlGetAttribute(template, "minus-sign");
    const naN = xmlGetAttribute(template, "NaN");
    const percent = xmlGetAttribute(template, "percent");
    const perMille = xmlGetAttribute(template, "per-mille");
    const zeroDigit = xmlGetAttribute(template, "zero-digit");
    const digit = xmlGetAttribute(template, "digit");
    const patternSeparator = xmlGetAttribute(template, "pattern-separator");
    this.decimalFormatSettings = {
      name: name || this.decimalFormatSettings.name,
      decimalSeparator: decimalSeparator || this.decimalFormatSettings.decimalSeparator,
      groupingSeparator: groupingSeparator || this.decimalFormatSettings.groupingSeparator,
      infinity: infinity || this.decimalFormatSettings.infinity,
      minusSign: minusSign || this.decimalFormatSettings.minusSign,
      naN: naN || this.decimalFormatSettings.naN,
      percent: percent || this.decimalFormatSettings.percent,
      perMille: perMille || this.decimalFormatSettings.perMille,
      zeroDigit: zeroDigit || this.decimalFormatSettings.zeroDigit,
      digit: digit || this.decimalFormatSettings.digit,
      patternSeparator: patternSeparator || this.decimalFormatSettings.patternSeparator
    };
    context.decimalFormatSettings = this.decimalFormatSettings;
  }
  /**
   * Implements `xsl:element`.
   * @param context The Expression Context.
   * @param template The template.
   */
  xsltElement(context, template, output) {
    return __async(this, null, function* () {
      const nameExpr = xmlGetAttribute(template, "name");
      const name = this.xsltAttributeValue(nameExpr, context);
      const node = domCreateElement(this.outputDocument, name);
      const useAttributeSets = xmlGetAttribute(template, "use-attribute-sets");
      if (useAttributeSets) {
        yield this.applyAttributeSets(context, node, useAttributeSets);
      }
      domAppendChild(output || this.outputDocument, node);
      const clonedContext = context.clone(void 0, 0);
      yield this.xsltChildNodes(clonedContext, template, node);
    });
  }
  /**
   * Implements `xsl:accumulator` (XSLT 3.0).
   *
   * Accumulators are a declarative way to compute values during template processing.
   * They consist of rules that are applied as elements are processed.
   *
   * @param context The expression context
   * @param template The xsl:accumulator element
   */
  xsltAccumulator(context, template) {
    const name = xmlGetAttribute(template, "name");
    if (!name) {
      throw new Error('<xsl:accumulator> requires a "name" attribute');
    }
    const initialValue = xmlGetAttribute(template, "initial-value") || "()";
    const as = xmlGetAttribute(template, "as") || "xs:anyAtomicType*";
    const streamableStr = xmlGetAttribute(template, "streamable") || "no";
    const streamable = streamableStr === "yes" || streamableStr === "true" || streamableStr === "1";
    const rules = [];
    for (let i = 0; i < template.childNodes.length; i++) {
      const child = template.childNodes[i];
      if (child.nodeType === DOM_ELEMENT_NODE && child.nodeName === "accumulator-rule") {
        const match = xmlGetAttribute(child, "match");
        if (!match) {
          throw new Error('<xsl:accumulator-rule> requires a "match" attribute');
        }
        const select = xmlGetAttribute(child, "select");
        if (!select) {
          throw new Error('<xsl:accumulator-rule> requires a "select" attribute');
        }
        const phase = xmlGetAttribute(child, "phase");
        rules.push({
          match,
          select,
          phase: phase === "start" || phase === "end" ? phase : void 0
        });
      }
    }
    const definition = {
      name,
      initialValue,
      as,
      rules,
      streamable
    };
    this.accumulatorRegistry.registerAccumulator(definition);
    try {
      const initialResult = this.xPath.xPathEval(initialValue, context);
      const state = {
        currentValue: initialResult,
        valueStack: [initialResult]
      };
      this.accumulatorRegistry.setAccumulatorState(name, state);
    } catch (e) {
      const state = {
        currentValue: null,
        valueStack: [null]
      };
      this.accumulatorRegistry.setAccumulatorState(name, state);
    }
  }
  /**
   * Evaluates all matching accumulator rules for a given node
   * and updates the accumulator state
   *
   * @param context The expression context with current node
   * @param node The current node being processed
   */
  evaluateAccumulatorRules(context, node) {
    const allAccumulators = this.accumulatorRegistry.getAllAccumulators();
    for (const accumulator of allAccumulators) {
      const state = this.accumulatorRegistry.getAccumulatorState(accumulator.name);
      if (!state) continue;
      for (const rule of accumulator.rules) {
        try {
          const matchContext = context.clone([node], 0);
          const matchedNodes = this.xsltMatch(rule.match, matchContext);
          const matchResult = matchedNodes && matchedNodes.length > 0;
          if (matchResult) {
            const ruleContext = context.clone([node], 0);
            ruleContext.setVariable("value", new StringValue(
              state.currentValue ? String(state.currentValue) : ""
            ));
            const newValue = this.xPath.xPathEval(rule.select, ruleContext);
            state.currentValue = newValue;
          }
        } catch (e) {
          if (this.warningsCallback) {
            this.warningsCallback(`Error evaluating accumulator rule for ${accumulator.name}: ${e}`);
          }
        }
      }
    }
  }
  /**
   * Retrieves the current value of an accumulator
   * Used when accessing accumulators in templates via accumulator-after() or accumulator-before()
   *
   * @param accumulatorName The name of the accumulator
   * @returns The current value of the accumulator, or null if not found
   */
  getAccumulatorValue(accumulatorName) {
    const state = this.accumulatorRegistry.getAccumulatorState(accumulatorName);
    return state ? state.currentValue : null;
  }
  /**
   * Implements `xsl:for-each`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltForEach(context, template, output) {
    return __async(this, null, function* () {
      const select = xmlGetAttribute(template, "select");
      const nodes = this.xPath.xPathEval(select, context).nodeSetValue();
      const onEmpty = this.findConditionalChild(template, "on-empty");
      const onNonEmpty = this.findConditionalChild(template, "on-non-empty");
      if (nodes.length === 0) {
        if (onEmpty) {
          yield this.xsltChildNodes(context.clone(), onEmpty, output);
        }
        return;
      }
      if (onNonEmpty) {
        yield this.xsltChildNodes(context.clone(), onNonEmpty, output);
        return;
      }
      const sortContext = context.clone(nodes);
      this.xsltSort(sortContext, template);
      const nodesWithParent = sortContext.nodeList.filter((n) => n.parentNode !== null && n.parentNode !== void 0);
      if (nodesWithParent.length <= 0) {
        throw new Error("Nodes with no parents defined.");
      }
      for (let i = 0; i < sortContext.contextSize(); ++i) {
        yield this.xsltChildNodesExcludingConditional(
          sortContext.clone(sortContext.nodeList, i),
          template,
          output
        );
      }
    });
  }
  /**
   * Implements `xsl:for-each-group` (XSLT 2.0).
   *
   * Groups items from the select expression and processes each group.
   * Supports group-by and group-adjacent grouping methods.
   *
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltForEachGroup(context, template, output) {
    return __async(this, null, function* () {
      const select = xmlGetAttribute(template, "select");
      const groupBy = xmlGetAttribute(template, "group-by");
      const groupAdjacent = xmlGetAttribute(template, "group-adjacent");
      const groupStartingWith = xmlGetAttribute(template, "group-starting-with");
      const groupEndingWith = xmlGetAttribute(template, "group-ending-with");
      const onEmpty = this.findConditionalChild(template, "on-empty");
      const onNonEmpty = this.findConditionalChild(template, "on-non-empty");
      if (!select) {
        throw new Error("<xsl:for-each-group> requires a select attribute.");
      }
      const groupingMethods = [groupBy, groupAdjacent, groupStartingWith, groupEndingWith].filter((m) => m);
      if (groupingMethods.length === 0) {
        throw new Error("<xsl:for-each-group> requires one of: group-by, group-adjacent, group-starting-with, or group-ending-with.");
      }
      if (groupingMethods.length > 1) {
        throw new Error("<xsl:for-each-group> can only have one grouping method.");
      }
      const items = this.xPath.xPathEval(select, context).nodeSetValue();
      if (items.length === 0) {
        if (onEmpty) {
          yield this.xsltChildNodes(context.clone(), onEmpty, output);
        }
        return;
      }
      let groups;
      if (groupBy) {
        groups = this.groupByKey(items, groupBy, context);
      } else if (groupAdjacent) {
        groups = this.groupAdjacent(items, groupAdjacent, context);
      } else if (groupStartingWith) {
        groups = this.groupStartingWith(items, groupStartingWith, context);
      } else if (groupEndingWith) {
        groups = this.groupEndingWith(items, groupEndingWith, context);
      } else {
        return;
      }
      if (onNonEmpty) {
        yield this.xsltChildNodes(context.clone(), onNonEmpty, output);
        return;
      }
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        const groupContext = context.clone(group.items, 0);
        groupContext.currentGroup = group.items;
        groupContext.currentGroupingKey = group.key;
        yield this.xsltChildNodesExcludingConditional(groupContext, template, output);
      }
    });
  }
  /**
   * Group items by a computed key value.
   * Items with the same key are placed in the same group.
   */
  groupByKey(items, keyExpr, context) {
    const groupMap = /* @__PURE__ */ new Map();
    const groupOrder = [];
    for (const item of items) {
      const itemContext = context.clone([item], 0);
      const keyValue = this.xPath.xPathEval(keyExpr, itemContext);
      const keyString = keyValue.stringValue();
      if (!groupMap.has(keyString)) {
        groupMap.set(keyString, { key: keyString, items: [] });
        groupOrder.push(keyString);
      }
      groupMap.get(keyString).items.push(item);
    }
    return groupOrder.map((key) => groupMap.get(key));
  }
  /**
   * Group adjacent items with the same key.
   * A new group starts when the key changes.
   */
  groupAdjacent(items, keyExpr, context) {
    const groups = [];
    let currentKey = null;
    let currentGroup = [];
    for (const item of items) {
      const itemContext = context.clone([item], 0);
      const keyValue = this.xPath.xPathEval(keyExpr, itemContext);
      const keyString = keyValue.stringValue();
      if (currentKey === null || keyString !== currentKey) {
        if (currentGroup.length > 0) {
          groups.push({ key: currentKey, items: currentGroup });
        }
        currentKey = keyString;
        currentGroup = [item];
      } else {
        currentGroup.push(item);
      }
    }
    if (currentGroup.length > 0) {
      groups.push({ key: currentKey, items: currentGroup });
    }
    return groups;
  }
  /**
   * Convert an XSLT pattern to a self:: expression for matching against the current node.
   * For example, "h1" becomes "self::h1", "section[@type]" becomes "self::section[@type]".
   */
  patternToSelfExpression(pattern) {
    if (pattern.includes("::") || pattern.startsWith("/") || pattern.startsWith("(")) {
      return pattern;
    }
    return `self::${pattern}`;
  }
  /**
   * Group items starting with items that match a pattern.
   * A new group starts when an item matches the pattern.
   */
  groupStartingWith(items, pattern, context) {
    const groups = [];
    let currentGroup = [];
    let groupIndex = 0;
    const selfPattern = this.patternToSelfExpression(pattern);
    for (const item of items) {
      const itemContext = context.clone([item], 0);
      const matches2 = this.xPath.xPathEval(selfPattern, itemContext).booleanValue();
      if (matches2 && currentGroup.length > 0) {
        groups.push({ key: groupIndex++, items: currentGroup });
        currentGroup = [item];
      } else if (matches2 && currentGroup.length === 0) {
        currentGroup = [item];
      } else {
        currentGroup.push(item);
      }
    }
    if (currentGroup.length > 0) {
      groups.push({ key: groupIndex, items: currentGroup });
    }
    return groups;
  }
  /**
   * Group items ending with items that match a pattern.
   * A group ends when an item matches the pattern.
   */
  groupEndingWith(items, pattern, context) {
    const groups = [];
    let currentGroup = [];
    let groupIndex = 0;
    const selfPattern = this.patternToSelfExpression(pattern);
    for (const item of items) {
      currentGroup.push(item);
      const itemContext = context.clone([item], 0);
      const matches2 = this.xPath.xPathEval(selfPattern, itemContext).booleanValue();
      if (matches2) {
        groups.push({ key: groupIndex++, items: currentGroup });
        currentGroup = [];
      }
    }
    if (currentGroup.length > 0) {
      groups.push({ key: groupIndex, items: currentGroup });
    }
    return groups;
  }
  /**
   * Implements `xsl:iterate` (XSLT 3.0).
   *
   * Iterates over a sequence, maintaining accumulators that are updated across iterations.
   * Each iteration can output content and update accumulator values.
   * After all iterations complete, optional xsl:on-completion is executed.
   *
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltIterate(context, template, output) {
    return __async(this, null, function* () {
      const select = xmlGetAttribute(template, "select");
      if (!select) {
        throw new Error("<xsl:iterate> requires a select attribute.");
      }
      const items = this.xPath.xPathEval(select, context).nodeSetValue();
      if (items.length === 0) {
        const onCompletionElements2 = Array.from(template.childNodes || []).filter(
          (node) => node.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(node, "on-completion")
        );
        if (onCompletionElements2.length > 0) {
          const onCompletion = onCompletionElements2[0];
          const completionContext = context.clone([], 0);
          yield this.xsltChildNodes(completionContext, onCompletion, output);
        }
        return;
      }
      const accumulators = {};
      const paramElements = Array.from(template.childNodes || []).filter(
        (node) => node.nodeType === DOM_ELEMENT_NODE && node.localName === "param" && this.isXsltElement(node)
      );
      for (const paramNode of paramElements) {
        const paramName = xmlGetAttribute(paramNode, "name");
        if (!paramName) {
          throw new Error("<xsl:param> in <xsl:iterate> requires a name attribute.");
        }
        const selectValue = xmlGetAttribute(paramNode, "select");
        let initialValue = new StringValue("");
        if (selectValue) {
          initialValue = this.xPath.xPathEval(selectValue, context);
        }
        accumulators[paramName] = initialValue;
      }
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const iterationContext = context.clone([item], 0);
        for (const accName in accumulators) {
          iterationContext.variables[accName] = accumulators[accName];
        }
        const allBodyNodes = Array.from(template.childNodes || []);
        for (const bodyNode of allBodyNodes) {
          if (bodyNode.nodeType === DOM_ELEMENT_NODE) {
            const elem = bodyNode;
            if (this.isXsltElement(elem) && (elem.localName === "param" || elem.localName === "on-completion" || elem.localName === "next-iteration")) {
              continue;
            }
          }
          yield this.xsltProcessContext(iterationContext, bodyNode, output);
        }
        const nextIterationElements = Array.from(template.childNodes || []).filter(
          (node) => node.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(node, "next-iteration")
        );
        if (nextIterationElements.length > 0) {
          const nextIteration = nextIterationElements[0];
          const withParamElements = Array.from(nextIteration.childNodes || []).filter(
            (node) => node.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(node, "with-param")
          );
          for (const withParam of withParamElements) {
            const paramName = xmlGetAttribute(withParam, "name");
            if (!paramName) {
              throw new Error("<xsl:with-param> requires a name attribute.");
            }
            const selectValue = xmlGetAttribute(withParam, "select");
            if (selectValue) {
              const newValue = this.xPath.xPathEval(selectValue, iterationContext);
              accumulators[paramName] = newValue;
            }
          }
        }
      }
      const onCompletionElements = Array.from(template.childNodes || []).filter(
        (node) => node.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(node, "on-completion")
      );
      if (onCompletionElements.length > 0) {
        const onCompletion = onCompletionElements[0];
        const completionContext = context.clone([], 0);
        for (const accName in accumulators) {
          completionContext.variables[accName] = accumulators[accName];
        }
        yield this.xsltChildNodes(completionContext, onCompletion, output);
      }
    });
  }
  /**
   * Implements `xsl:try`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltTry(context, template, output) {
    return __async(this, null, function* () {
      const tryBodyNodes = Array.from(template.childNodes || []).filter(
        (node) => node.nodeType === DOM_ELEMENT_NODE && !this.isXsltElement(node, "catch")
      );
      const catchElements = Array.from(template.childNodes || []).filter(
        (node) => node.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(node, "catch")
      );
      try {
        for (const bodyNode of tryBodyNodes) {
          yield this.xsltProcessContext(context, bodyNode, output);
        }
      } catch (error) {
        let errorCode = "err:UNKNOWN";
        if (error && typeof error === "object") {
          if (error.code) {
            errorCode = error.code;
          } else if (error.message) {
            if (error.message.includes("division by zero") || error.message.includes("div 0")) {
              errorCode = "err:FOAR0001";
            } else if (error.message.includes("undefined")) {
              errorCode = "err:XPDY0002";
            }
          }
        }
        let caught = false;
        for (const catchElement of catchElements) {
          const errorsAttr = xmlGetAttribute(catchElement, "errors");
          if (!errorsAttr) {
            caught = true;
          } else {
            const errorPatterns = errorsAttr.split("|").map((p) => p.trim());
            for (const pattern of errorPatterns) {
              if (pattern === "*" || pattern === errorCode) {
                caught = true;
                break;
              }
              if (pattern.endsWith("*")) {
                const prefix = pattern.slice(0, -1);
                if (errorCode.startsWith(prefix)) {
                  caught = true;
                  break;
                }
              }
            }
          }
          if (caught) {
            yield this.xsltChildNodes(context, catchElement, output);
            return;
          }
        }
        if (!caught && catchElements.length > 0) {
          throw error;
        }
      }
    });
  }
  /**
   * Implements `xsl:evaluate` (XSLT 3.0).
   * Dynamically evaluates an XPath expression constructed as a string.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltEvaluate(context, template, output) {
    return __async(this, null, function* () {
      const xpathAttr = xmlGetAttribute(template, "xpath");
      if (!xpathAttr) {
        throw new Error("<xsl:evaluate> requires an xpath attribute.");
      }
      const xpathExpr = this.xPath.xPathEval(xpathAttr, context).stringValue();
      let contextItem = null;
      const contextItemAttr = xmlGetAttribute(template, "context-item");
      if (contextItemAttr) {
        const contextItemResult = this.xPath.xPathEval(contextItemAttr, context);
        const items = contextItemResult.nodeSetValue();
        if (items.length > 0) {
          contextItem = items[0];
        }
      }
      let evalContext;
      if (contextItem) {
        evalContext = context.clone([contextItem], 0);
      } else {
        evalContext = context.clone();
      }
      try {
        const result = this.xPath.xPathEval(xpathExpr, evalContext);
        const destinationNode = output || this.outputDocument;
        if (result.type === "node-set") {
          const nodes = result.nodeSetValue();
          for (const node of nodes) {
            this.xsltCopyOf(destinationNode, node);
          }
        } else if (result.type === "array" && result.arrayValue) {
          const arrayItems = result.arrayValue();
          for (const item of arrayItems) {
            let textNode = domCreateTextNode(this.outputDocument, item.stringValue());
            textNode.siblingPosition = destinationNode.childNodes.length;
            domAppendChild(destinationNode, textNode);
          }
        } else {
          let textNode = domCreateTextNode(this.outputDocument, result.stringValue());
          textNode.siblingPosition = destinationNode.childNodes.length;
          domAppendChild(destinationNode, textNode);
        }
      } catch (error) {
        throw new Error(`Dynamic XPath evaluation error in xsl:evaluate: ${error.message}`);
      }
    });
  }
  /**
   * Implements `xsl:if`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltIf(context, template, output) {
    return __async(this, null, function* () {
      const test = xmlGetAttribute(template, "test");
      if (this.xPath.xPathEval(test, context).booleanValue()) {
        yield this.xsltChildNodes(context, template, output);
      }
    });
  }
  /**
   * Common implementation for `<xsl:import>` and `<xsl:include>`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   * @param isImport Whether this is an import (true) or include (false).
   */
  xsltImportOrInclude(context, template, output, isImport) {
    return __async(this, null, function* () {
      const elementName = isImport ? "xsl:import" : "xsl:include";
      const [major, minor] = process.versions.node.split(".").map(Number);
      if (major <= 17 && minor < 5) {
        throw new Error(`Your Node.js version does not support \`<${elementName}>\`. If possible, please update your Node.js version to at least version 17.5.0.`);
      }
      if (!global.globalThis.fetch) {
        global.globalThis.fetch = fetch;
        global.globalThis.Headers = Headers;
        global.globalThis.Request = Request;
        global.globalThis.Response = Response;
      }
      const hrefAttributeFind = template.childNodes.filter((n) => n.nodeName === "href");
      if (hrefAttributeFind.length <= 0) {
        throw new Error(`<${elementName}> with no href attribute defined.`);
      }
      const hrefAttribute = hrefAttributeFind[0];
      const href = hrefAttribute.nodeValue;
      if (this.importedStylesheets.has(href)) {
        return;
      }
      const fetchTest = yield global.globalThis.fetch(href);
      const fetchResponse = yield fetchTest.text();
      const includedXslt = this.xmlParser.xmlParse(fetchResponse);
      const currentDepth = this.styleSheetStack.length > 0 ? this.styleSheetStack[this.styleSheetStack.length - 1].importDepth : 0;
      const metadata = {
        importDepth: isImport ? currentDepth + 1 : currentDepth,
        // Includes are same depth, imports are deeper
        href,
        order: this.importedStylesheets.size
      };
      this.styleSheetStack.push(metadata);
      this.importedStylesheets.set(href, includedXslt);
      const stylesheetRoot = includedXslt.childNodes[0];
      if (stylesheetRoot) {
        this.mapTemplatesFromStylesheet(stylesheetRoot, metadata);
      }
      yield this.xsltChildNodes(context, stylesheetRoot, output);
      this.styleSheetStack.pop();
    });
  }
  /**
   * Implements `<xsl:import>`. For now the code is nearly identical to `<xsl:include>`, but there's
   * no precedence evaluation implemented yet.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltImport(context, template, output) {
    return __async(this, null, function* () {
      yield this.xsltImportOrInclude(context, template, output, true);
    });
  }
  /**
   * Implements `xsl:include`.
   * @param context The Expression Context.
   * @param template The template.
   * @param output The output.
   */
  xsltInclude(context, template, output) {
    return __async(this, null, function* () {
      yield this.xsltImportOrInclude(context, template, output, false);
    });
  }
  /**
   * Implements `<xsl:package>` (XSLT 3.0 Section 3.6).
   * Defines a package of XSLT components with controlled visibility.
   * @param context The Expression Context.
   * @param template The xsl:package element.
   * @param output The output node.
   */
  xsltPackage(context, template, output) {
    return __async(this, null, function* () {
      const version = xmlGetAttribute(template, "version") || this.version;
      if (!version || parseFloat(version) < 3) {
        throw new Error("<xsl:package> is only supported in XSLT 3.0 or later.");
      }
      const name = xmlGetAttribute(template, "name");
      const packageVersion = xmlGetAttribute(template, "package-version");
      const declaredModes = xmlGetAttribute(template, "declared-modes") || "yes";
      const inputTypeAnnotations = xmlGetAttribute(template, "input-type-annotations") || "unspecified";
      if (!name) {
        throw new Error('<xsl:package> requires a "name" attribute.');
      }
      const packageKey = packageVersion ? `${name}@${packageVersion}` : name;
      const wasAlreadyLoading = this.packageRegistry.isLoading(packageKey);
      if (!wasAlreadyLoading) {
        this.packageRegistry.beginLoading(packageKey);
      }
      const pkg = {
        name,
        version: packageVersion,
        root: template,
        components: /* @__PURE__ */ new Map(),
        usedPackages: /* @__PURE__ */ new Map(),
        isTopLevel: this.currentPackage === null,
        overrides: /* @__PURE__ */ new Map(),
        modes: /* @__PURE__ */ new Map(),
        declaredModes,
        inputTypeAnnotations
      };
      const previousPackage = this.currentPackage;
      this.currentPackage = pkg;
      try {
        this.packageRegistry.register(pkg);
        yield this.xsltTransformOrStylesheet(context, template, output);
      } finally {
        if (!wasAlreadyLoading) {
          this.packageRegistry.endLoading(packageKey);
        }
        this.currentPackage = previousPackage;
      }
    });
  }
  /**
   * Loads and registers an external package.
   * Creates a temporary context and processes the package document.
   * 
   * @param name The package name/URI.
   * @param packageDoc The parsed package document.
   * @param version Optional semantic version string.
   */
  loadAndRegisterPackage(name, packageDoc, version) {
    return __async(this, null, function* () {
      const packageKey = version ? `${name}@${version}` : name;
      if (!this.packageRegistry.beginLoading(packageKey)) {
        throw new Error(`Circular package dependency detected: "${packageKey}".`);
      }
      try {
        let packageRoot = packageDoc;
        if (packageDoc.nodeType === DOM_DOCUMENT_NODE) {
          for (const child of packageDoc.childNodes) {
            if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "package")) {
              packageRoot = child;
              break;
            }
          }
        }
        if (packageRoot && this.isXsltElement(packageRoot, "package")) {
          if (name && !xmlGetAttribute(packageRoot, "name")) {
            domSetAttribute(packageRoot, "name", name);
          }
          if (version && !xmlGetAttribute(packageRoot, "package-version")) {
            domSetAttribute(packageRoot, "package-version", version);
          }
          const tempContext = new ExprContext([packageRoot]);
          yield this.xsltPackage(tempContext, packageRoot);
        } else {
          throw new Error("Package document does not contain an xsl:package root element.");
        }
      } finally {
        this.packageRegistry.endLoading(packageKey);
      }
    });
  }
  /**
   * Implements `<xsl:use-package>` (XSLT 3.0 Section 3.7).
   * Imports another package and makes its public components available.
   * @param context The Expression Context.
   * @param template The xsl:use-package element.
   * @param output The output node.
   */
  xsltUsePackage(context, template, output) {
    return __async(this, null, function* () {
      if (!this.currentPackage) {
        throw new Error("<xsl:use-package> can only appear as a child of <xsl:package>.");
      }
      const name = xmlGetAttribute(template, "name");
      const packageVersion = xmlGetAttribute(template, "package-version");
      if (!name) {
        throw new Error('<xsl:use-package> requires a "name" attribute.');
      }
      const packageKey = packageVersion ? `${name}@${packageVersion}` : name;
      if (this.packageRegistry.isLoading(packageKey)) {
        throw new Error(`Circular package dependency detected: "${packageKey}".`);
      }
      let usedPackage = this.packageRegistry.get(name, packageVersion);
      if (!usedPackage && this.packageLoader) {
        try {
          const packageDoc = yield this.packageLoader(name, packageVersion);
          if (packageDoc) {
            yield this.loadAndRegisterPackage(name, packageDoc, packageVersion);
            usedPackage = this.packageRegistry.get(name, packageVersion);
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("Circular package dependency")) {
            throw error;
          }
        }
      }
      if (!usedPackage) {
        throw new Error(
          `Package "${name}"${packageVersion ? `@${packageVersion}` : ""} not found. ` + (this.packageLoader ? "Package loader failed to load the package." : "Packages must be loaded before they can be used.")
        );
      }
      const usedPkg = {
        package: usedPackage,
        acceptedComponents: /* @__PURE__ */ new Map()
      };
      const key = packageVersion ? `${name}@${packageVersion}` : name;
      this.currentPackage.usedPackages.set(key, usedPkg);
      for (const child of template.childNodes) {
        if (this.isXsltElement(child, "accept")) {
          this.xsltAccept(context, child);
        } else if (this.isXsltElement(child, "override")) {
          yield this.xsltOverride(context, child, output);
        }
      }
      yield this.registerAcceptedVariables(context);
      this.registerUserDefinedFunctionsInContext(context);
      usedPackage.components.forEach((component, key2) => {
        if (component.visibility === "abstract") {
          const hasOverride = this.currentPackage.overrides.has(key2);
          if (!hasOverride) {
            throw new Error(
              `Abstract component "${component.name || component.match || key2}" from package "${name}" must be overridden.`
            );
          }
        }
      });
    });
  }
  /**
   * Implements `<xsl:expose>` (XSLT 3.0 Section 3.8).
   * Marks a component as visible outside the package.
   * @param context The Expression Context.
   * @param template The xsl:expose element.
   */
  xsltExpose(context, template) {
    if (!this.currentPackage) {
      throw new Error("<xsl:expose> can only appear as a child of <xsl:package>.");
    }
    const componentType = xmlGetAttribute(template, "component");
    const names = xmlGetAttribute(template, "names");
    const visibility = xmlGetAttribute(template, "visibility") || "public";
    if (!componentType) {
      throw new Error('<xsl:expose> requires a "component" attribute (template, function, variable, attribute-set, mode).');
    }
    const nameList = names === "*" ? ["*"] : names ? names.split(/\s+/) : [];
    if (nameList.length === 0) {
      throw new Error('<xsl:expose> requires a "names" attribute.');
    }
    for (const name of nameList) {
      const actualComponent = this.findComponentInPackageRoot(
        this.currentPackage.root,
        componentType,
        name === "*" ? null : name
      );
      if (actualComponent) {
        const component = {
          type: componentType,
          name: actualComponent.name || (name !== "*" ? name : void 0),
          match: actualComponent.match,
          mode: actualComponent.mode,
          visibility,
          overridable: visibility !== "final",
          node: actualComponent.node,
          priority: actualComponent.priority
        };
        const key = makeComponentKey(component);
        this.currentPackage.components.set(key, component);
      } else if (name !== "*") {
      }
    }
  }
  /**
   * Find a component definition in the package root.
   * @param packageRoot The package root element
   * @param type The component type to find
   * @param name The component name (null for all matching type)
   * @returns Component information or null if not found
   */
  findComponentInPackageRoot(packageRoot, type, name) {
    for (const child of packageRoot.childNodes) {
      if (child.nodeType !== DOM_ELEMENT_NODE) {
        continue;
      }
      if (type === "template" && this.isXsltElement(child, "template")) {
        const templateName = xmlGetAttribute(child, "name");
        const match = xmlGetAttribute(child, "match");
        const mode = xmlGetAttribute(child, "mode");
        if (name) {
          if (templateName === name) {
            return { node: child, name: templateName, match, mode };
          }
        } else {
          return { node: child, name: templateName, match, mode };
        }
      } else if (type === "function" && this.isXsltElement(child, "function")) {
        const functionName2 = xmlGetAttribute(child, "name");
        if (!name || functionName2 === name) {
          return { node: child, name: functionName2 };
        }
      } else if (type === "variable" && this.isXsltElement(child, "variable")) {
        const varName = xmlGetAttribute(child, "name");
        if (!name || varName === name) {
          return { node: child, name: varName };
        }
      } else if (type === "attribute-set" && this.isXsltElement(child, "attribute-set")) {
        const setName = xmlGetAttribute(child, "name");
        if (!name || setName === name) {
          return { node: child, name: setName };
        }
      }
    }
    return null;
  }
  /**
   * Implements `<xsl:accept>` (XSLT 3.0 Section 3.9).
   * Accepts and optionally overrides a component from a used package.
   * @param context The Expression Context.
   * @param template The xsl:accept element.
   */
  xsltAccept(context, template) {
    if (!this.currentPackage) {
      throw new Error("<xsl:accept> can only appear as a child of <xsl:use-package>.");
    }
    const componentType = xmlGetAttribute(template, "component");
    const names = xmlGetAttribute(template, "names");
    const visibilityOverride = xmlGetAttribute(template, "visibility");
    if (!componentType) {
      throw new Error('<xsl:accept> requires a "component" attribute.');
    }
    if (!names) {
      throw new Error('<xsl:accept> requires a "names" attribute.');
    }
    const nameList = names === "*" ? ["*"] : names.split(/\s+/);
    const parentUsePackage = template.parentNode;
    if (!parentUsePackage || !this.isXsltElement(parentUsePackage, "use-package")) {
      throw new Error("<xsl:accept> must be a child of <xsl:use-package>.");
    }
    const packageName = xmlGetAttribute(parentUsePackage, "name");
    const packageVersion = xmlGetAttribute(parentUsePackage, "package-version");
    const key = packageVersion ? `${packageName}@${packageVersion}` : packageName;
    const usedPkg = this.currentPackage.usedPackages.get(key);
    if (!usedPkg) {
      throw new Error(`Internal error: used package "${key}" not found.`);
    }
    const componentsToAccept = this.findComponentsInPackage(
      usedPkg.package,
      componentType,
      nameList
    );
    for (const component of componentsToAccept) {
      if (!isComponentVisible(component, false)) {
        const componentName = component.name || component.match || "unnamed";
        throw new Error(
          `Cannot accept private component "${componentName}" of type "${componentType}" from package "${usedPkg.package.name}".`
        );
      }
      const acceptedComponent = __spreadProps(__spreadValues({}, component), {
        sourcePackage: usedPkg.package.name,
        isAccepted: true,
        effectiveVisibility: visibilityOverride || component.visibility
      });
      const componentKey = makeComponentKey(acceptedComponent);
      usedPkg.acceptedComponents.set(componentKey, acceptedComponent);
    }
  }
  /**
   * Implements <xsl:override> (XSLT 3.0 Section 3.7.2).
   * Overrides components from a used package.
   */
  xsltOverride(context, template, output) {
    return __async(this, null, function* () {
      if (!this.currentPackage) {
        throw new Error("<xsl:override> can only appear as a child of <xsl:use-package>.");
      }
      const parentUsePackage = template.parentNode;
      if (!parentUsePackage || !this.isXsltElement(parentUsePackage, "use-package")) {
        throw new Error("<xsl:override> must be a child of <xsl:use-package>.");
      }
      const packageName = xmlGetAttribute(parentUsePackage, "name");
      const packageVersion = xmlGetAttribute(parentUsePackage, "package-version");
      const key = packageVersion ? `${packageName}@${packageVersion}` : packageName;
      const usedPkg = this.currentPackage.usedPackages.get(key);
      if (!usedPkg) {
        throw new Error(`Internal error: used package "${key}" not found.`);
      }
      for (let i = 0; i < template.childNodes.length; i++) {
        const child = template.childNodes[i];
        if (child.nodeType !== DOM_ELEMENT_NODE) {
          continue;
        }
        const localName = child.localName;
        let componentType = null;
        let componentName = null;
        let componentMatch = null;
        switch (localName) {
          case "template":
            componentType = "template";
            componentName = xmlGetAttribute(child, "name");
            componentMatch = xmlGetAttribute(child, "match");
            break;
          case "function":
            componentType = "function";
            componentName = xmlGetAttribute(child, "name");
            break;
          case "variable":
            componentType = "variable";
            componentName = xmlGetAttribute(child, "name");
            break;
          case "attribute-set":
            componentType = "attribute-set";
            componentName = xmlGetAttribute(child, "name");
            break;
          default:
            throw new Error(`<xsl:override> does not support <xsl:${localName}> elements.`);
        }
        if (!componentType) {
          continue;
        }
        let originalComponent;
        usedPkg.acceptedComponents.forEach((component) => {
          if (component.type !== componentType) {
            return;
          }
          if (componentName && component.name === componentName) {
            originalComponent = component;
          } else if (componentMatch && component.match === componentMatch) {
            originalComponent = component;
          }
        });
        if (!originalComponent) {
          usedPkg.package.components.forEach((component) => {
            if (component.type !== componentType) {
              return;
            }
            if (componentName && component.name === componentName) {
              originalComponent = component;
            } else if (componentMatch && component.match === componentMatch) {
              originalComponent = component;
            }
          });
        }
        if (!originalComponent) {
          const identifier = componentName || componentMatch || "unnamed";
          throw new Error(
            `Cannot override component "${identifier}" of type "${componentType}": component not found in package "${usedPkg.package.name}".`
          );
        }
        if (!canOverrideComponent(originalComponent)) {
          const identifier = componentName || componentMatch || "unnamed";
          throw new Error(
            `Cannot override component "${identifier}" of type "${componentType}": component is marked as "final" in package "${usedPkg.package.name}".`
          );
        }
        const overridingComponent = {
          type: componentType,
          name: componentName || void 0,
          match: componentMatch || void 0,
          mode: xmlGetAttribute(child, "mode") || void 0,
          visibility: originalComponent.visibility,
          // Inherit visibility from original
          overridable: false,
          // Overrides cannot themselves be overridden (unless explicitly marked)
          node: child,
          sourcePackage: this.currentPackage.name,
          isAccepted: false,
          effectiveVisibility: originalComponent.visibility
        };
        overridingComponent.originalComponent = originalComponent;
        overridingComponent.node.__originalComponent = originalComponent;
        const componentKey = makeComponentKey(originalComponent);
        this.currentPackage.overrides.set(componentKey, overridingComponent);
        if (componentType === "function") {
          this.xsltFunction(context, child);
        }
      }
    });
  }
  /**
   * Find components in a package matching the given criteria.
   * Used by xsl:accept to locate components from used packages.
   * 
   * @param pkg The package to search in
   * @param componentType The type of component to find
   * @param namePatterns Array of name patterns ('*' for all, or specific names)
   * @returns Array of matching components
   */
  findComponentsInPackage(pkg, componentType, namePatterns) {
    const results = [];
    const isWildcard = namePatterns.includes("*");
    pkg.components.forEach((component, key) => {
      if (component.type !== componentType) {
        return;
      }
      if (isWildcard) {
        results.push(component);
        return;
      }
      const componentName = this.getComponentNameForMatching(component);
      if (componentName && namePatterns.includes(componentName)) {
        results.push(component);
      }
    });
    return results;
  }
  /**
   * Get the name to use when matching components.
   * For named components (functions, variables, attribute-sets), returns the name.
   * For templates, returns the name if present, otherwise returns null (match-based templates).
   * 
   * @param component The component to get the name from
   * @returns The component name for matching, or null if unnamed
   */
  getComponentNameForMatching(component) {
    switch (component.type) {
      case "function":
      case "variable":
      case "attribute-set":
      case "mode":
        return component.name || null;
      case "template":
        return component.name || null;
      default:
        return null;
    }
  }
  /**
   * Implements <xsl:original> (XSLT 3.0 Section 3.7.2).
   * Calls the original component from within an override.
   */
  xsltOriginal(context, template, output) {
    return __async(this, null, function* () {
      if (!this.currentOverrideContext && this.currentTemplateStack.length > 0) {
        const currentTemplate = this.currentTemplateStack[this.currentTemplateStack.length - 1].template;
        const templateOverrideContext = currentTemplate.__originalComponent;
        if (templateOverrideContext) {
          this.currentOverrideContext = templateOverrideContext;
        }
      }
      if (!this.currentOverrideContext) {
        throw new Error("<xsl:original> can only be used within an overriding component.");
      }
      const originalComponent = this.currentOverrideContext;
      const originalNode = originalComponent.node;
      switch (originalComponent.type) {
        case "template":
          yield this.xsltChildNodes(context, originalNode, output);
          break;
        case "function":
          throw new Error("<xsl:original> for functions should be called as a function, not as an element.");
        case "variable":
          yield this.xsltVariable(context, originalNode, true);
          break;
        case "attribute-set":
          if (originalComponent.name && output) {
            yield this.applyAttributeSets(context, output, originalComponent.name);
          }
          break;
        default:
          throw new Error(`<xsl:original> does not support component type "${originalComponent.type}".`);
      }
    });
  }
  /**
   * Implements `<xsl:mode>` (XSLT 3.0 Section 3.5).
   * Declares a mode with visibility and other properties.
   * Only valid within an xsl:package.
   */
  xsltMode(context, template) {
    if (!this.currentPackage) {
      throw new Error("<xsl:mode> can only appear as a child of <xsl:package>.");
    }
    const name = xmlGetAttribute(template, "name");
    if (!name) {
      throw new Error('<xsl:mode> requires a "name" attribute.');
    }
    const visibility = xmlGetAttribute(template, "visibility") || "public";
    const streamableAttr = xmlGetAttribute(template, "streamable");
    const onNoMatch = xmlGetAttribute(template, "on-no-match");
    const onMultipleMatch = xmlGetAttribute(template, "on-multiple-match");
    const streamable = streamableAttr === "yes";
    if (!this.currentPackage.modes) {
      this.currentPackage.modes = /* @__PURE__ */ new Map();
    }
    const modeProperties = {
      name,
      visibility,
      streamable,
      onNoMatch,
      onMultipleMatch
    };
    this.currentPackage.modes.set(name, modeProperties);
    const componentKey = makeComponentKey({ type: "mode", name, visibility });
    if (!this.currentPackage.components.has(componentKey)) {
      this.currentPackage.components.set(componentKey, {
        type: "mode",
        name,
        visibility,
        overridable: false,
        node: template
      });
    }
  }
  /**
   * Get the effective component, checking for overrides first.
   * If the component has been overridden in the current package, returns the override.
   * Otherwise, returns the original component.
   * @param component The original component
   * @returns The effective component (override or original)
   */
  getEffectiveComponent(component) {
    if (!this.currentPackage) {
      return component;
    }
    const componentKey = makeComponentKey(component);
    const override = this.currentPackage.overrides.get(componentKey);
    return override || component;
  }
  /**
   * Collect templates from accepted components in used packages.
   * @param mode The mode to match (null for default mode)
   * @returns Array of template priority interfaces
   */
  collectAcceptedTemplates(mode) {
    const templates = [];
    if (!this.currentPackage) {
      return templates;
    }
    this.currentPackage.usedPackages.forEach((usedPkg, packageKey) => {
      usedPkg.acceptedComponents.forEach((component, componentKey) => {
        if (component.type === "template" && component.isAccepted) {
          const effectiveComponent = this.getEffectiveComponent(component);
          const templateNode = effectiveComponent.node;
          const isOverride = effectiveComponent !== component;
          const originalForContext = isOverride ? component : void 0;
          const templateMode = xmlGetAttribute(templateNode, "mode") || null;
          const effectiveMode = mode || null;
          if (effectiveMode !== templateMode) {
            return;
          }
          const match = xmlGetAttribute(templateNode, "match");
          if (!match) {
            return;
          }
          const priorityAttr = xmlGetAttribute(templateNode, "priority");
          const explicitPriority = priorityAttr ? parseFloat(priorityAttr) : null;
          const defaultPriority = component.priority || 0;
          const effectivePriority = explicitPriority !== null && !isNaN(explicitPriority) ? explicitPriority : defaultPriority;
          templates.push({
            template: templateNode,
            explicitPriority: explicitPriority !== null && !isNaN(explicitPriority) ? explicitPriority : null,
            defaultPriority,
            effectivePriority,
            importPrecedence: 0,
            // Accepted templates have neutral precedence
            documentOrder: 0,
            matchPattern: match,
            originalComponent: originalForContext
            // Store original for xsl:original support
          });
        }
      });
    });
    return templates;
  }
  /**
   * Implements `<xsl:stream>` (XSLT 3.0 Section 16).
   * Enables streaming processing of large documents.
   * @param context The Expression Context.
   * @param template The xsl:stream element.
   * @param output The output node.
   */
  xsltStream(context, template, output) {
    return __async(this, null, function* () {
      this.streamingProcessor.setVersion(this.version);
      const childProcessor = {
        processChildren: (ctx, tmpl, out) => this.xsltChildNodes(ctx, tmpl, out),
        isXsltElement: (node, name) => this.isXsltElement(node, name)
      };
      yield this.streamingProcessor.processStream(context, template, output, childProcessor);
    });
  }
  /**
   * Implements `<xsl:fork>` (XSLT 3.0 Section 17).
   * Creates multiple independent output branches from the input stream.
   * @param context The Expression Context.
   * @param template The xsl:fork element.
   * @param output The output node.
   */
  xsltFork(context, template, output) {
    return __async(this, null, function* () {
      const childProcessor = {
        processChildren: (ctx, tmpl, out) => this.xsltChildNodes(ctx, tmpl, out),
        isXsltElement: (node, name) => this.isXsltElement(node, name)
      };
      yield this.streamingProcessor.processFork(context, template, output, childProcessor);
    });
  }
  /**
   * Implements `<xsl:merge>` (XSLT 3.0 Section 15).
   * Merges multiple sorted input sequences.
   * @param context The Expression Context.
   * @param template The xsl:merge element.
   * @param output The output node.
   */
  xsltMerge(context, template, output) {
    return __async(this, null, function* () {
      this.streamingProcessor.setVersion(this.version);
      const childProcessor = {
        processChildren: (ctx, tmpl, out) => this.xsltChildNodes(ctx, tmpl, out),
        isXsltElement: (node, name) => this.isXsltElement(node, name)
      };
      yield this.streamingProcessor.processMerge(context, template, output, childProcessor);
    });
  }
  /**
   * Implements `xsl:key`.
   * @param context The Expression Context.
   * @param template The template.
   */
  xsltKey(context, template) {
    const name = xmlGetAttribute(template, "name");
    const match = xmlGetAttribute(template, "match");
    const use = xmlGetAttribute(template, "use");
    if (!name || !match || !use) {
      let errorMessage = "<xsl:key> missing required parameters: ";
      if (!name) {
        errorMessage += "name, ";
      }
      if (!match) {
        errorMessage += "match, ";
      }
      if (!use) {
        errorMessage += "use, ";
      }
      errorMessage = errorMessage.slice(0, -2);
      throw new Error(errorMessage);
    }
    let keyContext;
    if (context.nodeList[context.position].nodeName === "#document") {
      keyContext = context.clone(context.nodeList[context.position].childNodes);
    } else {
      keyContext = context;
    }
    const nodes = this.xsltMatch(match, keyContext);
    if (!(name in context.keys)) {
      context.keys[name] = {};
    }
    for (const node of nodes) {
      const nodeContext = context.clone([node]);
      const attribute = this.xPath.xPathEval(use, nodeContext);
      const attributeValue = attribute.stringValue();
      context.keys[name][attributeValue] = new NodeSetValue([node]);
    }
  }
  /**
   * Implements `xsl:message`.
   * Outputs a message to the console. If terminate="yes", throws an error to stop processing.
   * @param context The Expression Context.
   * @param template The `<xsl:message>` node.
   */
  xsltMessage(context, template) {
    return __async(this, null, function* () {
      const documentFragment = domCreateDocumentFragment(this.outputDocument);
      yield this.xsltChildNodes(context, template, documentFragment);
      const messageText = xmlValue(documentFragment);
      const terminate = xmlGetAttribute(template, "terminate") || "no";
      console.log(`[xsl:message] ${messageText}`);
      if (terminate === "yes") {
        throw new Error(`xsl:message terminated: ${messageText}`);
      }
    });
  }
  /**
   * Implements `xsl:namespace-alias`.
   * Declares that a namespace URI in the stylesheet should be replaced by a different
   * namespace URI in the output.
   * @param template The `<xsl:namespace-alias>` node.
   */
  xsltNamespaceAlias(template) {
    const stylesheetPrefix = xmlGetAttribute(template, "stylesheet-prefix");
    const resultPrefix = xmlGetAttribute(template, "result-prefix");
    if (!stylesheetPrefix || !resultPrefix) {
      throw new Error("<xsl:namespace-alias> requires both stylesheet-prefix and result-prefix attributes.");
    }
    this.namespaceAliases.set(stylesheetPrefix, resultPrefix);
  }
  /**
   * Implements `xsl:number`.
   * Inserts a formatted number into the result tree.
   * @param context The Expression Context.
   * @param template The `<xsl:number>` node.
   * @param output The output node.
   */
  xsltNumber(context, template, output) {
    const value = xmlGetAttribute(template, "value");
    const level = xmlGetAttribute(template, "level") || "single";
    const count = xmlGetAttribute(template, "count");
    const from = xmlGetAttribute(template, "from");
    const format = xmlGetAttribute(template, "format") || "1";
    const lang2 = xmlGetAttribute(template, "lang");
    const letterValue = xmlGetAttribute(template, "letter-value");
    const groupingSeparator = xmlGetAttribute(template, "grouping-separator");
    const groupingSize = xmlGetAttribute(template, "grouping-size");
    let numbers;
    if (value) {
      const result = this.xPath.xPathEval(value, context);
      numbers = [Math.round(result.numberValue())];
    } else {
      numbers = this.xsltNumberCount(context, level, count, from);
    }
    const formattedNumber = this.xsltFormatNumbers(numbers, format, groupingSeparator, groupingSize);
    const textNode = domCreateTextNode(this.outputDocument, formattedNumber);
    const targetOutput = output || this.outputDocument;
    textNode.siblingPosition = targetOutput.childNodes.length;
    domAppendChild(targetOutput, textNode);
  }
  /**
   * Counts nodes for xsl:number based on level, count, and from attributes.
   * @param context The Expression Context.
   * @param level The counting level: 'single', 'multiple', or 'any'.
   * @param count Pattern to match nodes to count.
   * @param from Pattern to define counting boundary.
   * @returns Array of count values (single element for 'single'/'any', multiple for 'multiple').
   */
  xsltNumberCount(context, level, count, from) {
    const currentNode = context.nodeList[context.position];
    const countPattern = count || currentNode.nodeName;
    switch (level) {
      case "single": {
        let node = currentNode;
        while (node) {
          if (this.nodeMatchesPattern(node, countPattern)) {
            let num = 1;
            let sibling = node.previousSibling;
            while (sibling) {
              if (this.nodeMatchesPattern(sibling, countPattern)) {
                num++;
              }
              sibling = sibling.previousSibling;
            }
            return [num];
          }
          if (from && this.nodeMatchesPattern(node, from)) {
            break;
          }
          node = node.parentNode;
        }
        return [0];
      }
      case "multiple": {
        const numbers = [];
        let node = currentNode;
        const matchingAncestors = [];
        while (node) {
          if (this.nodeMatchesPattern(node, countPattern)) {
            matchingAncestors.push(node);
          }
          if (from && this.nodeMatchesPattern(node, from)) {
            break;
          }
          node = node.parentNode;
        }
        for (let i = matchingAncestors.length - 1; i >= 0; i--) {
          const ancestor = matchingAncestors[i];
          let num = 1;
          let sibling = ancestor.previousSibling;
          while (sibling) {
            if (this.nodeMatchesPattern(sibling, countPattern)) {
              num++;
            }
            sibling = sibling.previousSibling;
          }
          numbers.push(num);
        }
        return numbers.length > 0 ? numbers : [0];
      }
      case "any": {
        let num = 0;
        const allNodes = this.getAllPrecedingNodes(currentNode, from);
        if (this.nodeMatchesPattern(currentNode, countPattern)) {
          num = 1;
        }
        for (const node of allNodes) {
          if (this.nodeMatchesPattern(node, countPattern)) {
            num++;
          }
        }
        return [num];
      }
      default:
        return [1];
    }
  }
  /**
   * Checks if a node matches a pattern (supports simple names and union patterns).
   * @param node The node to check.
   * @param pattern The pattern (node name, wildcard, or union like "a|b|c").
   * @returns True if the node matches.
   */
  nodeMatchesPattern(node, pattern) {
    if (pattern.includes("|")) {
      const alternatives = pattern.split("|").map((p) => p.trim());
      return alternatives.some((alt) => this.nodeMatchesSinglePattern(node, alt));
    }
    return this.nodeMatchesSinglePattern(node, pattern);
  }
  /**
   * Checks if a node matches a single (non-union) pattern.
   * @param node The node to check.
   * @param pattern The pattern (node name or wildcard).
   * @returns True if the node matches.
   */
  nodeMatchesSinglePattern(node, pattern) {
    if (pattern === "*") {
      return node.nodeType === DOM_ELEMENT_NODE;
    }
    if (pattern === "node()") {
      return true;
    }
    if (pattern === "text()") {
      return node.nodeType === DOM_TEXT_NODE;
    }
    if (pattern === "comment()") {
      return node.nodeType === DOM_COMMENT_NODE;
    }
    if (pattern.startsWith("processing-instruction")) {
      return node.nodeType === DOM_PROCESSING_INSTRUCTION_NODE;
    }
    return node.nodeName === pattern || node.localName === pattern;
  }
  /**
   * Gets all nodes preceding the given node in document order.
   * @param node The reference node.
   * @param fromPattern Optional pattern to define counting boundary.
   * @returns Array of preceding nodes.
   */
  getAllPrecedingNodes(node, fromPattern = null) {
    const result = [];
    let sibling = node.previousSibling;
    while (sibling) {
      if (fromPattern && this.nodeMatchesPattern(sibling, fromPattern)) {
        this.collectDescendants(sibling, result);
        return result;
      }
      result.push(sibling);
      this.collectDescendants(sibling, result);
      sibling = sibling.previousSibling;
    }
    let parent = node.parentNode;
    while (parent) {
      if (fromPattern && this.nodeMatchesPattern(parent, fromPattern)) {
        return result;
      }
      let parentSibling = parent.previousSibling;
      while (parentSibling) {
        if (fromPattern && this.nodeMatchesPattern(parentSibling, fromPattern)) {
          this.collectDescendants(parentSibling, result);
          return result;
        }
        result.push(parentSibling);
        this.collectDescendants(parentSibling, result);
        parentSibling = parentSibling.previousSibling;
      }
      parent = parent.parentNode;
    }
    return result;
  }
  /**
   * Collects all descendant nodes of a given node.
   * @param node The parent node.
   * @param result The array to collect into.
   */
  collectDescendants(node, result) {
    for (const child of node.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE) {
        result.push(child);
        this.collectDescendants(child, result);
      }
    }
  }
  /**
   * Formats an array of numbers according to the format string.
   * For level="multiple", numbers like [1, 2, 3] with format "1.1.1" produce "1.2.3".
   * @param numbers The numbers to format.
   * @param format The format string (e.g., "1", "1.1", "1.a.i").
   * @param groupingSeparator Optional grouping separator.
   * @param groupingSize Optional grouping size.
   * @returns The formatted number string.
   */
  xsltFormatNumbers(numbers, format, groupingSeparator, groupingSize) {
    if (numbers.length === 0) return "0";
    const { tokens, separators } = this.parseFormatString(format);
    const formattedParts = [];
    for (let i = 0; i < numbers.length; i++) {
      const tokenIndex = Math.min(i, tokens.length - 1);
      const token = tokens[tokenIndex] || "1";
      const formatted = this.xsltFormatNumber(numbers[i], token, groupingSeparator, groupingSize);
      formattedParts.push(formatted);
    }
    if (formattedParts.length === 1) {
      return formattedParts[0];
    }
    let result = formattedParts[0];
    for (let i = 1; i < formattedParts.length; i++) {
      const sepIndex = Math.min(i - 1, separators.length - 1);
      const sep = separators.length > 0 ? separators[sepIndex] : ".";
      result += sep + formattedParts[i];
    }
    return result;
  }
  /**
   * Parses a format string into tokens and separators.
   * E.g., "1.a.i" -> tokens: ["1", "a", "i"], separators: [".", "."]
   * @param format The format string.
   * @returns Object with tokens and separators arrays.
   */
  parseFormatString(format) {
    const tokens = [];
    const separators = [];
    const tokenRegex = /^(0*1|[aAiI])/;
    let remaining = format;
    let lastWasToken = false;
    while (remaining.length > 0) {
      const match = remaining.match(tokenRegex);
      if (match) {
        tokens.push(match[1]);
        remaining = remaining.substring(match[1].length);
        lastWasToken = true;
      } else {
        if (lastWasToken && tokens.length > 0) {
          let sepEnd = 1;
          while (sepEnd < remaining.length && !remaining.substring(sepEnd).match(tokenRegex)) {
            sepEnd++;
          }
          separators.push(remaining.substring(0, sepEnd));
          remaining = remaining.substring(sepEnd);
        } else {
          remaining = remaining.substring(1);
        }
        lastWasToken = false;
      }
    }
    if (tokens.length === 0) {
      tokens.push("1");
    }
    if (separators.length === 0 && tokens.length > 1) {
      for (let i = 1; i < tokens.length; i++) {
        separators.push(".");
      }
    }
    return { tokens, separators };
  }
  /**
   * Formats a number according to the format string.
   * @param number The number to format.
   * @param format The format string (e.g., "1", "01", "a", "A", "i", "I").
   * @param groupingSeparator Optional grouping separator.
   * @param groupingSize Optional grouping size.
   * @returns The formatted number string.
   */
  xsltFormatNumber(number, format, groupingSeparator, groupingSize) {
    const formatChar = format.charAt(0);
    let result;
    switch (formatChar) {
      case "1":
        result = number.toString();
        if (format.length > 1 && format.match(/^0+1$/)) {
          const width = format.length;
          result = number.toString().padStart(width, "0");
        }
        break;
      case "a":
        result = this.numberToAlpha(number, false);
        break;
      case "A":
        result = this.numberToAlpha(number, true);
        break;
      case "i":
        result = this.numberToRoman(number).toLowerCase();
        break;
      case "I":
        result = this.numberToRoman(number);
        break;
      default:
        result = number.toString();
    }
    if (groupingSeparator && groupingSize) {
      const size = parseInt(groupingSize, 10);
      if (size > 0 && !isNaN(size)) {
        result = this.applyGrouping(result, groupingSeparator, size);
      }
    }
    return result;
  }
  /**
   * Converts a number to alphabetic representation.
   * @param number The number to convert.
   * @param uppercase Whether to use uppercase letters.
   * @returns The alphabetic representation.
   */
  numberToAlpha(number, uppercase) {
    if (number <= 0) return "";
    let result = "";
    while (number > 0) {
      number--;
      result = String.fromCharCode(number % 26 + (uppercase ? 65 : 97)) + result;
      number = Math.floor(number / 26);
    }
    return result;
  }
  /**
   * Converts a number to Roman numeral representation.
   * @param number The number to convert.
   * @returns The Roman numeral string.
   */
  numberToRoman(number) {
    if (number <= 0 || number > 3999) return number.toString();
    const romanNumerals = [
      [1e3, "M"],
      [900, "CM"],
      [500, "D"],
      [400, "CD"],
      [100, "C"],
      [90, "XC"],
      [50, "L"],
      [40, "XL"],
      [10, "X"],
      [9, "IX"],
      [5, "V"],
      [4, "IV"],
      [1, "I"]
    ];
    let result = "";
    for (const [value, numeral] of romanNumerals) {
      while (number >= value) {
        result += numeral;
        number -= value;
      }
    }
    return result;
  }
  /**
   * Applies grouping separators to a numeric string.
   * @param numStr The numeric string.
   * @param separator The grouping separator.
   * @param size The grouping size.
   * @returns The grouped string.
   */
  applyGrouping(numStr, separator, size) {
    const parts = numStr.split(".");
    let intPart = parts[0];
    const decPart = parts[1];
    let result = "";
    let count = 0;
    for (let i = intPart.length - 1; i >= 0; i--) {
      if (count > 0 && count % size === 0) {
        result = separator + result;
      }
      result = intPart[i] + result;
      count++;
    }
    return decPart ? result + "." + decPart : result;
  }
  /**
   * Orders the current node list in the input context according to the
   * sort order specified by xsl:sort child nodes of the current
   * template node. This happens before the operation specified by the
   * current template node is executed.
   * @param context The expression context.
   * @param template The template node.
   * @todo case-order is not implemented.
   */
  xsltSort(context, template) {
    const sort2 = [];
    for (const childNode of template.childNodes) {
      if (childNode.nodeType == DOM_ELEMENT_NODE && this.isXsltElement(childNode, "sort")) {
        const select = xmlGetAttribute(childNode, "select");
        const expression = this.xPath.xPathParse(select);
        const type = xmlGetAttribute(childNode, "data-type") || "text";
        const order = xmlGetAttribute(childNode, "order") || "ascending";
        sort2.push({
          expr: expression,
          type,
          order
        });
      }
    }
    this.xPath.xPathSort(context, sort2);
  }
  /**
   * Implements `xsl:strip-space`.
   * Collects element name patterns for which whitespace-only text nodes should be stripped.
   * @param template The `<xsl:strip-space>` node.
   */
  xsltStripSpace(template) {
    const elements = xmlGetAttribute(template, "elements");
    if (elements) {
      const patterns = elements.trim().split(/\s+/);
      this.stripSpacePatterns.push(...patterns);
    }
  }
  /**
   * Implements `xsl:preserve-space`.
   * Collects element name patterns for which whitespace-only text nodes should be preserved.
   * preserve-space takes precedence over strip-space for matching elements.
   * @param template The `<xsl:preserve-space>` node.
   */
  xsltPreserveSpace(template) {
    const elements = xmlGetAttribute(template, "elements");
    if (elements) {
      const patterns = elements.trim().split(/\s+/);
      this.preserveSpacePatterns.push(...patterns);
    }
  }
  /**
   * Determines if a text node from the input document should be stripped.
   * This applies xsl:strip-space and xsl:preserve-space rules to whitespace-only text nodes.
   * @param textNode The text node to check.
   * @returns True if the text node should be stripped (not included in output).
   */
  shouldStripWhitespaceNode(textNode) {
    if (!textNode.nodeValue || !textNode.nodeValue.match(/^\s*$/)) {
      return false;
    }
    if (this.stripSpacePatterns.length === 0) {
      return false;
    }
    const parentElement = textNode.parentNode;
    if (!parentElement || parentElement.nodeType !== DOM_ELEMENT_NODE) {
      return false;
    }
    let ancestor = parentElement;
    while (ancestor && ancestor.nodeType === DOM_ELEMENT_NODE) {
      const xmlspace = domGetAttributeValue(ancestor, "xml:space");
      if (xmlspace === "preserve") {
        return false;
      }
      if (xmlspace === "default") {
        break;
      }
      ancestor = ancestor.parentNode;
    }
    const parentName = parentElement.localName || parentElement.nodeName;
    for (const pattern of this.preserveSpacePatterns) {
      if (this.matchesNamePattern(parentName, pattern, parentElement)) {
        return false;
      }
    }
    for (const pattern of this.stripSpacePatterns) {
      if (this.matchesNamePattern(parentName, pattern, parentElement)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Matches an element name against a strip-space/preserve-space pattern.
   * Supports:
   * - "*" matches any element
   * - "prefix:*" matches any element in a namespace
   * - "name" matches elements with that local name
   * - "prefix:name" matches elements with that QName
   * @param elementName The local name of the element.
   * @param pattern The pattern to match against.
   * @param element The element node (for namespace checking).
   * @returns True if the element matches the pattern.
   */
  matchesNamePattern(elementName, pattern, element) {
    if (pattern === "*") {
      return true;
    }
    if (pattern.includes(":")) {
      const [prefix, localPart] = pattern.split(":");
      const elementPrefix = element.prefix || "";
      if (localPart === "*") {
        return elementPrefix === prefix;
      } else {
        return elementPrefix === prefix && elementName === localPart;
      }
    }
    return elementName === pattern;
  }
  /**
   * Implements `xsl:template`.
   * @param context The Expression Context.
   * @param template The `<xsl:template>` node.
   * @param output The output. In general, a fragment that will be used by 
   *               the caller.
   */
  xsltTemplate(context, template, output) {
    return __async(this, null, function* () {
      if (!context.inApplyTemplates && context.baseTemplateMatched) {
        return;
      }
      const match = xmlGetAttribute(template, "match");
      if (!match) return;
      const nodes = this.xsltMatch(match, context, "self-and-siblings");
      if (nodes.length > 0) {
        this.firstTemplateRan = true;
        if (!context.inApplyTemplates) {
          context.baseTemplateMatched = true;
        }
        const templateContext = context.clone(nodes, 0);
        yield this.xsltChildNodes(templateContext, template, output);
      }
    });
  }
  xsltText(context, template, output) {
    const text = xmlValue(template);
    const node = domCreateTextNode(this.outputDocument, text);
    node.fromXslText = true;
    const disableOutputEscaping = template.childNodes.filter(
      (a) => a.nodeType === DOM_ATTRIBUTE_NODE && a.nodeName === "disable-output-escaping"
    );
    if (disableOutputEscaping.length > 0 && disableOutputEscaping[0].nodeValue === "yes") {
      node.escape = false;
    }
    const destinationTextNode = output || this.outputDocument;
    node.siblingPosition = destinationTextNode.childNodes.length;
    destinationTextNode.appendChild(node);
  }
  /**
   * Validates XSLT stylesheet/transform attributes.
   * According to XSLT specification, validates:
   * - Required version attribute
   * - Valid version values (1.0, 2.0, 3.0)
   * - Valid namespace declarations
   * - Valid values for optional attributes (extension-element-prefixes, exclude-result-prefixes)
   * @param stylesheetElement The `<xsl:stylesheet>` or `<xsl:transform>` element to validate.
   * @param context The Expression Context for namespace access.
   */
  validateStylesheetAttributes(stylesheetElement, context) {
    const attributes = stylesheetElement.childNodes.filter((n) => n.nodeType === DOM_ATTRIBUTE_NODE);
    const validAttributes = ["version", "id", "extension-element-prefixes", "exclude-result-prefixes", "default-collation"];
    const validNamespaceAttributes = ["xmlns"];
    let versionFound = false;
    for (let attribute of attributes) {
      const nodeName2 = attribute.nodeName;
      const nodeValue = attribute.nodeValue;
      if (attribute.prefix === "xmlns") {
        context.knownNamespaces[attribute.localName] = nodeValue;
        continue;
      }
      if (nodeName2 === "xmlns") {
        context.knownNamespaces[""] = nodeValue;
        continue;
      }
      if (nodeName2 === "version") {
        versionFound = true;
        const versionNum = parseFloat(nodeValue);
        if (isNaN(versionNum) || versionNum <= 0) {
          throw new Error(
            `XSLT version not defined or invalid. Actual resolved version: ${nodeValue || "(none)"}.`
          );
        }
        if (versionNum > 1 && !["2.0", "3.0"].includes(nodeValue)) {
          this.forwardsCompatible = true;
          this.version = nodeValue;
          context.xsltVersion = "1.0";
          this.warningsCallback(
            `XSLT Warning: Stylesheet version "${nodeValue}" is not directly supported. Entering forwards-compatible processing mode (XSLT 1.0 Section 2.5).`
          );
        } else {
          this.version = nodeValue;
          context.xsltVersion = nodeValue;
        }
        continue;
      }
      if (nodeName2 === "extension-element-prefixes") {
        const prefixes = nodeValue.split(/\s+/);
        for (const prefix of prefixes) {
          if (prefix && !/^[a-zA-Z_:][\w:.-]*$/.test(prefix)) {
            throw new Error(`Invalid prefix in extension-element-prefixes: "${prefix}". Prefixes must be valid QNames.`);
          }
        }
        continue;
      }
      if (nodeName2 === "exclude-result-prefixes") {
        if (nodeValue !== "#all") {
          const prefixes = nodeValue.split(/\s+/);
          for (const prefix of prefixes) {
            if (prefix && !/^[a-zA-Z_:][\w:.-]*$/.test(prefix)) {
              throw new Error(`Invalid prefix in exclude-result-prefixes: "${prefix}". Prefixes must be valid QNames or "#all".`);
            }
          }
        }
        continue;
      }
      if (nodeName2 === "default-collation") {
        if (!nodeValue || nodeValue.trim().length === 0) {
          throw new Error("The default-collation attribute must contain a URI.");
        }
        continue;
      }
      if (nodeName2 === "id") {
        if (!/^[a-zA-Z_:][\w:.-]*$/.test(nodeValue)) {
          throw new Error(`Invalid id attribute value: "${nodeValue}". IDs must be valid NCNames.`);
        }
        continue;
      }
    }
  }
  /**
   * Implements `<xsl:stylesheet>` and `<xsl:transform>`, and its corresponding
   * validations.
   * @param context The Expression Context.
   * @param template The `<xsl:stylesheet>` or `<xsl:transform>` node.
   * @param output The output. In general, a fragment that will be used by
   *               the caller.
   */
  xsltTransformOrStylesheet(context, template, output) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const mainStylesheetMetadata = {
        importDepth: 0,
        href: "(main stylesheet)",
        order: 0
      };
      this.mapTemplatesFromStylesheet(template, mainStylesheetMetadata);
      this.collectAttributeSets(template);
      this.collectUserDefinedFunctions(template, context);
      this.registerUserDefinedFunctionsInContext(context);
      this.validateStylesheetAttributes(template, context);
      let importsDone = false;
      for (const child of template.childNodes) {
        if (child.nodeType === DOM_ELEMENT_NODE) {
          if (this.isXsltElement(child, "import")) {
            if (importsDone) {
              throw new Error("<xsl:import> should be the first child node of <xsl:stylesheet> or <xsl:transform>.");
            }
          } else {
            importsDone = true;
          }
        }
      }
      const nonTemplates = [];
      const templates = [];
      for (const child of template.childNodes) {
        if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "template")) {
          templates.push(child);
        } else {
          nonTemplates.push(child);
        }
      }
      const contextClone = context.clone();
      for (const child of nonTemplates) {
        yield this.xsltProcessContext(contextClone, child, output);
      }
      if (templates.length > 0) {
        const expandedTemplates = collectAndExpandTemplates(template, null, this.xPath, this.templateSourceMap);
        const matchCandidates = [];
        for (const t of expandedTemplates) {
          try {
            const matchedNodes = this.xsltMatch(t.matchPattern, contextClone);
            if (matchedNodes.length > 0) {
              matchCandidates.push({ priority: t, matchedNodes });
            }
          } catch (e) {
            this.warningsCallback(`Failed to match pattern "${t.matchPattern}":`, e);
          }
        }
        if (matchCandidates.length > 0) {
          const rootPatternMatch = matchCandidates.find((c) => c.priority.matchPattern === "/");
          let winner;
          if (rootPatternMatch) {
            winner = rootPatternMatch;
          } else {
            matchCandidates.sort((a, b) => {
              if (a.priority.importPrecedence !== b.priority.importPrecedence) {
                return b.priority.importPrecedence - a.priority.importPrecedence;
              }
              if (a.priority.effectivePriority !== b.priority.effectivePriority) {
                return b.priority.effectivePriority - a.priority.effectivePriority;
              }
              return b.priority.documentOrder - a.priority.documentOrder;
            });
            winner = matchCandidates[0];
          }
          const conflicts = matchCandidates.filter(
            (t) => t.priority.importPrecedence === winner.priority.importPrecedence && t.priority.effectivePriority === winner.priority.effectivePriority
          );
          if (conflicts.length > 1) {
            const patterns = conflicts.map((t) => `"${t.priority.matchPattern}" (priority: ${t.priority.effectivePriority})`).join(", ");
            this.warningsCallback(
              `XSLT Warning: Ambiguous template match. Multiple templates match with equal priority: ${patterns}. Using the last one in document order.`
            );
          }
          this.firstTemplateRan = true;
          contextClone.baseTemplateMatched = true;
          const templateContext = contextClone.clone(winner.matchedNodes, 0);
          const metadata = this.templateSourceMap.get(winner.priority.template);
          const matchPattern = xmlGetAttribute(winner.priority.template, "match");
          const modeAttr = xmlGetAttribute(winner.priority.template, "mode");
          this.currentTemplateStack.push({
            template: winner.priority.template,
            stylesheetDepth: (_a = metadata == null ? void 0 : metadata.importDepth) != null ? _a : 0,
            mode: modeAttr || null,
            match: matchPattern
          });
          yield this.xsltChildNodes(templateContext, winner.priority.template, output);
          this.currentTemplateStack.pop();
        } else {
          const rootNode = context.nodeList[context.position];
          if (rootNode && rootNode.childNodes && rootNode.childNodes.length > 0) {
            const childNodes = rootNode.childNodes.filter((n) => n.nodeName !== "#dtd-section");
            if (childNodes.length > 0) {
              const childContext = context.clone(childNodes);
              for (let j = 0; j < childContext.contextSize(); ++j) {
                const currentNode = childContext.nodeList[j];
                if (currentNode.nodeType === DOM_TEXT_NODE) {
                  const textNodeContext = context.clone([currentNode], 0);
                  this.commonLogicTextNode(textNodeContext, currentNode, output);
                } else {
                  const clonedContext = childContext.clone([currentNode], 0);
                  const selection = selectBestTemplate(
                    expandedTemplates,
                    clonedContext,
                    this.matchResolver,
                    this.xPath,
                    this.warningsCallback
                  );
                  if (selection.selectedTemplate) {
                    const templateContext = clonedContext.clone([currentNode], 0);
                    templateContext.inApplyTemplates = true;
                    const metadata = this.templateSourceMap.get(selection.selectedTemplate);
                    const matchPattern = xmlGetAttribute(selection.selectedTemplate, "match");
                    const modeAttr = xmlGetAttribute(selection.selectedTemplate, "mode");
                    this.currentTemplateStack.push({
                      template: selection.selectedTemplate,
                      stylesheetDepth: (_b = metadata == null ? void 0 : metadata.importDepth) != null ? _b : 0,
                      mode: modeAttr || null,
                      match: matchPattern
                    });
                    yield this.xsltChildNodes(templateContext, selection.selectedTemplate, output);
                    this.currentTemplateStack.pop();
                  } else {
                    if (currentNode.childNodes && currentNode.childNodes.length > 0) {
                      const grandchildNodes = currentNode.childNodes.filter((n) => n.nodeName !== "#dtd-section");
                      if (grandchildNodes.length > 0) {
                        const grandchildContext = context.clone(grandchildNodes);
                        for (let k = 0; k < grandchildContext.contextSize(); ++k) {
                          const grandchildNode = grandchildContext.nodeList[k];
                          if (grandchildNode.nodeType === DOM_TEXT_NODE) {
                            const textNodeContext = context.clone([grandchildNode], 0);
                            this.commonLogicTextNode(textNodeContext, grandchildNode, output);
                          } else {
                            const grandchildClonedContext = grandchildContext.clone([grandchildNode], 0);
                            const grandchildSelection = selectBestTemplate(
                              expandedTemplates,
                              grandchildClonedContext,
                              this.matchResolver,
                              this.xPath,
                              this.warningsCallback
                            );
                            if (grandchildSelection.selectedTemplate) {
                              const grandchildTemplateContext = grandchildClonedContext.clone([grandchildNode], 0);
                              grandchildTemplateContext.inApplyTemplates = true;
                              const metadata = this.templateSourceMap.get(grandchildSelection.selectedTemplate);
                              const matchPattern = xmlGetAttribute(grandchildSelection.selectedTemplate, "match");
                              const modeAttr = xmlGetAttribute(grandchildSelection.selectedTemplate, "mode");
                              this.currentTemplateStack.push({
                                template: grandchildSelection.selectedTemplate,
                                stylesheetDepth: (_c = metadata == null ? void 0 : metadata.importDepth) != null ? _c : 0,
                                mode: modeAttr || null,
                                match: matchPattern
                              });
                              yield this.xsltChildNodes(grandchildTemplateContext, grandchildSelection.selectedTemplate, output);
                              this.currentTemplateStack.pop();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });
  }
  xsltValueOf(context, template, output) {
    const select = xmlGetAttribute(template, "select");
    const current = context.nodeList[context.position];
    let attribute = this.xPath.xPathEval(select, context);
    if (current && current.nodeName === "#document" && (attribute.stringValue() === "" || attribute instanceof NodeSetValue && attribute.nodeSetValue().length === 0)) {
      const docChild = current.childNodes.find((c) => c.nodeName !== "#dtd-section");
      if (docChild) {
        const fallbackContext = context.clone([docChild], 0);
        attribute = this.xPath.xPathEval(select, fallbackContext);
      }
    }
    const value = attribute.stringValue();
    const node = domCreateTextNode(this.outputDocument, value);
    const targetOutput = output || this.outputDocument;
    node.siblingPosition = targetOutput.childNodes.length;
    targetOutput.appendChild(node);
  }
  /**
   * Implements `xsl:sequence` (XSLT 2.0).
   *
   * Constructs a sequence by evaluating the select expression or processing
   * child content. Unlike xsl:copy-of, xsl:sequence returns nodes by reference
   * and can return atomic values.
   *
   * @param context The expression context.
   * @param template The xsl:sequence element.
   * @param output The output node.
   */
  xsltSequence(context, template, output) {
    return __async(this, null, function* () {
      const select = xmlGetAttribute(template, "select");
      const destinationNode = output || this.outputDocument;
      if (select) {
        const result = this.xPath.xPathEval(select, context);
        if (result.type === "node-set") {
          const nodes = result.nodeSetValue();
          for (const node of nodes) {
            this.xsltCopyOf(destinationNode, node);
          }
        } else {
          const textNode = domCreateTextNode(this.outputDocument, result.stringValue());
          textNode.siblingPosition = destinationNode.childNodes.length;
          domAppendChild(destinationNode, textNode);
        }
      } else {
        yield this.xsltChildNodes(context, template, output);
      }
    });
  }
  /**
   * Implements `xsl:analyze-string` (XSLT 2.0).
   *
   * Processes a string using a regular expression, with separate handling
   * for matching and non-matching substrings.
   *
   * @param context The expression context.
   * @param template The xsl:analyze-string element.
   * @param output The output node.
   */
  xsltAnalyzeString(context, template, output) {
    return __async(this, null, function* () {
      const selectAttr = xmlGetAttribute(template, "select");
      const regexAttr = xmlGetAttribute(template, "regex");
      const flagsAttr = xmlGetAttribute(template, "flags") || "";
      if (!selectAttr) {
        throw new Error("<xsl:analyze-string> requires a select attribute.");
      }
      if (!regexAttr) {
        throw new Error("<xsl:analyze-string> requires a regex attribute.");
      }
      const inputValue = this.xPath.xPathEval(selectAttr, context);
      const inputString = inputValue.stringValue();
      let matchingSubstring = null;
      let nonMatchingSubstring = null;
      for (const child of template.childNodes) {
        if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child)) {
          if (child.localName === "matching-substring") {
            matchingSubstring = child;
          } else if (child.localName === "non-matching-substring") {
            nonMatchingSubstring = child;
          } else if (child.localName === "fallback") {
            continue;
          }
        }
      }
      let jsFlags = "g";
      for (const flag of flagsAttr) {
        switch (flag) {
          case "i":
            jsFlags += "i";
            break;
          case "m":
            jsFlags += "m";
            break;
          case "s":
            jsFlags += "s";
            break;
        }
      }
      let regex;
      try {
        regex = new RegExp(regexAttr, jsFlags);
      } catch (e) {
        throw new Error(`Invalid regular expression in xsl:analyze-string: ${regexAttr}`);
      }
      let lastIndex = 0;
      let match;
      while ((match = regex.exec(inputString)) !== null) {
        const matchStart = match.index;
        const matchEnd = matchStart + match[0].length;
        if (matchStart > lastIndex && nonMatchingSubstring) {
          const nonMatchText = inputString.substring(lastIndex, matchStart);
          yield this.processAnalyzeStringContent(context, nonMatchingSubstring, output, nonMatchText, null);
        }
        if (matchingSubstring) {
          const groups = match.slice(0);
          yield this.processAnalyzeStringContent(context, matchingSubstring, output, match[0], groups);
        }
        lastIndex = matchEnd;
        if (match[0].length === 0) {
          regex.lastIndex++;
        }
      }
      if (lastIndex < inputString.length && nonMatchingSubstring) {
        const nonMatchText = inputString.substring(lastIndex);
        yield this.processAnalyzeStringContent(context, nonMatchingSubstring, output, nonMatchText, null);
      }
    });
  }
  /**
   * Helper method to process xsl:matching-substring or xsl:non-matching-substring content.
   * Sets up the context with the current text and regex groups.
   */
  processAnalyzeStringContent(context, template, output, currentText, regexGroups) {
    return __async(this, null, function* () {
      const textNode = domCreateTextNode(this.outputDocument, currentText);
      const childContext = context.clone([textNode], 0);
      if (regexGroups) {
        childContext.regexGroups = regexGroups;
      }
      yield this.xsltChildNodes(childContext, template, output);
    });
  }
  /**
   * Implements `xsl:function` (XSLT 2.0).
   * 
   * Declares a stylesheet function that can be called from XPath expressions.
   * Functions are collected during stylesheet initialization and made available
   * to the XPath evaluator.
   *
   * @param context The expression context.
   * @param template The xsl:function element.
   */
  xsltFunction(context, template) {
    const name = xmlGetAttribute(template, "name");
    const asAttr = xmlGetAttribute(template, "as");
    const overrideAttr = xmlGetAttribute(template, "override");
    if (!name) {
      throw new Error('<xsl:function> requires a "name" attribute.');
    }
    if (!name.includes(":")) {
      throw new Error(`<xsl:function> name "${name}" must be in a namespace (use a prefixed name like "my:functionName").`);
    }
    const override = overrideAttr === "yes" || overrideAttr === "true";
    if (this.userDefinedFunctions.has(name) && !override) {
      return;
    }
    this.userDefinedFunctions.set(name, template);
  }
  /**
   * Coerce a NodeValue to a specific type based on the 'as' attribute.
   * 
   * @param value The value to coerce.
   * @param type The target type (e.g., "xs:integer", "xs:string", "xs:boolean").
   * @returns The coerced value.
   */
  coerceToType(value, type) {
    const normalizedType = type.replace(/^xs:/, "").toLowerCase();
    switch (normalizedType) {
      case "integer":
      case "int":
      case "double":
      case "decimal":
      case "number":
        return new NumberValue(value.numberValue());
      case "string":
        return new StringValue(value.stringValue());
      case "boolean":
        return new BooleanValue(value.booleanValue());
      default:
        return value;
    }
  }
  /**
   * Execute a user-defined xsl:function.
   * Called when a function from userDefinedFunctions is invoked from XPath.
   *
   * @param context The expression context.
   * @param functionDef The xsl:function node.
   * @param args The evaluated arguments passed to the function.
   * @returns The result of the function execution.
   */
  executeUserDefinedFunction(context, functionDef, args) {
    return __async(this, null, function* () {
      return this.executeUserDefinedFunctionSync(context, functionDef, args);
    });
  }
  /**
   * Synchronously execute a user-defined xsl:function.
   * This is used when functions are called from XPath expressions.
   * Limited to functions that don't require async operations in their body.
   *
   * @param context The expression context.
   * @param functionDef The xsl:function node.
   * @param args The evaluated arguments passed to the function.
   * @returns The result of the function execution.
   */
  executeUserDefinedFunctionSync(context, functionDef, args) {
    const functionContext = context.clone();
    functionContext.variables = __spreadValues({}, context.variables);
    const params = [];
    for (const child of functionDef.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "param")) {
        params.push(child);
      }
    }
    for (let i = 0; i < params.length; i++) {
      const paramName = xmlGetAttribute(params[i], "name");
      if (paramName) {
        if (i < args.length) {
          let argValue = args[i];
          const paramType = xmlGetAttribute(params[i], "as");
          let paramValue;
          if (argValue && typeof argValue === "object" && "stringValue" in argValue) {
            paramValue = argValue;
            if (paramType) {
              paramValue = this.coerceToType(paramValue, paramType);
            }
          } else if (argValue && typeof argValue === "object" && "nodeType" in argValue) {
            paramValue = new NodeSetValue([argValue]);
            if (paramType) {
              paramValue = this.coerceToType(paramValue, paramType);
            }
          } else if (Array.isArray(argValue)) {
            paramValue = new NodeSetValue(argValue);
            if (paramType) {
              paramValue = this.coerceToType(paramValue, paramType);
            }
          } else if (typeof argValue === "number") {
            paramValue = new NumberValue(argValue);
          } else if (typeof argValue === "boolean") {
            paramValue = new BooleanValue(argValue);
          } else {
            paramValue = new StringValue(String(argValue != null ? argValue : ""));
          }
          functionContext.setVariable(paramName, paramValue);
        } else {
          const selectExpr = xmlGetAttribute(params[i], "select");
          if (selectExpr) {
            const defaultValue = this.xPath.xPathEval(selectExpr, functionContext);
            functionContext.setVariable(paramName, defaultValue);
          } else {
            functionContext.setVariable(paramName, new StringValue(""));
          }
        }
      }
    }
    for (const child of functionDef.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE) {
        if (this.isXsltElement(child, "sequence")) {
          const select = xmlGetAttribute(child, "select");
          if (select) {
            const result = this.xPath.xPathEval(select, functionContext);
            if (result.type === "number") {
              return result.numberValue();
            } else if (result.type === "boolean") {
              return result.booleanValue();
            } else if (result.type === "node-set") {
              return result.nodeSetValue();
            } else {
              return result.stringValue();
            }
          }
        } else if (this.isXsltElement(child, "value-of")) {
          const select = xmlGetAttribute(child, "select");
          if (select) {
            return this.xPath.xPathEval(select, functionContext).stringValue();
          }
        }
      }
    }
    return "";
  }
  /**
   * Implements `xsl:result-document` (XSLT 2.0).
   *
   * Creates a secondary output document. The output is stored in the
   * resultDocuments map, accessible via getResultDocuments().
   *
   * @param context The expression context.
   * @param template The xsl:result-document element.
   */
  xsltResultDocument(context, template) {
    return __async(this, null, function* () {
      const hrefExpr = xmlGetAttribute(template, "href") || "";
      const methodAttr = xmlGetAttribute(template, "method") || this.outputMethod || "xml";
      const omitXmlDeclaration = xmlGetAttribute(template, "omit-xml-declaration") || this.outputOmitXmlDeclaration;
      const href = this.xsltAttributeValue(hrefExpr, context);
      if (!href) {
        throw new Error('<xsl:result-document> requires a non-empty "href" attribute.');
      }
      if (this.resultDocuments.has(href)) {
        throw new Error(`<xsl:result-document>: A document has already been created with href="${href}".`);
      }
      const resultDocument = new XDocument();
      yield this.xsltChildNodes(context, template, resultDocument);
      const serialized = xmlTransformedText(resultDocument, {
        cData: this.options.cData,
        escape: this.options.escape,
        selfClosingTags: this.options.selfClosingTags,
        outputMethod: methodAttr,
        outputVersion: this.outputVersion,
        itemSeparator: this.itemSeparator
      });
      this.resultDocuments.set(href, serialized);
    });
  }
  /**
   * Get all result documents created by xsl:result-document.
   * @returns A map of href URIs to serialized output strings.
   */
  getResultDocuments() {
    return this.resultDocuments;
  }
  /**
   * Sets the package loader callback.
   * The callback is called when a package is referenced via xsl:use-package
   * but is not found in the registry.
   * 
   * @param loader A function that loads package documents by URI and optional version.
   *               Returns the parsed package document, or null if not found.
   */
  setPackageLoader(loader) {
    this.packageLoader = loader;
  }
  /**
   * Pre-registers a package for use in transformations.
   * The package is parsed and stored in the internal registry.
   * 
   * @param name The package name/URI.
   * @param packageDoc The parsed package document.
   * @param version Optional semantic version string.
   */
  registerPackage(name, packageDoc, version) {
    return __async(this, null, function* () {
      yield this.loadAndRegisterPackage(name, packageDoc, version);
    });
  }
  /**
   * Implements `xsl:perform-sort` (XSLT 2.0).
   *
   * Sorts a sequence of items without iteration. The sorted sequence
   * is available via xsl:sequence or other sequence-consuming instructions.
   *
   * @param context The expression context.
   * @param template The xsl:perform-sort element.
   * @param output The output node.
   */
  xsltPerformSort(context, template, output) {
    return __async(this, null, function* () {
      const select = xmlGetAttribute(template, "select");
      let items;
      if (select) {
        items = this.xPath.xPathEval(select, context).nodeSetValue();
      } else {
        const sequenceChildren = [];
        for (const child of template.childNodes) {
          if (child.nodeType === DOM_ELEMENT_NODE && !this.isXsltElement(child, "sort")) {
            sequenceChildren.push(child);
          }
        }
        const fragment = domCreateDocumentFragment(this.outputDocument);
        for (const child of sequenceChildren) {
          yield this.xsltProcessContext(context, child, fragment);
        }
        items = Array.from(fragment.childNodes);
      }
      if (items.length === 0) {
        return;
      }
      const sortContext = context.clone(items);
      this.xsltSort(sortContext, template);
      const destinationNode = output || this.outputDocument;
      for (const node of sortContext.nodeList) {
        this.xsltCopyOf(destinationNode, node);
      }
    });
  }
  /**
   * Implements `xsl:namespace` (XSLT 2.0).
   *
   * Creates a namespace node in the result tree.
   *
   * @param context The expression context.
   * @param template The xsl:namespace element.
   * @param output The output node.
   */
  xsltNamespace(context, template, output) {
    return __async(this, null, function* () {
      const nameExpr = xmlGetAttribute(template, "name");
      const selectExpr = xmlGetAttribute(template, "select");
      if (!nameExpr && nameExpr !== "") {
        throw new Error('<xsl:namespace> requires a "name" attribute.');
      }
      const prefix = this.xsltAttributeValue(nameExpr, context);
      let namespaceUri;
      if (selectExpr) {
        namespaceUri = this.xPath.xPathEval(selectExpr, context).stringValue();
      } else {
        const fragment = domCreateDocumentFragment(this.outputDocument);
        yield this.xsltChildNodes(context, template, fragment);
        namespaceUri = xmlValue(fragment);
      }
      if (!namespaceUri) {
        throw new Error("<xsl:namespace> requires a non-empty namespace URI.");
      }
      const destinationNode = output || this.outputDocument;
      if (destinationNode.nodeType === DOM_ELEMENT_NODE) {
        if (prefix) {
          domSetAttribute(destinationNode, `xmlns:${prefix}`, namespaceUri);
        } else {
          domSetAttribute(destinationNode, "xmlns", namespaceUri);
        }
      }
    });
  }
  /**
   * Evaluates a variable or parameter and set it in the current input
   * context. Implements `xsl:variable`, `xsl:param`, and `xsl:with-param`.
   *
   * @param context The expression context.
   * @param template The template node.
   * @param override flag that defines if the value computed here
   * overrides the one already in the input context if that is the
   * case. I.e. decides if this is a default value or a local
   * value. `xsl:variable` and `xsl:with-param` override; `xsl:param` doesn't.
   */
  xsltVariable(context, template, override) {
    return __async(this, null, function* () {
      const name = xmlGetAttribute(template, "name");
      const select = xmlGetAttribute(template, "select");
      let value;
      const nonAttributeChildren = template.childNodes.filter((n) => n.nodeType !== DOM_ATTRIBUTE_NODE);
      if (nonAttributeChildren.length > 0) {
        const fragment = domCreateDocumentFragment(template.ownerDocument);
        yield this.xsltChildNodes(context, template, fragment);
        value = new NodeSetValue([fragment]);
      } else if (select) {
        value = this.xPath.xPathEval(select, context);
      } else {
        let parameterValue = "";
        const filteredParameter = this.options.parameters.filter((p) => p.name === name);
        if (filteredParameter.length > 0) {
          parameterValue = filteredParameter[0].value;
        }
        value = new StringValue(parameterValue);
      }
      if (override || !context.getVariable(name)) {
        context.setVariable(name, value);
      }
    });
  }
  /**
   * Register accepted variables from used packages into the context.
   * Called after processing package use-package declarations.
   * @param context The expression context.
   */
  registerAcceptedVariables(context) {
    return __async(this, null, function* () {
      if (!this.currentPackage) {
        return;
      }
      this.currentPackage.usedPackages.forEach((usedPkg, packageKey) => {
        usedPkg.acceptedComponents.forEach((component, componentKey) => {
          if (component.type === "variable" && component.name && component.isAccepted) {
            this.xsltVariable(context, component.node, false);
          }
        });
      });
    });
  }
  /**
   * Traverses the template node tree. Calls the main processing
   * function with the current input context for every child node of the
   * current template node.
   * @param context Normally the Expression Context.
   * @param template The XSL-T definition.
   * @param output If set, the output where the transformation should occur.
   */
  xsltChildNodes(context, template, output) {
    return __async(this, null, function* () {
      const contextClone = context.clone();
      for (let i = 0; i < template.childNodes.length; ++i) {
        const child = template.childNodes[i];
        if (child.nodeType === DOM_ATTRIBUTE_NODE) {
          continue;
        }
        yield this.xsltProcessContext(contextClone, child, output);
      }
    });
  }
  /**
   * Processes child nodes while skipping xsl:on-empty and xsl:on-non-empty.
   * Used by instructions that handle these conditionals explicitly.
   */
  xsltChildNodesExcludingConditional(context, template, output) {
    return __async(this, null, function* () {
      const contextClone = context.clone();
      for (let i = 0; i < template.childNodes.length; ++i) {
        const child = template.childNodes[i];
        if (child.nodeType === DOM_ATTRIBUTE_NODE) {
          continue;
        }
        if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child) && (child.localName === "on-empty" || child.localName === "on-non-empty")) {
          continue;
        }
        yield this.xsltProcessContext(contextClone, child, output);
      }
    });
  }
  findConditionalChild(template, localName) {
    for (const child of template.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, localName)) {
        return child;
      }
    }
    return null;
  }
  /**
   * This logic is used in two different places:
   * - `xsltPassThrough`, if the template asks this library to write a text node;
   * - `xsltProcessContext`, `apply-templates` operation, when the current node is text.
   * 
   * Text nodes always require a parent, and they never have children.
   * @param context The Expression Context.
   * @param template The template, that contains the node value to be written.
   * @param output The output.
   */
  commonLogicTextNode(context, template, output) {
    if (output) {
      if (this.shouldStripWhitespaceNode(template)) {
        return;
      }
      let textValue = template.nodeValue;
      if (this.version && parseFloat(this.version) >= 3) {
        textValue = this.xsltTextValueTemplate(textValue, context);
      }
      let node = domCreateTextNode(this.outputDocument, textValue);
      node.siblingPosition = output.childNodes.length;
      domAppendChild(output, node);
    }
  }
  /**
   * Passes template text to the output. The current template node does
   * not specify an XSL-T operation and therefore is appended to the
   * output with all its attributes. Then continues traversing the
   * template node tree.
   * @param context The Expression Context.
   * @param template The XSLT stylesheet or transformation.
   * @param output The output.
   */
  xsltPassThrough(context, template, output) {
    return __async(this, null, function* () {
      switch (template.nodeType) {
        case DOM_TEXT_NODE:
          if (this.xsltPassText(template)) {
            this.commonLogicTextNode(context, template, output);
          }
          break;
        case DOM_ELEMENT_NODE:
          let node;
          let elementContext = context;
          node = context.nodeList[context.position];
          let newNode;
          newNode = domCreateElement(this.outputDocument, template.nodeName);
          newNode.siblingPosition = (output || this.outputDocument).childNodes.length;
          domAppendChild(output || this.outputDocument, newNode);
          const useAttributeSetsAttr = template.childNodes.find(
            (a) => (a == null ? void 0 : a.nodeType) === DOM_ATTRIBUTE_NODE && a.nodeName === "use-attribute-sets"
          );
          if (useAttributeSetsAttr) {
            yield this.applyAttributeSets(elementContext, newNode, useAttributeSetsAttr.nodeValue);
          }
          yield this.xsltChildNodes(elementContext, template, newNode);
          const templateAttributes = template.childNodes.filter(
            (a) => (a == null ? void 0 : a.nodeType) === DOM_ATTRIBUTE_NODE && a.nodeName !== "use-attribute-sets"
          );
          for (const attribute of templateAttributes) {
            const name = attribute.nodeName;
            const value = this.xsltAttributeValue(attribute.nodeValue, elementContext);
            domSetAttribute(newNode, name, value);
          }
          break;
        default:
          yield this.xsltChildNodes(context, template, output);
      }
    });
  }
  /**
   * Determines if a text node in the XSLT template document is to be
   * stripped according to XSLT whitespace stripping rules.
   * @see [XSLT], section 3.4.
   * @param template The XSLT template.
   * @returns TODO
   * @todo Whitespace stripping on the input document is
   * currently not implemented.
   */
  xsltPassText(template) {
    if (!template.nodeValue.match(/^\s*$/)) {
      return true;
    }
    let element = template.parentNode;
    if (this.isXsltElement(element, "text")) {
      return true;
    }
    while (element && element.nodeType == DOM_ELEMENT_NODE) {
      const xmlspace = domGetAttributeValue(element, "xml:space");
      if (xmlspace) {
        if (xmlspace == "default") {
          return false;
        }
        if (xmlspace == "preserve") {
          return true;
        }
      }
      element = element.parentNode;
    }
    return false;
  }
  findAttributeInContext(attributeName, context) {
    return context.nodeList[context.position].childNodes.find(
      (a) => a.nodeType === DOM_ATTRIBUTE_NODE && a.nodeName === attributeName
    );
  }
  /**
   * Evaluates an XSL-T attribute value template. Attribute value
   * templates are attributes on XSL-T elements that contain XPath
   * expressions in braces {}. The XSL-T expressions are evaluated in
   * the current input context.
   * @param value TODO
   * @param context TODO
   * @returns TODO
   */
  xsltAttributeValue(value, context) {
    const parts = value.split("{");
    if (parts.length === 1) {
      return value;
    }
    let ret = "";
    for (let i = 0; i < parts.length; ++i) {
      const rp = parts[i].split("}");
      if (rp.length != 2) {
        ret += parts[i];
        continue;
      }
      const val = this.xPath.xPathEval(rp[0], context).stringValue();
      ret += val + rp[1];
    }
    return ret;
  }
  /**
   * Evaluates text value templates in XSLT 3.0. Text value templates
   * allow XPath expressions in braces {} within text nodes.
   * The expressions are evaluated in the current input context.
   * To include a literal brace, use {{ or }}.
   * @param value The text node value to process
   * @param context The expression context
   * @returns The processed text with expressions evaluated
   */
  xsltTextValueTemplate(value, context) {
    if (!value) {
      return value;
    }
    let result = "";
    let i = 0;
    while (i < value.length) {
      const char = value[i];
      if (char === "{") {
        if (i + 1 < value.length && value[i + 1] === "{") {
          result += "{";
          i += 2;
          continue;
        }
        let depth = 1;
        let j = i + 1;
        let expr = "";
        while (j < value.length && depth > 0) {
          if (value[j] === "{") {
            depth++;
          } else if (value[j] === "}") {
            depth--;
            if (depth === 0) {
              break;
            }
          }
          expr += value[j];
          j++;
        }
        if (depth === 0) {
          try {
            const val = this.xPath.xPathEval(expr, context).stringValue();
            result += val;
          } catch (e) {
            throw new Error(`Error evaluating text value template expression "${expr}": ${e.message}`);
          }
          i = j + 1;
        } else {
          result += char;
          i++;
        }
      } else if (char === "}") {
        if (i + 1 < value.length && value[i + 1] === "}") {
          result += "}";
          i += 2;
          continue;
        }
        result += char;
        i++;
      } else {
        result += char;
        i++;
      }
    }
    return result;
  }
  /**
   * Evaluates an XPath expression in the current input context as a
   * match.
   * @see [XSLT] section 5.2, paragraph 1
   * @param match TODO
   * @param context The Expression Context.
   * @param axis The XPath axis. Used when the match does not start with the parent.
   * @returns {XNode[]} A list of the found nodes.
   */
  xsltMatch(match, context, axis) {
    const expression = this.xPath.xPathParse(match, axis);
    return this.matchResolver.expressionMatch(expression, context);
  }
  /**
   * Sets parameters defined by xsl:with-param child nodes of the
   * current template node, in the current input context. This happens
   * before the operation specified by the current template node is
   * executed.
   * @param context The Expression Context.
   * @param template The template node.
   */
  xsltWithParam(context, template) {
    return __async(this, null, function* () {
      for (const childNode of template.childNodes) {
        if (childNode.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(childNode, "with-param")) {
          yield this.xsltVariable(context, childNode, true);
        }
      }
    });
  }
  /**
   * Recursively map all template nodes in a stylesheet to their metadata.
   * Used to track which stylesheet each template comes from for apply-imports.
   * @param stylesheetElement The stylesheet or transform element (or any parent element).
   * @param metadata The metadata for this stylesheet.
   */
  mapTemplatesFromStylesheet(stylesheetElement, metadata) {
    for (const child of stylesheetElement.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE) {
        if (this.isXsltElement(child, "template")) {
          this.templateSourceMap.set(child, metadata);
        } else if (this.isXsltElement(child, "stylesheet") || this.isXsltElement(child, "transform") || this.isXsltElement(child, "package")) {
          this.mapTemplatesFromStylesheet(child, metadata);
        }
      }
    }
  }
  /**
   * Collect all attribute set definitions from the stylesheet.
   * Called at stylesheet initialization time.
   * @param stylesheetElement The stylesheet or transform element.
   */
  collectAttributeSets(stylesheetElement) {
    for (const child of stylesheetElement.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "attribute-set")) {
        const name = xmlGetAttribute(child, "name");
        const attributes = child.childNodes.filter(
          (n) => n.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(n, "attribute")
        );
        if (name) {
          const existing = this.attributeSets.get(name);
          if (existing && existing.length) {
            this.attributeSets.set(name, [...existing, ...attributes]);
          } else {
            this.attributeSets.set(name, attributes);
          }
        }
      }
    }
  }
  /**
   * Collect all user-defined function definitions from the stylesheet.
   * Called at stylesheet initialization time.
   * @param stylesheetElement The stylesheet or transform element.
   * @param context The expression context.
   */
  collectUserDefinedFunctions(stylesheetElement, context) {
    for (const child of stylesheetElement.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "function")) {
        this.xsltFunction(context, child);
      }
    }
  }
  /**
   * Register user-defined functions in the expression context.
   * This makes them available to XPath expressions.
   * @param context The expression context.
   */
  registerUserDefinedFunctionsInContext(context) {
    if (this.userDefinedFunctions.size === 0 && !this.hasAcceptedFunctions()) {
      return;
    }
    const functionsMap = /* @__PURE__ */ new Map();
    this.userDefinedFunctions.forEach((functionDef, name) => {
      functionsMap.set(name, {
        functionDef,
        executor: (ctx, funcDef, args) => {
          return this.executeUserDefinedFunctionSync(ctx, funcDef, args);
        }
      });
    });
    this.registerAcceptedFunctions(functionsMap);
    context.userDefinedFunctions = functionsMap;
  }
  /**
   * Check if there are any accepted functions in used packages.
   */
  hasAcceptedFunctions() {
    if (!this.currentPackage) {
      return false;
    }
    let hasAccepted = false;
    this.currentPackage.usedPackages.forEach((usedPkg) => {
      usedPkg.acceptedComponents.forEach((component) => {
        if (component.type === "function" && component.isAccepted) {
          hasAccepted = true;
        }
      });
    });
    return hasAccepted;
  }
  /**
   * Register accepted functions from used packages.
   * @param functionsMap The map to register functions into.
   */
  registerAcceptedFunctions(functionsMap) {
    if (!this.currentPackage) {
      return;
    }
    this.currentPackage.usedPackages.forEach((usedPkg, packageKey) => {
      usedPkg.acceptedComponents.forEach((component, componentKey) => {
        if (component.type === "function" && component.name && component.isAccepted) {
          const effectiveComponent = this.getEffectiveComponent(component);
          functionsMap.set(component.name, {
            functionDef: effectiveComponent.node,
            executor: (ctx, funcDef, args) => {
              return this.executeUserDefinedFunctionSync(ctx, funcDef, args);
            }
          });
        }
      });
    });
  }
  /**
   * Apply one or more attribute sets to an element.
   * Parses space-separated attribute set names and applies them.
   * @param context The Expression Context.
   * @param element The element to apply attributes to.
   * @param setNames Space-separated attribute set names.
   */
  applyAttributeSets(context, element, setNames) {
    return __async(this, null, function* () {
      if (!setNames || !setNames.trim()) {
        return;
      }
      const names = setNames.trim().split(/\s+/);
      const processedSets = /* @__PURE__ */ new Set();
      for (const name of names) {
        yield this.applyAttributeSet(context, element, name, processedSets);
      }
    });
  }
  /**
   * Apply a single attribute set to an element.
   * Handles recursive attribute sets with cycle detection.
   * @param context The Expression Context.
   * @param element The element to apply attributes to.
   * @param setName The name of the attribute set to apply.
   * @param processedSets Set of already-processed attribute set names (for cycle detection).
   */
  applyAttributeSet(context, element, setName, processedSets) {
    return __async(this, null, function* () {
      if (processedSets.has(setName)) {
        return;
      }
      processedSets.add(setName);
      const attributeNodes = this.attributeSets.get(setName);
      if (!attributeNodes) {
        return;
      }
      for (const attrNode of attributeNodes) {
        let nestedSets = null;
        const ownerNode = attrNode.parentNode;
        if (ownerNode) {
          nestedSets = xmlGetAttribute(ownerNode, "use-attribute-sets");
        }
        if (nestedSets) {
          for (const nestedName of nestedSets.trim().split(/\s+/)) {
            if (nestedName) {
              yield this.applyAttributeSet(context, element, nestedName, processedSets);
            }
          }
        }
        const nameExpr = xmlGetAttribute(attrNode, "name");
        const name = this.xsltAttributeValue(nameExpr, context);
        const documentFragment = domCreateDocumentFragment(this.outputDocument);
        yield this.xsltChildNodes(context, attrNode, documentFragment);
        const value = xmlValueLegacyBehavior(documentFragment);
        domSetAttribute(element, name, value);
      }
    });
  }
  /**
   * Test if an element is a supported extension.
   * Returns false for unrecognized elements in non-XSLT namespaces.
   * @param node The element to test.
   * @returns True if the element is supported, false if it's an unrecognized extension.
   */
  isExtensionElementSupported(node) {
    if (node.nodeType !== DOM_ELEMENT_NODE) {
      return true;
    }
    const namespaceUri = node.namespaceUri;
    if (!namespaceUri) {
      return true;
    }
    if (this.isXsltElement(node)) {
      return true;
    }
    if (!this.supportedExtensions.has(namespaceUri)) {
      return false;
    }
    return true;
  }
  /**
   * Get the fallback element from an extension element if it exists.
   * Searches for the first direct xsl:fallback child.
   * @param node The extension element.
   * @returns The fallback element, or null if not found.
   */
  getFallbackElement(node) {
    for (const child of node.childNodes) {
      if (child.nodeType === DOM_ELEMENT_NODE && this.isXsltElement(child, "fallback")) {
        return child;
      }
    }
    return null;
  }
  /**
   * Process an extension element with fallback support.
   * If a fallback is defined, executes it; otherwise treats element as literal.
   * @param context The Expression Context.
   * @param element The extension element.
   * @param output The output node.
   */
  xsltExtensionElement(context, element, output) {
    return __async(this, null, function* () {
      const fallback = this.getFallbackElement(element);
      if (fallback) {
        yield this.xsltChildNodes(context, fallback, output);
      } else {
        yield this.xsltPassThrough(context, element, output);
      }
    });
  }
  /**
   * Test if the given element is an XSLT element, optionally the one with the given name.
   * @param {XNode} element The element.
   * @param {string} opt_wantedName The name for comparison.
   * @returns True, if element is an XSL node. False otherwise.
   */
  isXsltElement(element, opt_wantedName) {
    if (opt_wantedName && element.localName != opt_wantedName) return false;
    if (element.namespaceUri) return element.namespaceUri === "http://www.w3.org/1999/XSL/Transform";
    return element.prefix === "xsl";
  }
};
export {
  ExprContext,
  XPath,
  XmlParser,
  Xslt,
  xmlEscapeText
};
//# sourceMappingURL=index.mjs.map